--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.3
-- Dumped by pg_dump version 9.6.3

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: qwat_dr; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA qwat_dr;


ALTER SCHEMA qwat_dr OWNER TO postgres;

--
-- Name: qwat_od; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA qwat_od;


ALTER SCHEMA qwat_od OWNER TO postgres;

--
-- Name: qwat_sys; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA qwat_sys;


ALTER SCHEMA qwat_sys OWNER TO postgres;

--
-- Name: qwat_vl; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA qwat_vl;


ALTER SCHEMA qwat_vl OWNER TO postgres;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- Name: postgis; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA public;


--
-- Name: EXTENSION postgis; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgis IS 'PostGIS geometry, geography, and raster spatial types and functions';


SET search_path = qwat_od, pg_catalog;

--
-- Name: element_type; Type: TYPE; Schema: qwat_od; Owner: postgres
--

CREATE TYPE element_type AS ENUM (
    'element',
    'subscriber',
    'part',
    'installation',
    'hydrant',
    'samplingpoint',
    'valve',
    'meter'
);


ALTER TYPE element_type OWNER TO postgres;

--
-- Name: installation_type; Type: TYPE; Schema: qwat_od; Owner: postgres
--

CREATE TYPE installation_type AS ENUM (
    'installation',
    'source',
    'pump',
    'tank',
    'treatment',
    'chamber',
    'pressurecontrol'
);


ALTER TYPE installation_type OWNER TO postgres;

--
-- Name: node_type; Type: TYPE; Schema: qwat_od; Owner: postgres
--

CREATE TYPE node_type AS ENUM (
    'node',
    'element'
);


ALTER TYPE node_type OWNER TO postgres;

--
-- Name: pipe_connection; Type: TYPE; Schema: qwat_od; Owner: postgres
--

CREATE TYPE pipe_connection AS ENUM (
    'pipe_end',
    'couple_same',
    'couple_year',
    'couple_diameter',
    'couple_material',
    'couple_other',
    'T'
);


ALTER TYPE pipe_connection OWNER TO postgres;

SET search_path = qwat_sys, pg_catalog;

--
-- Name: version_result; Type: TYPE; Schema: qwat_sys; Owner: postgres
--

CREATE TYPE version_result AS (
	version_short character varying,
	major integer,
	minor integer,
	patch integer,
	prerelease character varying,
	metadata character varying
);


ALTER TYPE version_result OWNER TO postgres;

SET search_path = qwat_dr, pg_catalog;

--
-- Name: ft_dimension_distance_distance(); Type: FUNCTION; Schema: qwat_dr; Owner: postgres
--

CREATE FUNCTION ft_dimension_distance_distance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW._calculation := ST_Distance( ST_StartPoint(NEW.geometry), ST_EndPoint(NEW.geometry) );
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_dr.ft_dimension_distance_distance() OWNER TO postgres;

--
-- Name: FUNCTION ft_dimension_distance_distance(); Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON FUNCTION ft_dimension_distance_distance() IS 'Fcn/Trigger: updates the distance between the two extremities of the arc.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: fn_get_district(public.geometry); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_get_district(public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		geom ALIAS FOR $1;
		fk_district integer;
	BEGIN
		SELECT district.id INTO fk_district
			FROM  qwat_od.district
			WHERE ST_Intersects(geom,district.geometry) IS TRUE
			LIMIT 1;
		RETURN fk_district;
	END;
$_$;


ALTER FUNCTION qwat_od.fn_get_district(public.geometry) OWNER TO postgres;

--
-- Name: FUNCTION fn_get_district(public.geometry); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_get_district(public.geometry) IS 'Returns the id of the first overlapping district.';


--
-- Name: fn_get_pressurezone(public.geometry); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_get_pressurezone(public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ 
	DECLARE
		geom ALIAS FOR $1;
		fk_pressurezone integer;
	BEGIN
		SELECT pressurezone.id INTO fk_pressurezone
			FROM  qwat_od.pressurezone
			WHERE ST_Intersects(geom,pressurezone.geometry) IS TRUE
			ORDER BY ST_Length(ST_Intersection(geom,pressurezone.geometry)) DESC
			LIMIT 1;
		RETURN fk_pressurezone;
	END
$_$;


ALTER FUNCTION qwat_od.fn_get_pressurezone(public.geometry) OWNER TO postgres;

--
-- Name: FUNCTION fn_get_pressurezone(public.geometry); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_get_pressurezone(public.geometry) IS 'Returns the id of the first overlapping pressurezone.';


--
-- Name: fn_get_printmap_id(public.geometry); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_get_printmap_id(public.geometry) RETURNS integer[]
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		geom ALIAS FOR $1;
	BEGIN
		RETURN ARRAY( SELECT printmap.id FROM  qwat_od.printmap WHERE ST_Intersects(geom,printmap.geometry) IS TRUE);
	END;
$_$;


ALTER FUNCTION qwat_od.fn_get_printmap_id(public.geometry) OWNER TO postgres;

--
-- Name: FUNCTION fn_get_printmap_id(public.geometry); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_get_printmap_id(public.geometry) IS 'Returns the id of the first overlapping printmap.';


--
-- Name: fn_get_printmaps(public.geometry); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_get_printmaps(public.geometry) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		geom ALIAS FOR $1;
		result text;
	BEGIN
		SELECT string_agg(printmap.name , ', ') INTO result
			FROM  qwat_od.printmap
			WHERE ST_Intersects(geom,printmap.geometry) IS TRUE;
		RETURN result;
	END;
$_$;


ALTER FUNCTION qwat_od.fn_get_printmaps(public.geometry) OWNER TO postgres;

--
-- Name: FUNCTION fn_get_printmaps(public.geometry); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_get_printmaps(public.geometry) IS 'Returns a string contaning all the short names of the polygons in table printmap which overlap the given geometry.';


--
-- Name: fn_litres_per_cm(integer, double precision, double precision); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_litres_per_cm(fk_type integer, dim1 double precision, dim2 double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF fk_type = 1 THEN
			return pi()*(dim1/2)^2*10;
		ELSEIF fk_type = 2 THEN
			return dim2*dim2*10;
		ELSE
			return NULL;
		END IF;
	END
$$;


ALTER FUNCTION qwat_od.fn_litres_per_cm(fk_type integer, dim1 double precision, dim2 double precision) OWNER TO postgres;

--
-- Name: FUNCTION fn_litres_per_cm(fk_type integer, dim1 double precision, dim2 double precision); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_litres_per_cm(fk_type integer, dim1 double precision, dim2 double precision) IS 'Calculate the litres_per_cm of a tank cistern.';


--
-- Name: fn_node_create(public.geometry, boolean); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_node_create(_point public.geometry, deactivate_node_add_pipe_vertex boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		_node_id integer;
	BEGIN
		SELECT id FROM qwat_od.node WHERE ST_Equals(ST_Force2d(_point), ST_Force2d(node.geometry)) IS TRUE LIMIT 1 INTO _node_id;
		IF _node_id IS NULL THEN
                        IF deactivate_node_add_pipe_vertex THEN
                           -- if we are called from a pipe creation, do not try to add a vertex on the pipe
                           ALTER TABLE qwat_od.node DISABLE TRIGGER tr_node_add_pipe_vertex_insert;
                        END IF;
			INSERT INTO qwat_od.node (geometry) VALUES (ST_Force3D(_point)) RETURNING id INTO _node_id;
                        IF deactivate_node_add_pipe_vertex THEN
                           ALTER TABLE qwat_od.node ENABLE TRIGGER tr_node_add_pipe_vertex_insert;
                        END IF;
			IF _node_id IS NULL THEN
				RAISE EXCEPTION 'Node is null although it should have been created';
			END IF;
		END IF;
		RETURN _node_id;
	END;
$$;


ALTER FUNCTION qwat_od.fn_node_create(_point public.geometry, deactivate_node_add_pipe_vertex boolean) OWNER TO postgres;

--
-- Name: FUNCTION fn_node_create(_point public.geometry, deactivate_node_add_pipe_vertex boolean); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_node_create(_point public.geometry, deactivate_node_add_pipe_vertex boolean) IS 'Returns the node for a given geometry (point). If node does not exist, create it.';


--
-- Name: fn_node_get_ids(public.box2d); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_node_get_ids(extent public.box2d DEFAULT NULL::public.box2d) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
	DECLARE
		node_ids integer[];
	BEGIN
		IF extent IS NULL THEN
			SELECT ARRAY( SELECT id FROM qwat_od.node ) INTO node_ids;
		ELSE
			SELECT ARRAY( SELECT id FROM qwat_od.node WHERE node.geometry && extent ) INTO node_ids;
		END IF;
		RETURN node_ids;
	END;
$$;


ALTER FUNCTION qwat_od.fn_node_get_ids(extent public.box2d) OWNER TO postgres;

--
-- Name: FUNCTION fn_node_get_ids(extent public.box2d); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_node_get_ids(extent public.box2d) IS 'Returns a list of node IDs contained a given extent.';


--
-- Name: fn_node_set_type(integer[]); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_node_set_type(_node_ids integer[] DEFAULT NULL::integer[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
	DECLARE
		node record;
		_node_id integer;
	BEGIN
		IF _node_ids IS NULL THEN
			FOR node IN (SELECT id FROM qwat_od.node ORDER BY id) LOOP
				PERFORM qwat_od.fn_node_set_type(node.id);
			END LOOP;
		ELSE
			FOREACH _node_id IN ARRAY _node_ids LOOP
				PERFORM qwat_od.fn_node_set_type(_node_id);
			END LOOP;
		END IF;
	END;
$$;


ALTER FUNCTION qwat_od.fn_node_set_type(_node_ids integer[]) OWNER TO postgres;

--
-- Name: FUNCTION fn_node_set_type(_node_ids integer[]); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_node_set_type(_node_ids integer[]) IS 'Set the type and orientation for node. If three pipe arrives at the node: intersection. If one pipe: end. If two: depends on characteristics of pipe: year (is different), material (and year), diameter(and material/year)';


--
-- Name: fn_node_set_type(integer); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_node_set_type(_node_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
	DECLARE
		_pipeitem     record;
		_pipe_id      integer;
		_grouped      record;
		_year         integer;
		_material     varchar(50);
		_diameter     smallint;
		_looppos      integer          := 0;
		_type         qwat_od.pipe_connection;
		_orientation  double precision := 0;
		_orientation2 double precision := 0;
		_node_geom    geometry;
		_pipe_geom    geometry;
		_sub_geom     geometry;
		_lin_ref      float;
	BEGIN

		-- get the geoemetry
		_node_geom := geometry FROM qwat_od.node WHERE id = _node_id;

		-- count the active pipes associated to this node
		SELECT
				COUNT(pipe.id) AS count,
				bool_or(coalesce(schema_force_visible,pipe_function.schema_visible)) AS schema_visible
			INTO _grouped
			FROM qwat_od.pipe
				INNER JOIN qwat_vl.status ON pipe.fk_status = status.id
				INNER JOIN qwat_vl.pipe_function ON pipe.fk_function = pipe_function.id
			WHERE (fk_node_a = _node_id OR fk_node_b = _node_id)
				AND status.active IS TRUE;

		-- if not connected to any pipe, delete the node if it is not something else (i.e. is not inherited)
		IF _grouped.count = 0 THEN
			-- check it is not associated to any pipe (including inactive ones)
			IF _node_id NOT IN (SELECT fk_node_a FROM qwat_od.pipe UNION SELECT fk_node_b FROM qwat_od.pipe) THEN
				-- if it is not something else
				IF ( SELECT node_type = 'node'::qwat_od.node_type FROM qwat_od.vw_qwat_node WHERE id = _node_id) THEN
					-- delete it
					RAISE NOTICE 'Delete node %' , _node_id;
					DELETE FROM qwat_od.node WHERE id = _node_id; -- delete on table level for safety (do not delete on the merge view)
					RETURN;
				-- otherwise this means the node is node at the end of a pipe, it must be on a vertex
				ELSE
					-- calculate the orientation on that vertex
					_pipe_geom := geometry 
									FROM qwat_od.pipe 
									WHERE ST_Intersects(pipe.geometry, _node_geom) 
									ORDER BY (
										_node_geom IN (
											ST_StartPoint(pipe.geometry),
											ST_EndPoint(pipe.geometry))
										)::integer ASC -- prefer a pipe which doesn't end on the valve
									LIMIT 1;
					
					IF _pipe_geom IS NULL THEN
						RAISE NOTICE 'Network element of type % with ID % is not located on a pipe!'
							, element_type FROM qwat_od.vw_qwat_network_element WHERE id = _node_id
							, _node_id ;
					ELSE
						_lin_ref := ST_LineLocatePoint(_pipe_geom,_node_geom); -- shouldn't be 0 or 1 as it would mean that the node is a pipe end

						_sub_geom := ST_LineSubstring( _pipe_geom, 0, _lin_ref);
						_orientation  := pi()/2 - ST_Azimuth( 	ST_PointN(_sub_geom, ST_NumPoints(_sub_geom)-1),
																ST_EndPoint(_sub_geom) );
						_sub_geom := ST_LineSubstring( _pipe_geom, _lin_ref, 1);
						_orientation2 := pi()/2 - ST_Azimuth( 	ST_PointN(_sub_geom, 2),
																ST_StartPoint(_sub_geom) );
						_orientation2 := pi() + _orientation2; -- reverse angle
						-- RAISE NOTICE 'pipe 1 %', degrees( _orientation );
						-- RAISE NOTICE 'pipe 2 %', degrees( _orientation2 );
						_orientation := ATAN2( (SIN(_orientation)+SIN(_orientation2))/2 , (COS(_orientation)+COS(_orientation2))/2 );
						-- RAISE NOTICE 'mean %', degrees( _orientation );
					END IF;
				END IF;
			ELSE
				_type := NULL::qwat_od.pipe_connection;
			END IF;
		-- if 1 or 2 pipes associated
		ELSEIF _grouped.count <= 2 THEN
			/* loop over them, and take the 2 first/last vertices
			 of the pipe to determine orientation (used for symbology) */
			FOR _pipeitem IN (
				SELECT 	pipe.id, pipe.year, pipe_material.value_fr AS material, pipe_material.diameter_nominal AS diameter,
						ST_StartPoint(geometry) AS point_1,
						ST_PointN(geometry,2)   AS point_2
						FROM qwat_od.pipe
						INNER JOIN qwat_vl.pipe_material ON pipe.fk_material = pipe_material.id
						INNER JOIN qwat_vl.status        ON pipe.fk_status = status.id
						WHERE fk_node_a = _node_id AND status.active IS TRUE
				UNION ALL
				SELECT	pipe.id, pipe.year, pipe_material.value_fr AS material, pipe_material.diameter_nominal AS diameter,
						ST_EndPoint(geometry)                      AS point_1,
						ST_PointN(geometry,ST_NPoints(geometry)-1) AS point_2
						FROM qwat_od.pipe
						INNER JOIN qwat_vl.pipe_material ON pipe.fk_material = pipe_material.id
						INNER JOIN qwat_vl.status        ON pipe.fk_status = status.id
						WHERE fk_node_b = _node_id AND status.active IS TRUE
			) LOOP
				IF _looppos=0 THEN
					-- first pipe
					_type := 'pipe_end'::qwat_od.pipe_connection;
					_year     := _pipeitem.year;
					_material := _pipeitem.material;
					_diameter := _pipeitem.diameter;
					_pipe_id   := _pipeitem.id;
					_looppos   := 1;
					_orientation := pi()/2 - ST_Azimuth(_pipeitem.point_2,_pipeitem.point_1);
					-- RAISE NOTICE 'pipe % %', _pipe_id, degrees( _orientation );
				ELSE
					-- second pipe if exists
					IF _material = _pipeitem.material AND _diameter = _pipeitem.diameter AND _year = _pipeitem.year THEN
						_type := 'couple_same'::qwat_od.pipe_connection;
					ELSIF _material = _pipeitem.material AND _diameter = _pipeitem.diameter THEN
						_type := 'couple_year'::qwat_od.pipe_connection;
					ELSIF _material = _pipeitem.material THEN
						_type := 'couple_diameter'::qwat_od.pipe_connection;
					ELSIF _diameter = _pipeitem.diameter THEN
						_type := 'couple_material'::qwat_od.pipe_connection;
					ELSE
						_type := 'couple_other';
					END IF;
					_orientation2 := pi()/2 - ST_Azimuth(_pipeitem.point_2,_pipeitem.point_1);
					_orientation2 := pi() + _orientation2; -- reverse angle
					-- RAISE NOTICE 'pipe % %', _pipeitem.id, degrees( _orientation2 );
					_orientation := ATAN2( (SIN(_orientation)+SIN(_orientation2))/2 , (COS(_orientation)+COS(_orientation2))/2 );
					-- RAISE NOTICE 'mean:  %', degrees(_orientation  );
					-- reverse arrow according to diameter reduction
					IF _pipeitem.diameter > _diameter THEN
						_orientation := _orientation + pi();
					END IF;
				END IF;
			END LOOP;
		-- more than 2 pipes connected, nothing to calculate
		ELSEIF _grouped.count > 2 THEN
			_type := 'T'::qwat_od.pipe_connection;
		END IF;

		-- update the node table
		UPDATE qwat_od.node SET
			_pipe_node_type      = _type,
			_pipe_orientation    = degrees(_orientation),
			_pipe_schema_visible = _grouped.schema_visible
			WHERE id = _node_id;
		--RAISE NOTICE '% %' , _node_id , degrees(_orientation);
	END;
$$;


ALTER FUNCTION qwat_od.fn_node_set_type(_node_id integer) OWNER TO postgres;

--
-- Name: FUNCTION fn_node_set_type(_node_id integer); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_node_set_type(_node_id integer) IS 'Set the orientation and type for a node. If three pipe arrives at the node: intersection. If one pipe: end. If two: depends on characteristics of pipe: year (is different), material (and year), diameter(and material/year)';


--
-- Name: fn_node_update_id(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_node_update_id() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare 
  node_table        record;
  stmt     text;
  max_id   integer;
begin
  FOR node_table IN SELECT * FROM qwat_od.node_table
    LOOP
    RAISE NOTICE '%', node_table.table_name;
    stmt := 'UPDATE qwat_od.' || node_table.table_name || ' SET fk_node = qwat_od.fn_get_node(geometry,false);';
    EXECUTE stmt;
  END LOOP;
end;
$$;


ALTER FUNCTION qwat_od.fn_node_update_id() OWNER TO postgres;

--
-- Name: fn_pipe_get_id(public.geometry); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_pipe_get_id(_geometry public.geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		_pipe_id integer := NULL;
	BEGIN
		_pipe_id := pipe.id FROM qwat_od.pipe 
			JOIN qwat_vl.status ON fk_status = status.id
			WHERE ST_Intersects(ST_Force2d(_geometry),ST_Force2d(pipe.geometry)) 
			ORDER BY status.active::integer DESC
			LIMIT 1;
		RETURN _pipe_id;
	END;
$$;


ALTER FUNCTION qwat_od.fn_pipe_get_id(_geometry public.geometry) OWNER TO postgres;

--
-- Name: FUNCTION fn_pipe_get_id(_geometry public.geometry); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION fn_pipe_get_id(_geometry public.geometry) IS 'Returns the pipe at a given position. If geometry is a point, do not return a pipe which ends on it.';


--
-- Name: fn_pipe_update_valve(integer); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_pipe_update_valve(_pipe_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
	BEGIN
		UPDATE qwat_od.pipe
			SET
				_valve_count  = valve_group.vcount,
				_valve_closed = valve_group.vclosed
			FROM qwat_od.pipe pipe_dupp
			INNER JOIN (
				SELECT fk_pipe, count(id) AS vcount, bool_or(closed) AS vclosed
				FROM qwat_od.valve
				WHERE fk_pipe = _pipe_id
				GROUP BY fk_pipe
				) AS valve_group
			ON pipe_dupp.id = valve_group.fk_pipe
			WHERE pipe.id = _pipe_id;
	END;
$$;


ALTER FUNCTION qwat_od.fn_pipe_update_valve(_pipe_id integer) OWNER TO postgres;

--
-- Name: fn_update_pipe_crossing(boolean, boolean); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_update_pipe_crossing(update_existing boolean DEFAULT true, delete_unused boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
	DECLARE
		_crossing record;
		_pipe1 record;
		_pipe2 record;
		_crossing_id integer;
		_updated_crossing integer[] := ARRAY[]::integer[];
		_inserted_crossing_count integer := 0;
		_updated_crossing_count integer := 0;
		_deleted_crossing_count integer := 0;
	BEGIN
/* * * * * * * * * * * * * * * * * * * * * * * * */
		/* compute all crossing points */
		FOR _crossing IN
			SELECT pipe1_id, pipe2_id,
				pipe1_geometry, pipe2_geometry,
				(dp).geom AS cross_geometry
			FROM
			(
				/* dump mulitpoints to points */
				SELECT pipe1_id, pipe2_id,
					pipe1_geometry, pipe2_geometry,
					ST_DumpPoints(cross_geometry) AS dp FROM
				(
					/* compute the crossing points only for active pipes and different ids */
					SELECT p1.id AS pipe1_id,
						p2.id AS pipe2_id,
						p1.geometry AS pipe1_geometry,
						p2.geometry AS pipe2_geometry,
						ST_Intersection(p1.geometry,p2.geometry) AS cross_geometry
					FROM qwat_od.pipe p1, qwat_od.pipe p2
					WHERE p1.id < p2.id
					AND p1.fk_status = 1301
					AND p2.fk_status = 1301
					AND ST_Crosses(p1.geometry,p2.geometry)
				) AS foo
			 ) AS foo2
		LOOP
/* * * * * * * * * * * * * * * * * * * * * * * * */
			/* SKIP INTERSECTION AT ENDS OF PIPE (occurs if the two pipes cross at another point) */
			IF _crossing.cross_geometry IN (ST_StartPoint(_crossing.pipe1_geometry), ST_EndPoint(_crossing.pipe1_geometry),
						ST_StartPoint(_crossing.pipe2_geometry), ST_EndPoint(_crossing.pipe2_geometry)) THEN
				CONTINUE;
			END IF;
/* * * * * * * * * * * * * * * * * * * * * * * * */
			/* !!!! PIPE 1 !!!! */
			/* perform azimuth for all segments of the pipes with the corresponding linear referencing */
			WITH azimuth AS
			(
				SELECT 	id AS pipe_id,
					n AS pt_index,
					ST_LineLocatePoint( geometry, ST_PointN( geometry, n) ) AS pt_locat,
					( 90 + degrees( ST_Azimuth( ST_PointN( geometry, n), ST_PointN( geometry, n+1 ) ) ) )::integer % 360 AS azimuth
				FROM qwat_od.pipe, generate_series(1, ST_NumPoints(geometry)-1) n
				WHERE pipe.id = _crossing.pipe1_id
			),
			/* find the correct segment according to linear referencing of the crossing point */
			pt_locat AS
			(
				SELECT MAX(pt_locat) AS pt_locat
				FROM azimuth
				WHERE pt_locat < ST_LineLocatePoint( _crossing.pipe1_geometry, _crossing.cross_geometry )
			)
			/* get the corresponding azimuth according to segment id (pt_locat) */
			SELECT azimuth
			INTO _pipe1
			FROM azimuth
			JOIN pt_locat USING (pt_locat);

/* * * * * * * * * * * * * * * * * * * * * * * * */
			/* !!!! PIPE 2 !!!! */
			/* perform azimuth for all segments of the pipes with the corresponding linear referencing */
			WITH azimuth AS
			(
				SELECT 	id AS pipe_id,
					n AS pt_index,
					ST_LineLocatePoint( geometry, ST_PointN( geometry, n) ) AS pt_locat,
					( 90 + degrees( ST_Azimuth( ST_PointN( geometry, n), ST_PointN( geometry, n+1 ) ) ) )::integer % 360 AS azimuth
				FROM qwat_od.pipe, generate_series(1, ST_NumPoints(geometry)-1) n
				WHERE pipe.id = _crossing.pipe2_id
			),
			/* find the correct segment according to linear referencing of the crossing point */
			pt_locat AS
			(
				SELECT MAX(pt_locat) AS pt_locat
				FROM azimuth
				WHERE pt_locat < ST_LineLocatePoint( _crossing.pipe2_geometry, _crossing.cross_geometry )
			)
			/* get the corresponding azimuth according to segment id (pt_locat) */
			SELECT azimuth
			INTO _pipe2
			FROM azimuth
			JOIN pt_locat USING (pt_locat);

/* * * * * * * * * * * * * * * * * * * * * * * * */
			/* ERROR REPORTING */
			IF _pipe1.azimuth IS NULL THEN
				RAISE NOTICE '*******';
				RAISE NOTICE 'POINT: %', ST_AsText(_crossing.cross_geometry);
				RAISE NOTICE 'PIPE: %', _crossing.pipe1_id;
				RAISE NOTICE 'LINE: %', ST_AsText(_crossing.pipe1_geometry);
			END IF;
			IF _pipe2.azimuth IS NULL THEN
				RAISE NOTICE '*******';
				RAISE NOTICE 'POINT: %', ST_AsText(_crossing.cross_geometry);
				RAISE NOTICE 'PIPE: %', _crossing.pipe2_id;
				RAISE NOTICE 'LINE: %', ST_AsText(_crossing.pipe2_geometry);
			END IF;
/* * * * * * * * * * * * * * * * * * * * * * * * */
			/* UPDATE OR INSERT NEW CROSSING */
			SELECT id FROM qwat_od.crossing WHERE ST_Equals(_crossing.cross_geometry,geometry) IS TRUE LIMIT 1 INTO _crossing_id;
			IF _crossing_id IS NULL THEN
				INSERT INTO qwat_od.crossing
						(         _pipe1_id,          _pipe2_id, _pipe1_angle,     _pipe2_angle,                 geometry )
					VALUES
						(_crossing.pipe1_id, _crossing.pipe2_id, _pipe1.azimuth, _pipe2.azimuth, ST_Force2d(_crossing.cross_geometry) )
					RETURNING id INTO _crossing_id;
				_inserted_crossing_count := _inserted_crossing_count + 1;
			ELSIF update_existing IS TRUE THEN
				UPDATE qwat_od.crossing
				SET
					_pipe1_id     = _crossing.pipe1_id,
					_pipe1_angle  = _pipe1.azimuth,
					_pipe2_id     = _crossing.pipe2_id,
					_pipe2_angle  = _pipe2.azimuth,
					geometry      = ST_Force2d(_crossing.cross_geometry)
				WHERE crossing.id = _crossing_id;
				_updated_crossing_count := _updated_crossing_count + 1;
			END IF;
			_updated_crossing := array_append(_updated_crossing, _crossing_id);
		END LOOP;
/* * * * * * * * * * * * * * * * * * * * * * * * */
		/* DELETE OLD CROSSINGS */
		IF delete_unused IS TRUE THEN
			DELETE FROM qwat_od.crossing WHERE NOT ( id = ANY(_updated_crossing) );
			GET DIAGNOSTICS _deleted_crossing_count = ROW_COUNT;
		END IF;
		RAISE NOTICE '';
		RAISE NOTICE '* * * * * * * * * * * * * * * * *';
		RAISE NOTICE '';
		RAISE NOTICE 'Added % new crossing.', _inserted_crossing_count;
		RAISE NOTICE 'Updated % existing crossing.', _updated_crossing_count;
		RAISE NOTICE 'Deleted % unused crossing.', _deleted_crossing_count;
		RAISE NOTICE '';
		RAISE NOTICE '* * * * * * * * * * * * * * * * *';
		RAISE NOTICE '';
	END;
$$;


ALTER FUNCTION qwat_od.fn_update_pipe_crossing(update_existing boolean, delete_unused boolean) OWNER TO postgres;

--
-- Name: fn_update_sequences(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION fn_update_sequences() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare 
  r        record;
  stmt     text;
  max_id   integer;
begin
  for r in (
              select *
              from (
                select table_schema, 
                       table_name, 
                       column_name, 
                       pg_get_serial_sequence(table_schema||'.'||table_name, column_name) as col_sequence
                from information_schema.columns
                where table_schema = 'qwat_od'
              ) t
              where col_sequence is not null
        ) 
  loop
    stmt := 'select coalesce(max('||r.column_name||'), 0) + 1 from '||r.table_schema||'.'||r.table_name;
    execute stmt into max_id;
    raise notice 'Next ID for %.%.% is %', r.table_schema, r.table_name, r.column_name, max_id;
    perform setval(r.col_sequence, max_id); 
  end loop;
end;
$$;


ALTER FUNCTION qwat_od.fn_update_sequences() OWNER TO postgres;

--
-- Name: ft_controled_crossing(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_controled_crossing() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW.controled = true;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_controled_crossing() OWNER TO postgres;

--
-- Name: ft_element_hydrant_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_hydrant_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.hydrant WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_hydrant_delete() OWNER TO postgres;

--
-- Name: ft_element_hydrant_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_hydrant_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.hydrant (
			id
			, fk_provider
			, fk_model_sup
			, fk_model_inf
			, fk_material
			, fk_output
			, underground
			, marked
			, pressure_static
			, pressure_dynamic
			, flow
			, observation_date
			, observation_source
		) VALUES (
			NEW.id 
			, NEW.fk_provider
			, NEW.fk_model_sup
			, NEW.fk_model_inf
			, NEW.fk_material
			, NEW.fk_output
			, NEW.underground
			, NEW.marked
			, NEW.pressure_static
			, NEW.pressure_dynamic
			, NEW.flow
			, NEW.observation_date
			, NEW.observation_source
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_hydrant_insert() OWNER TO postgres;

--
-- Name: ft_element_hydrant_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_hydrant_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;

	UPDATE qwat_od.hydrant SET
			fk_provider = NEW.fk_provider,
			fk_model_sup = NEW.fk_model_sup,
			fk_model_inf = NEW.fk_model_inf,
			fk_material = NEW.fk_material,
			fk_output = NEW.fk_output,
			underground = NEW.underground,
			marked = NEW.marked,
			pressure_static = NEW.pressure_static,
			pressure_dynamic = NEW.pressure_dynamic,
			flow = NEW.flow,
			observation_date = NEW.observation_date,
			observation_source = NEW.observation_source
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_hydrant_update() OWNER TO postgres;

--
-- Name: ft_element_installation_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_installation_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.vw_qwat_installation WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_installation_delete() OWNER TO postgres;

--
-- Name: ft_element_installation_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_installation_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.vw_qwat_installation (
			id
			, installation_type
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
			, fk_source_type
			, fk_source_quality
			, flow_lowest
			, flow_average
			, flow_concession
			, contract_end
			, gathering_chamber
			, fk_pump_type
			, fk_pipe_in
			, fk_pipe_out
			, fk_pump_operating
			, no_pumps
			, rejected_flow
			, manometric_height
			, fk_overflow
			, fk_tank_firestorage
			, storage_total
			, storage_supply
			, storage_fire
			, altitude_overflow
			, altitude_apron
			, height_max
			, fire_valve
			, fire_remote
			, _litrepercm
			, cistern1_fk_type
			, cistern1_dimension_1
			, cistern1_dimension_2
			, cistern1_storage
			, _cistern1_litrepercm
			, cistern2_fk_type
			, cistern2_dimension_1
			, cistern2_dimension_2
			, cistern2_storage
			, _cistern2_litrepercm
			, sanitization_uv
			, sanitization_chlorine_liquid
			, sanitization_chlorine_gazeous
			, sanitization_ozone
			, filtration_membrane
			, filtration_sandorgravel
			, flocculation
			, activatedcharcoal
			, settling
			, treatment_capacity
			, networkseparation
			, flow_meter
			, water_meter
			, manometer
			, depth
			, no_valves
			, fk_pressurecontrol_type
		) VALUES (
			NEW.id 
			, NEW.installation_type
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
			, NEW.fk_source_type
			, NEW.fk_source_quality
			, NEW.flow_lowest
			, NEW.flow_average
			, NEW.flow_concession
			, NEW.contract_end
			, NEW.gathering_chamber
			, NEW.fk_pump_type
			, NEW.fk_pipe_in
			, NEW.fk_pipe_out
			, NEW.fk_pump_operating
			, NEW.no_pumps
			, NEW.rejected_flow
			, NEW.manometric_height
			, NEW.fk_overflow
			, NEW.fk_tank_firestorage
			, NEW.storage_total
			, NEW.storage_supply
			, NEW.storage_fire
			, NEW.altitude_overflow
			, NEW.altitude_apron
			, NEW.height_max
			, NEW.fire_valve
			, NEW.fire_remote
			, NEW._litrepercm
			, NEW.cistern1_fk_type
			, NEW.cistern1_dimension_1
			, NEW.cistern1_dimension_2
			, NEW.cistern1_storage
			, NEW._cistern1_litrepercm
			, NEW.cistern2_fk_type
			, NEW.cistern2_dimension_1
			, NEW.cistern2_dimension_2
			, NEW.cistern2_storage
			, NEW._cistern2_litrepercm
			, NEW.sanitization_uv
			, NEW.sanitization_chlorine_liquid
			, NEW.sanitization_chlorine_gazeous
			, NEW.sanitization_ozone
			, NEW.filtration_membrane
			, NEW.filtration_sandorgravel
			, NEW.flocculation
			, NEW.activatedcharcoal
			, NEW.settling
			, NEW.treatment_capacity
			, NEW.networkseparation
			, NEW.flow_meter
			, NEW.water_meter
			, NEW.manometer
			, NEW.depth
			, NEW.no_valves
			, NEW.fk_pressurecontrol_type
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_installation_insert() OWNER TO postgres;

--
-- Name: ft_element_installation_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_installation_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;

	UPDATE qwat_od.vw_qwat_installation SET
			installation_type = NEW.installation_type,
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon,
			fk_source_type = NEW.fk_source_type,
			fk_source_quality = NEW.fk_source_quality,
			flow_lowest = NEW.flow_lowest,
			flow_average = NEW.flow_average,
			flow_concession = NEW.flow_concession,
			contract_end = NEW.contract_end,
			gathering_chamber = NEW.gathering_chamber,
			fk_pump_type = NEW.fk_pump_type,
			fk_pipe_in = NEW.fk_pipe_in,
			fk_pipe_out = NEW.fk_pipe_out,
			fk_pump_operating = NEW.fk_pump_operating,
			no_pumps = NEW.no_pumps,
			rejected_flow = NEW.rejected_flow,
			manometric_height = NEW.manometric_height,
			fk_overflow = NEW.fk_overflow,
			fk_tank_firestorage = NEW.fk_tank_firestorage,
			storage_total = NEW.storage_total,
			storage_supply = NEW.storage_supply,
			storage_fire = NEW.storage_fire,
			altitude_overflow = NEW.altitude_overflow,
			altitude_apron = NEW.altitude_apron,
			height_max = NEW.height_max,
			fire_valve = NEW.fire_valve,
			fire_remote = NEW.fire_remote,
			_litrepercm = NEW._litrepercm,
			cistern1_fk_type = NEW.cistern1_fk_type,
			cistern1_dimension_1 = NEW.cistern1_dimension_1,
			cistern1_dimension_2 = NEW.cistern1_dimension_2,
			cistern1_storage = NEW.cistern1_storage,
			_cistern1_litrepercm = NEW._cistern1_litrepercm,
			cistern2_fk_type = NEW.cistern2_fk_type,
			cistern2_dimension_1 = NEW.cistern2_dimension_1,
			cistern2_dimension_2 = NEW.cistern2_dimension_2,
			cistern2_storage = NEW.cistern2_storage,
			_cistern2_litrepercm = NEW._cistern2_litrepercm,
			sanitization_uv = NEW.sanitization_uv,
			sanitization_chlorine_liquid = NEW.sanitization_chlorine_liquid,
			sanitization_chlorine_gazeous = NEW.sanitization_chlorine_gazeous,
			sanitization_ozone = NEW.sanitization_ozone,
			filtration_membrane = NEW.filtration_membrane,
			filtration_sandorgravel = NEW.filtration_sandorgravel,
			flocculation = NEW.flocculation,
			activatedcharcoal = NEW.activatedcharcoal,
			settling = NEW.settling,
			treatment_capacity = NEW.treatment_capacity,
			networkseparation = NEW.networkseparation,
			flow_meter = NEW.flow_meter,
			water_meter = NEW.water_meter,
			manometer = NEW.manometer,
			depth = NEW.depth,
			no_valves = NEW.no_valves,
			fk_pressurecontrol_type = NEW.fk_pressurecontrol_type
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_installation_update() OWNER TO postgres;

--
-- Name: ft_element_meter_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_meter_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.meter WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_meter_delete() OWNER TO postgres;

--
-- Name: ft_element_meter_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_meter_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.meter (
			id
			, fk_pipe
			, parcel
		) VALUES (
			NEW.id 
			, NEW.fk_pipe
			, NEW.parcel
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_meter_insert() OWNER TO postgres;

--
-- Name: ft_element_meter_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_meter_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;

	UPDATE qwat_od.meter SET
			fk_pipe = NEW.fk_pipe,
			parcel = NEW.parcel
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_meter_update() OWNER TO postgres;

--
-- Name: ft_element_part_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_part_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.part WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_part_delete() OWNER TO postgres;

--
-- Name: ft_element_part_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_part_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.part (
			id
			, fk_part_type
			, fk_pipe
		) VALUES (
			NEW.id 
			, NEW.fk_part_type
			, qwat_od.fn_pipe_get_id(NEW.geometry)
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_part_insert() OWNER TO postgres;

--
-- Name: ft_element_part_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_part_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;

	UPDATE qwat_od.part SET
			fk_part_type = NEW.fk_part_type,
			fk_pipe = qwat_od.fn_pipe_get_id(NEW.geometry)
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_part_update() OWNER TO postgres;

--
-- Name: ft_element_samplingpoint_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_samplingpoint_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.samplingpoint WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_samplingpoint_delete() OWNER TO postgres;

--
-- Name: ft_element_samplingpoint_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_samplingpoint_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.samplingpoint (
			id
			
		) VALUES (
			NEW.id 
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_samplingpoint_insert() OWNER TO postgres;

--
-- Name: ft_element_samplingpoint_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_samplingpoint_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_samplingpoint_update() OWNER TO postgres;

--
-- Name: ft_element_subscriber_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_subscriber_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.subscriber WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_subscriber_delete() OWNER TO postgres;

--
-- Name: ft_element_subscriber_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_subscriber_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.subscriber (
			id
			, fk_subscriber_type
			, fk_pipe
			, parcel
			, flow_current
			, flow_planned
		) VALUES (
			NEW.id 
			, NEW.fk_subscriber_type
			, NEW.fk_pipe
			, NEW.parcel
			, NEW.flow_current
			, NEW.flow_planned
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_subscriber_insert() OWNER TO postgres;

--
-- Name: ft_element_subscriber_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_subscriber_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;

	UPDATE qwat_od.subscriber SET
			fk_subscriber_type = NEW.fk_subscriber_type,
			fk_pipe = NEW.fk_pipe,
			parcel = NEW.parcel,
			flow_current = NEW.flow_current,
			flow_planned = NEW.flow_planned
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_subscriber_update() OWNER TO postgres;

--
-- Name: ft_element_valve_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_valve_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.valve WHERE id = OLD.id;
		DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_valve_delete() OWNER TO postgres;

--
-- Name: ft_element_valve_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_valve_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.valve (
			id
			, fk_valve_type
			, fk_valve_function
			, fk_valve_actuation
			, fk_pipe
			, fk_handle_precision
			, fk_handle_precisionalti
			, fk_maintenance
			, diameter_nominal
			, closed
			, networkseparation
			, handle_altitude
			, handle_geometry
		) VALUES (
			NEW.id 
			, NEW.fk_valve_type
			, NEW.fk_valve_function
			, NEW.fk_valve_actuation
			, qwat_od.fn_pipe_get_id(NEW.geometry)
			, NEW.fk_handle_precision
			, NEW.fk_handle_precisionalti
			, NEW.fk_maintenance
			, NEW.diameter_nominal
			, NEW.closed
			, NEW.networkseparation
			, NEW.handle_altitude
			, NEW.handle_geometry
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_valve_insert() OWNER TO postgres;

--
-- Name: ft_element_valve_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_element_valve_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;

	UPDATE qwat_od.valve SET
			fk_valve_type = NEW.fk_valve_type,
			fk_valve_function = NEW.fk_valve_function,
			fk_valve_actuation = NEW.fk_valve_actuation,
			fk_pipe = qwat_od.fn_pipe_get_id(NEW.geometry),
			fk_handle_precision = NEW.fk_handle_precision,
			fk_handle_precisionalti = NEW.fk_handle_precisionalti,
			fk_maintenance = NEW.fk_maintenance,
			diameter_nominal = NEW.diameter_nominal,
			closed = NEW.closed,
			networkseparation = NEW.networkseparation,
			handle_altitude = NEW.handle_altitude,
			handle_geometry = NEW.handle_geometry
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_element_valve_update() OWNER TO postgres;

--
-- Name: ft_geom3d_altitude(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_geom3d_altitude() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		-- altitude is prioritary on Z value of the geometry (if both changed, only altitude is taken into account)
		IF NEW.altitude IS NULL THEN
			NEW.altitude := NULLIF( ST_Z(NEW.geometry), 0.0); -- 0 is the NULL value
		END IF;
		IF 	NEW.altitude IS NULL     AND ST_Z(NEW.geometry) <> 0.0 OR
			NEW.altitude IS NOT NULL AND ( ST_Z(NEW.geometry) IS NULL OR ST_Z(NEW.geometry) <> NEW.altitude ) THEN
				NEW.geometry := ST_SetSRID( ST_MakePoint( ST_X(NEW.geometry), ST_Y(NEW.geometry), COALESCE(NEW.altitude,0) ), ST_SRID(NEW.geometry) );
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_geom3d_altitude() OWNER TO postgres;

--
-- Name: ft_geometry_alternative_aux(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_geometry_alternative_aux() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW._geometry_alt1_used := NEW.geometry_alt1 IS NOT NULL AND ST_Equals(ST_Force2d(NEW.geometry_alt1), ST_Force2d(NEW.geometry)) IS FALSE;
		NEW._geometry_alt2_used := NEW.geometry_alt2 IS NOT NULL AND ST_Equals(ST_Force2d(NEW.geometry_alt2), ST_Force2d(NEW.geometry)) IS FALSE;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_geometry_alternative_aux() OWNER TO postgres;

--
-- Name: ft_geometry_alternative_main(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_geometry_alternative_main() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.geometry_alt1 IS NULL OR NEW.update_geometry_alt1 IS TRUE OR ( TG_OP = 'UPDATE' AND NEW.update_geometry_alt1 IS NULL AND ST_Equals(OLD.geometry, OLD.geometry_alt1) ) THEN
			NEW.geometry_alt1 := NEW.geometry;
		END IF;
		IF NEW.geometry_alt2 IS NULL OR NEW.update_geometry_alt2 IS TRUE OR ( TG_OP = 'UPDATE' AND NEW.update_geometry_alt2 IS NULL AND ST_Equals(OLD.geometry, OLD.geometry_alt2) ) THEN
			NEW.geometry_alt2 := NEW.geometry;
		END IF;
		NEW._geometry_alt1_used := ST_Equals(ST_Force2d(NEW.geometry_alt1), ST_Force2d(NEW.geometry)) IS FALSE;
		NEW._geometry_alt2_used := ST_Equals(ST_Force2d(NEW.geometry_alt2), ST_Force2d(NEW.geometry)) IS FALSE;
		NEW.update_geometry_alt1 := NULL; -- used to determine if alternative geometry 1 should be updated when main geometry is updated
		NEW.update_geometry_alt2 := NULL; -- used to determine if alternative geometry 2 should be updated when main geometry is updated
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_geometry_alternative_main() OWNER TO postgres;

--
-- Name: ft_installation_chamber_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_chamber_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.chamber WHERE id = OLD.id;
		DELETE FROM qwat_od.installation WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_chamber_delete() OWNER TO postgres;

--
-- Name: ft_installation_chamber_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_chamber_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.chamber (
			id
			, networkseparation
			, flow_meter
			, water_meter
			, manometer
			, depth
			, no_valves
		) VALUES (
			NEW.id 
			, NEW.networkseparation
			, NEW.flow_meter
			, NEW.water_meter
			, NEW.manometer
			, NEW.depth
			, NEW.no_valves
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_chamber_insert() OWNER TO postgres;

--
-- Name: ft_installation_chamber_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_chamber_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;

	UPDATE qwat_od.chamber SET
			networkseparation = NEW.networkseparation,
			flow_meter = NEW.flow_meter,
			water_meter = NEW.water_meter,
			manometer = NEW.manometer,
			depth = NEW.depth,
			no_valves = NEW.no_valves
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_chamber_update() OWNER TO postgres;

--
-- Name: ft_installation_pressurecontrol_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_pressurecontrol_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.pressurecontrol WHERE id = OLD.id;
		DELETE FROM qwat_od.installation WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_pressurecontrol_delete() OWNER TO postgres;

--
-- Name: ft_installation_pressurecontrol_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_pressurecontrol_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.pressurecontrol (
			id
			, fk_pressurecontrol_type
		) VALUES (
			NEW.id 
			, NEW.fk_pressurecontrol_type
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_pressurecontrol_insert() OWNER TO postgres;

--
-- Name: ft_installation_pressurecontrol_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_pressurecontrol_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;

	UPDATE qwat_od.pressurecontrol SET
			fk_pressurecontrol_type = NEW.fk_pressurecontrol_type
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_pressurecontrol_update() OWNER TO postgres;

--
-- Name: ft_installation_pump_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_pump_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.pump WHERE id = OLD.id;
		DELETE FROM qwat_od.installation WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_pump_delete() OWNER TO postgres;

--
-- Name: ft_installation_pump_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_pump_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.pump (
			id
			, fk_pump_type
			, fk_pipe_in
			, fk_pipe_out
			, fk_pump_operating
			, no_pumps
			, rejected_flow
			, manometric_height
		) VALUES (
			NEW.id 
			, NEW.fk_pump_type
			, NEW.fk_pipe_in
			, NEW.fk_pipe_out
			, NEW.fk_pump_operating
			, NEW.no_pumps
			, NEW.rejected_flow
			, NEW.manometric_height
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_pump_insert() OWNER TO postgres;

--
-- Name: ft_installation_pump_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_pump_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;

	UPDATE qwat_od.pump SET
			fk_pump_type = NEW.fk_pump_type,
			fk_pipe_in = NEW.fk_pipe_in,
			fk_pipe_out = NEW.fk_pipe_out,
			fk_pump_operating = NEW.fk_pump_operating,
			no_pumps = NEW.no_pumps,
			rejected_flow = NEW.rejected_flow,
			manometric_height = NEW.manometric_height
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_pump_update() OWNER TO postgres;

--
-- Name: ft_installation_source_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_source_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.source WHERE id = OLD.id;
		DELETE FROM qwat_od.installation WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_source_delete() OWNER TO postgres;

--
-- Name: ft_installation_source_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_source_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.source (
			id
			, fk_source_type
			, fk_source_quality
			, flow_lowest
			, flow_average
			, flow_concession
			, contract_end
			, gathering_chamber
		) VALUES (
			NEW.id 
			, NEW.fk_source_type
			, NEW.fk_source_quality
			, NEW.flow_lowest
			, NEW.flow_average
			, NEW.flow_concession
			, NEW.contract_end
			, NEW.gathering_chamber
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_source_insert() OWNER TO postgres;

--
-- Name: ft_installation_source_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_source_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;

	UPDATE qwat_od.source SET
			fk_source_type = NEW.fk_source_type,
			fk_source_quality = NEW.fk_source_quality,
			flow_lowest = NEW.flow_lowest,
			flow_average = NEW.flow_average,
			flow_concession = NEW.flow_concession,
			contract_end = NEW.contract_end,
			gathering_chamber = NEW.gathering_chamber
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_source_update() OWNER TO postgres;

--
-- Name: ft_installation_tank_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_tank_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.tank WHERE id = OLD.id;
		DELETE FROM qwat_od.installation WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_tank_delete() OWNER TO postgres;

--
-- Name: ft_installation_tank_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_tank_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.tank (
			id
			, fk_overflow
			, fk_tank_firestorage
			, storage_total
			, storage_supply
			, storage_fire
			, altitude_overflow
			, altitude_apron
			, height_max
			, fire_valve
			, fire_remote
			, _litrepercm
			, cistern1_fk_type
			, cistern1_dimension_1
			, cistern1_dimension_2
			, cistern1_storage
			, _cistern1_litrepercm
			, cistern2_fk_type
			, cistern2_dimension_1
			, cistern2_dimension_2
			, cistern2_storage
			, _cistern2_litrepercm
		) VALUES (
			NEW.id 
			, NEW.fk_overflow
			, NEW.fk_tank_firestorage
			, NEW.storage_total
			, NEW.storage_supply
			, NEW.storage_fire
			, NEW.altitude_overflow
			, NEW.altitude_apron
			, NEW.height_max
			, NEW.fire_valve
			, NEW.fire_remote
			, NEW._litrepercm
			, NEW.cistern1_fk_type
			, NEW.cistern1_dimension_1
			, NEW.cistern1_dimension_2
			, NEW.cistern1_storage
			, NEW._cistern1_litrepercm
			, NEW.cistern2_fk_type
			, NEW.cistern2_dimension_1
			, NEW.cistern2_dimension_2
			, NEW.cistern2_storage
			, NEW._cistern2_litrepercm
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_tank_insert() OWNER TO postgres;

--
-- Name: ft_installation_tank_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_tank_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;

	UPDATE qwat_od.tank SET
			fk_overflow = NEW.fk_overflow,
			fk_tank_firestorage = NEW.fk_tank_firestorage,
			storage_total = NEW.storage_total,
			storage_supply = NEW.storage_supply,
			storage_fire = NEW.storage_fire,
			altitude_overflow = NEW.altitude_overflow,
			altitude_apron = NEW.altitude_apron,
			height_max = NEW.height_max,
			fire_valve = NEW.fire_valve,
			fire_remote = NEW.fire_remote,
			_litrepercm = NEW._litrepercm,
			cistern1_fk_type = NEW.cistern1_fk_type,
			cistern1_dimension_1 = NEW.cistern1_dimension_1,
			cistern1_dimension_2 = NEW.cistern1_dimension_2,
			cistern1_storage = NEW.cistern1_storage,
			_cistern1_litrepercm = NEW._cistern1_litrepercm,
			cistern2_fk_type = NEW.cistern2_fk_type,
			cistern2_dimension_1 = NEW.cistern2_dimension_1,
			cistern2_dimension_2 = NEW.cistern2_dimension_2,
			cistern2_storage = NEW.cistern2_storage,
			_cistern2_litrepercm = NEW._cistern2_litrepercm
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_tank_update() OWNER TO postgres;

--
-- Name: ft_installation_treatment_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_treatment_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.treatment WHERE id = OLD.id;
		DELETE FROM qwat_od.installation WHERE id = OLD.id;
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_treatment_delete() OWNER TO postgres;

--
-- Name: ft_installation_treatment_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_treatment_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

		INSERT INTO qwat_od.treatment (
			id
			, sanitization_uv
			, sanitization_chlorine_liquid
			, sanitization_chlorine_gazeous
			, sanitization_ozone
			, filtration_membrane
			, filtration_sandorgravel
			, flocculation
			, activatedcharcoal
			, settling
			, treatment_capacity
		) VALUES (
			NEW.id 
			, NEW.sanitization_uv
			, NEW.sanitization_chlorine_liquid
			, NEW.sanitization_chlorine_gazeous
			, NEW.sanitization_ozone
			, NEW.filtration_membrane
			, NEW.filtration_sandorgravel
			, NEW.flocculation
			, NEW.activatedcharcoal
			, NEW.settling
			, NEW.treatment_capacity
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_treatment_insert() OWNER TO postgres;

--
-- Name: ft_installation_treatment_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_installation_treatment_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;

	UPDATE qwat_od.treatment SET
			sanitization_uv = NEW.sanitization_uv,
			sanitization_chlorine_liquid = NEW.sanitization_chlorine_liquid,
			sanitization_chlorine_gazeous = NEW.sanitization_chlorine_gazeous,
			sanitization_ozone = NEW.sanitization_ozone,
			filtration_membrane = NEW.filtration_membrane,
			filtration_sandorgravel = NEW.filtration_sandorgravel,
			flocculation = NEW.flocculation,
			activatedcharcoal = NEW.activatedcharcoal,
			settling = NEW.settling,
			treatment_capacity = NEW.treatment_capacity
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_installation_treatment_update() OWNER TO postgres;

--
-- Name: ft_leak_pipe(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_leak_pipe() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.fk_pipe IS NULL THEN
			NEW.fk_pipe := qwat_od.fn_pipe_get_id(NEW.geometry);
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_leak_pipe() OWNER TO postgres;

--
-- Name: FUNCTION ft_leak_pipe(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_leak_pipe() IS 'Fcn/Trigger:get the pipe associated to the leak.';


--
-- Name: ft_leak_repaired(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_leak_repaired() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.repair_date IS NULL THEN
			NEW._repaired := false;
		ELSE
			NEW._repaired := true;
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_leak_repaired() OWNER TO postgres;

--
-- Name: FUNCTION ft_leak_repaired(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_leak_repaired() IS 'Fcn/Trigger: updates the repaired status of the leak.';


--
-- Name: ft_node_add_pipe_vertex(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_node_add_pipe_vertex() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
			-- add a vertex to the corresponding pipe if it intersects
			-- when the node is close enough to the pipe (< 1 micrometer) the node is considered to intersect the pipe
			-- it allows to deal with intersections that cannot be represented by floating point numbers
			UPDATE qwat_od.pipe SET geometry = ST_Snap(geometry, NEW.geometry, 1e-6) WHERE ST_Distance(geometry, NEW.geometry) < 1e-6;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_node_add_pipe_vertex() OWNER TO postgres;

--
-- Name: ft_node_element_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_node_element_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		DELETE FROM qwat_od.network_element WHERE id = OLD.id;
		PERFORM qwat_od.fn_node_set_type(OLD.id);
		RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_node_element_delete() OWNER TO postgres;

--
-- Name: ft_node_element_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_node_element_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		-- altitude is prioritary on Z value of the geometry (if both changed, only altitude is taken into account)
		IF NEW.altitude IS NULL THEN
			NEW.altitude := NULLIF( ST_Z(NEW.geometry), 0.0); -- 0 is the NULL value
		END IF;
		-- TODO handle going to NULL on update
		IF	NEW.altitude IS NULL     AND ST_Z(NEW.geometry) <> 0.0 OR
				NEW.altitude IS NOT NULL AND ( ST_Z(NEW.geometry) IS NULL OR ST_Z(NEW.geometry) <> NEW.altitude ) THEN
				NEW.geometry := ST_SetSRID( ST_MakePoint( ST_X(NEW.geometry), ST_Y(NEW.geometry), COALESCE(NEW.altitude,0) ), ST_SRID(NEW.geometry) );
		END IF;

		-- The function creates or gets a parent row.
		NEW.id := qwat_od.fn_node_create(NEW.geometry);
		-- If it previously existed with another subtype, it should raise an exception
		IF (SELECT _oid IS NOT NULL FROM 
			(
				SELECT id AS _oid FROM qwat_od.network_element
			) AS foo WHERE _oid = NEW.id
		) THEN
			RAISE EXCEPTION 'Cannot insert node as element since it already has another subtype. ID: %', NEW.id;
		END IF;

		INSERT INTO qwat_od.network_element (
			id
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		);
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_node_element_insert() OWNER TO postgres;

--
-- Name: ft_node_element_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_node_element_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN		-- altitude is prioritary on Z value of the geometry (if both changed, only altitude is taken into account)
		IF NEW.altitude IS NULL THEN
			NEW.altitude := NULLIF( ST_Z(NEW.geometry), 0.0); -- 0 is the NULL value
		END IF;
		-- TODO handle going to NULL on update
		IF	NEW.altitude IS NULL     AND ST_Z(NEW.geometry) <> 0.0 OR
				NEW.altitude IS NOT NULL AND ( ST_Z(NEW.geometry) IS NULL OR ST_Z(NEW.geometry) <> NEW.altitude ) THEN
				NEW.geometry := ST_SetSRID( ST_MakePoint( ST_X(NEW.geometry), ST_Y(NEW.geometry), COALESCE(NEW.altitude,0) ), ST_SRID(NEW.geometry) );
		END IF;


	UPDATE qwat_od.node SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2
		WHERE id = OLD.id;

	UPDATE qwat_od.network_element SET
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_node_element_update() OWNER TO postgres;

--
-- Name: ft_node_geom(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_node_geom() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW.geometry            := ST_Force3D(NEW.geometry);
		NEW.fk_district         := qwat_od.fn_get_district(NEW.geometry);
		NEW.fk_pressurezone     := qwat_od.fn_get_pressurezone(NEW.geometry);
		NEW.fk_printmap         := qwat_od.fn_get_printmap_id(NEW.geometry);
		NEW._printmaps          := qwat_od.fn_get_printmaps(NEW.geometry);
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_node_geom() OWNER TO postgres;

--
-- Name: ft_pipe_geom(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_pipe_geom() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF TG_OP = 'INSERT' OR ST_Equals(ST_StartPoint(NEW.geometry), ST_StartPoint(OLD.geometry)) IS FALSE THEN
			NEW.fk_node_a       := qwat_od.fn_node_create(ST_StartPoint(NEW.geometry), /* deactivate_node_add_pipe_vertex */ TRUE);
		END IF;
		IF TG_OP = 'INSERT' OR ST_Equals(ST_EndPoint(NEW.geometry), ST_EndPoint(OLD.geometry)) IS FALSE THEN
			NEW.fk_node_b       := qwat_od.fn_node_create(ST_EndPoint(NEW.geometry), /* deactivate_node_add_pipe_vertex */ TRUE);
		END IF;
		NEW.fk_district         := qwat_od.fn_get_district(NEW.geometry);
		NEW.fk_pressurezone     := qwat_od.fn_get_pressurezone(NEW.geometry);
		NEW.fk_printmap         := qwat_od.fn_get_printmap_id(NEW.geometry);
		NEW._printmaps          := qwat_od.fn_get_printmaps(NEW.geometry);
		NEW._length2d           := ST_Length(NEW.geometry);
		NEW._length3d           := ST_3DLength(NEW.geometry);
		NEW._diff_elevation     := @(ST_Z(ST_StartPoint(NEW.geometry))-ST_Z(ST_EndPoint(NEW.geometry)));
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_pipe_geom() OWNER TO postgres;

--
-- Name: ft_pipe_node_moved(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_pipe_node_moved() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        node_ids integer[];
        new_node_a integer;
        new_node_b integer;
        start_geom geometry;
        end_geom geometry;
    BEGIN
        -- We get start and end points of the pipe
        SELECT ST_StartPoint(geometry) into start_geom FROM qwat_od.pipe WHERE fk_node_a = OLD.id;
        SELECT ST_EndPoint(geometry) into end_geom FROM qwat_od.pipe WHERE fk_node_b = OLD.id;
        IF start_geom IS NOT NULL THEN
            -- In that case, we can create a new node, and affect it to the pipe
            new_node_a := qwat_od.fn_node_create(start_geom);
            UPDATE qwat_od.pipe SET fk_node_a = new_node_a WHERE fk_node_a = OLD.id;
        END IF;
        IF end_geom IS NOT NULL THEN
            -- In that case, we can create a new node, and affect it to the pipe
            new_node_b := qwat_od.fn_node_create(end_geom);
            UPDATE qwat_od.pipe SET fk_node_b = new_node_b WHERE fk_node_b = OLD.id;
        END IF;
        RETURN NEW;
    END;
    $$;


ALTER FUNCTION qwat_od.ft_pipe_node_moved() OWNER TO postgres;

--
-- Name: FUNCTION ft_pipe_node_moved(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_pipe_node_moved() IS 'Trigger: if a network element (i.e. a node) has moved, then reaasign the nodes for the pipe.';


--
-- Name: ft_pipe_node_type(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_pipe_node_type() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	DECLARE
		node_ids integer[];
	BEGIN
		IF TG_OP = 'INSERT' THEN
			node_ids := ARRAY[NEW.fk_node_a, NEW.fk_node_b];
		ELSE
			-- delete or update (OLD exists)
			node_ids := ARRAY[OLD.fk_node_a, OLD.fk_node_b];
		END IF;
		IF TG_OP = 'UPDATE' THEN
			IF NEW.fk_node_a <> OLD.fk_node_a THEN
				node_ids := array_append(node_ids, OLD.fk_node_a);
			END IF;
			IF NEW.fk_node_b <> OLD.fk_node_b THEN
				node_ids := array_append(node_ids, OLD.fk_node_b);
			END IF;
		END IF;
		PERFORM qwat_od.fn_node_set_type( node_ids );
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_pipe_node_type() OWNER TO postgres;

--
-- Name: ft_pipe_tunnelbridge(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_pipe_tunnelbridge() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
 BEGIN
  NEW._length3d := NULL;
  NEW._diff_elevation := NULL;
  RETURN NEW;
 END;
$$;


ALTER FUNCTION qwat_od.ft_pipe_tunnelbridge() OWNER TO postgres;

--
-- Name: ft_tank(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_tank() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW._cistern1_litrepercm := qwat_od.fn_litres_per_cm(NEW.cistern1_fk_type,NEW.cistern1_dimension_1,NEW.cistern1_dimension_2);
		NEW._cistern2_litrepercm := qwat_od.fn_litres_per_cm(NEW.cistern2_fk_type,NEW.cistern2_dimension_1,NEW.cistern2_dimension_2);
		NEW._litrepercm := COALESCE(NEW._cistern1_litrepercm,0)+COALESCE(NEW._cistern2_litrepercm,0);
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_tank() OWNER TO postgres;

--
-- Name: ft_valve_handle_altitude(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_valve_handle_altitude() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	DECLARE
	BEGIN
		-- altitude is prioritary on Z value of the geometry (if both changed, only altitude is taken into account)
		IF NEW.handle_altitude IS NULL THEN
			NEW.handle_altitude := NULLIF( ST_Z(NEW.handle_geometry), 0.0); -- 0 is the NULL value
		END IF;
		IF 	NEW.handle_altitude IS NULL     AND ST_Z(NEW.handle_geometry) <> 0.0 OR
			NEW.handle_altitude IS NOT NULL AND ( ST_Z(NEW.handle_geometry) IS NULL OR ST_Z(NEW.handle_geometry) <> NEW.handle_altitude ) THEN
				NEW.handle_geometry := ST_SetSRID( ST_MakePoint( ST_X(NEW.handle_geometry), ST_Y(NEW.handle_geometry), COALESCE(NEW.handle_altitude,0) ), ST_SRID(NEW.handle_geometry) );
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_valve_handle_altitude() OWNER TO postgres;

--
-- Name: FUNCTION ft_valve_handle_altitude(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_valve_handle_altitude() IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: ft_valve_node_set_type(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_valve_node_set_type() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		PERFORM qwat_od.fn_node_set_type(NEW.id);
	RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_valve_node_set_type() OWNER TO postgres;

--
-- Name: FUNCTION ft_valve_node_set_type(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_valve_node_set_type() IS 'Trigger: set-type of node after inserting a valve (to get orientation).';


--
-- Name: ft_valve_pipe_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_valve_pipe_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		UPDATE qwat_od.vw_element_valve valve SET fk_pipe = qwat_od.fn_pipe_get_id(geometry) WHERE fk_pipe = OLD.id OR ST_Distance(geometry, OLD.geometry) < 1e-4;
		RETURN NULL;
	END;
$$;


ALTER FUNCTION qwat_od.ft_valve_pipe_update() OWNER TO postgres;

--
-- Name: FUNCTION ft_valve_pipe_update(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_valve_pipe_update() IS 'Trigger: when moving or deleting a pipe, reassign the pipe to all valves connected to the old pipe. Do an AFTER trigger since it will update valve after updating the node.';


--
-- Name: ft_valve_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_valve_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		PERFORM qwat_od.fn_pipe_update_valve(OLD.id);
		PERFORM qwat_od.fn_pipe_update_valve(NEW.id);
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_od.ft_valve_update() OWNER TO postgres;

--
-- Name: FUNCTION ft_valve_update(); Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON FUNCTION ft_valve_update() IS 'Trigger: when updating a valve, reevaluate old and new pipes.';


--
-- Name: ft_vw_qwat_installation_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_installation_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	CASE
		WHEN OLD.installation_type::qwat_od.installation_type = 'source'::qwat_od.installation_type THEN
			DELETE FROM qwat_od.source WHERE id = OLD.id;
		WHEN OLD.installation_type::qwat_od.installation_type = 'pump'::qwat_od.installation_type THEN
			DELETE FROM qwat_od.pump WHERE id = OLD.id;
		WHEN OLD.installation_type::qwat_od.installation_type = 'tank'::qwat_od.installation_type THEN
			DELETE FROM qwat_od.tank WHERE id = OLD.id;
		WHEN OLD.installation_type::qwat_od.installation_type = 'treatment'::qwat_od.installation_type THEN
			DELETE FROM qwat_od.treatment WHERE id = OLD.id;
		WHEN OLD.installation_type::qwat_od.installation_type = 'chamber'::qwat_od.installation_type THEN
			DELETE FROM qwat_od.chamber WHERE id = OLD.id;
		WHEN OLD.installation_type::qwat_od.installation_type = 'pressurecontrol'::qwat_od.installation_type THEN
			DELETE FROM qwat_od.pressurecontrol WHERE id = OLD.id;
	END CASE;
	DELETE FROM qwat_od.installation WHERE id = OLD.id;
	RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_installation_delete() OWNER TO postgres;

--
-- Name: ft_vw_qwat_installation_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_installation_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.installation (
			id
			, name
			, fk_parent
			, fk_remote
			, fk_watertype
			, parcel
			, eca
			, open_water_surface
			, geometry_polygon
		) VALUES (
			NEW.id 
			, NEW.name
			, NEW.fk_parent
			, NEW.fk_remote
			, NEW.fk_watertype
			, NEW.parcel
			, NEW.eca
			, NEW.open_water_surface
			, NEW.geometry_polygon
		) RETURNING id INTO NEW.id;

	CASE
		WHEN NEW.installation_type::qwat_od.installation_type = 'source'::qwat_od.installation_type
			THEN INSERT INTO qwat_od.source (
				id 
				, fk_source_type
				, fk_source_quality
				, flow_lowest
				, flow_average
				, flow_concession
				, contract_end
				, gathering_chamber
			) VALUES (
				NEW.id
				, NEW.fk_source_type
				, NEW.fk_source_quality
				, NEW.flow_lowest
				, NEW.flow_average
				, NEW.flow_concession
				, NEW.contract_end
				, NEW.gathering_chamber
		);

		WHEN NEW.installation_type::qwat_od.installation_type = 'pump'::qwat_od.installation_type
			THEN INSERT INTO qwat_od.pump (
				id 
				, fk_pump_type
				, fk_pipe_in
				, fk_pipe_out
				, fk_pump_operating
				, no_pumps
				, rejected_flow
				, manometric_height
			) VALUES (
				NEW.id
				, NEW.fk_pump_type
				, NEW.fk_pipe_in
				, NEW.fk_pipe_out
				, NEW.fk_pump_operating
				, NEW.no_pumps
				, NEW.rejected_flow
				, NEW.manometric_height
		);

		WHEN NEW.installation_type::qwat_od.installation_type = 'tank'::qwat_od.installation_type
			THEN INSERT INTO qwat_od.tank (
				id 
				, fk_overflow
				, fk_tank_firestorage
				, storage_total
				, storage_supply
				, storage_fire
				, altitude_overflow
				, altitude_apron
				, height_max
				, fire_valve
				, fire_remote
				, _litrepercm
				, cistern1_fk_type
				, cistern1_dimension_1
				, cistern1_dimension_2
				, cistern1_storage
				, _cistern1_litrepercm
				, cistern2_fk_type
				, cistern2_dimension_1
				, cistern2_dimension_2
				, cistern2_storage
				, _cistern2_litrepercm
			) VALUES (
				NEW.id
				, NEW.fk_overflow
				, NEW.fk_tank_firestorage
				, NEW.storage_total
				, NEW.storage_supply
				, NEW.storage_fire
				, NEW.altitude_overflow
				, NEW.altitude_apron
				, NEW.height_max
				, NEW.fire_valve
				, NEW.fire_remote
				, NEW._litrepercm
				, NEW.cistern1_fk_type
				, NEW.cistern1_dimension_1
				, NEW.cistern1_dimension_2
				, NEW.cistern1_storage
				, NEW._cistern1_litrepercm
				, NEW.cistern2_fk_type
				, NEW.cistern2_dimension_1
				, NEW.cistern2_dimension_2
				, NEW.cistern2_storage
				, NEW._cistern2_litrepercm
		);

		WHEN NEW.installation_type::qwat_od.installation_type = 'treatment'::qwat_od.installation_type
			THEN INSERT INTO qwat_od.treatment (
				id 
				, sanitization_uv
				, sanitization_chlorine_liquid
				, sanitization_chlorine_gazeous
				, sanitization_ozone
				, filtration_membrane
				, filtration_sandorgravel
				, flocculation
				, activatedcharcoal
				, settling
				, treatment_capacity
			) VALUES (
				NEW.id
				, NEW.sanitization_uv
				, NEW.sanitization_chlorine_liquid
				, NEW.sanitization_chlorine_gazeous
				, NEW.sanitization_ozone
				, NEW.filtration_membrane
				, NEW.filtration_sandorgravel
				, NEW.flocculation
				, NEW.activatedcharcoal
				, NEW.settling
				, NEW.treatment_capacity
		);

		WHEN NEW.installation_type::qwat_od.installation_type = 'chamber'::qwat_od.installation_type
			THEN INSERT INTO qwat_od.chamber (
				id 
				, networkseparation
				, flow_meter
				, water_meter
				, manometer
				, depth
				, no_valves
			) VALUES (
				NEW.id
				, NEW.networkseparation
				, NEW.flow_meter
				, NEW.water_meter
				, NEW.manometer
				, NEW.depth
				, NEW.no_valves
		);

		WHEN NEW.installation_type::qwat_od.installation_type = 'pressurecontrol'::qwat_od.installation_type
			THEN INSERT INTO qwat_od.pressurecontrol (
				id 
				, fk_pressurecontrol_type
			) VALUES (
				NEW.id
				, NEW.fk_pressurecontrol_type
		);

	 END CASE;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_installation_insert() OWNER TO postgres;

--
-- Name: ft_vw_qwat_installation_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_installation_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.installation SET
			name = NEW.name,
			fk_parent = NEW.fk_parent,
			fk_remote = NEW.fk_remote,
			fk_watertype = NEW.fk_watertype,
			parcel = NEW.parcel,
			eca = NEW.eca,
			open_water_surface = NEW.open_water_surface,
			geometry_polygon = NEW.geometry_polygon
		WHERE id = OLD.id;
	-- detect if type has changed
	IF OLD.installation_type <> NEW.installation_type::qwat_od.installation_type THEN
		RAISE EXCEPTION 'Type change not allowed for installation'
			USING HINT = 'You cannot switch from ' || OLD.installation_type || ' to ' || NEW.installation_type; 
	END IF;
	CASE
	WHEN NEW.installation_type::qwat_od.installation_type = 'source'::qwat_od.installation_type
		THEN UPDATE qwat_od.source SET
			fk_source_type = NEW.fk_source_type
			, fk_source_quality = NEW.fk_source_quality
			, flow_lowest = NEW.flow_lowest
			, flow_average = NEW.flow_average
			, flow_concession = NEW.flow_concession
			, contract_end = NEW.contract_end
			, gathering_chamber = NEW.gathering_chamber
		WHERE id = OLD.id;
	WHEN NEW.installation_type::qwat_od.installation_type = 'pump'::qwat_od.installation_type
		THEN UPDATE qwat_od.pump SET
			fk_pump_type = NEW.fk_pump_type
			, fk_pipe_in = NEW.fk_pipe_in
			, fk_pipe_out = NEW.fk_pipe_out
			, fk_pump_operating = NEW.fk_pump_operating
			, no_pumps = NEW.no_pumps
			, rejected_flow = NEW.rejected_flow
			, manometric_height = NEW.manometric_height
		WHERE id = OLD.id;
	WHEN NEW.installation_type::qwat_od.installation_type = 'tank'::qwat_od.installation_type
		THEN UPDATE qwat_od.tank SET
			fk_overflow = NEW.fk_overflow
			, fk_tank_firestorage = NEW.fk_tank_firestorage
			, storage_total = NEW.storage_total
			, storage_supply = NEW.storage_supply
			, storage_fire = NEW.storage_fire
			, altitude_overflow = NEW.altitude_overflow
			, altitude_apron = NEW.altitude_apron
			, height_max = NEW.height_max
			, fire_valve = NEW.fire_valve
			, fire_remote = NEW.fire_remote
			, _litrepercm = NEW._litrepercm
			, cistern1_fk_type = NEW.cistern1_fk_type
			, cistern1_dimension_1 = NEW.cistern1_dimension_1
			, cistern1_dimension_2 = NEW.cistern1_dimension_2
			, cistern1_storage = NEW.cistern1_storage
			, _cistern1_litrepercm = NEW._cistern1_litrepercm
			, cistern2_fk_type = NEW.cistern2_fk_type
			, cistern2_dimension_1 = NEW.cistern2_dimension_1
			, cistern2_dimension_2 = NEW.cistern2_dimension_2
			, cistern2_storage = NEW.cistern2_storage
			, _cistern2_litrepercm = NEW._cistern2_litrepercm
		WHERE id = OLD.id;
	WHEN NEW.installation_type::qwat_od.installation_type = 'treatment'::qwat_od.installation_type
		THEN UPDATE qwat_od.treatment SET
			sanitization_uv = NEW.sanitization_uv
			, sanitization_chlorine_liquid = NEW.sanitization_chlorine_liquid
			, sanitization_chlorine_gazeous = NEW.sanitization_chlorine_gazeous
			, sanitization_ozone = NEW.sanitization_ozone
			, filtration_membrane = NEW.filtration_membrane
			, filtration_sandorgravel = NEW.filtration_sandorgravel
			, flocculation = NEW.flocculation
			, activatedcharcoal = NEW.activatedcharcoal
			, settling = NEW.settling
			, treatment_capacity = NEW.treatment_capacity
		WHERE id = OLD.id;
	WHEN NEW.installation_type::qwat_od.installation_type = 'chamber'::qwat_od.installation_type
		THEN UPDATE qwat_od.chamber SET
			networkseparation = NEW.networkseparation
			, flow_meter = NEW.flow_meter
			, water_meter = NEW.water_meter
			, manometer = NEW.manometer
			, depth = NEW.depth
			, no_valves = NEW.no_valves
		WHERE id = OLD.id;
	WHEN NEW.installation_type::qwat_od.installation_type = 'pressurecontrol'::qwat_od.installation_type
		THEN UPDATE qwat_od.pressurecontrol SET
			fk_pressurecontrol_type = NEW.fk_pressurecontrol_type
		WHERE id = OLD.id;
	END CASE;

	RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_installation_update() OWNER TO postgres;

--
-- Name: ft_vw_qwat_network_element_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_network_element_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	CASE
		WHEN OLD.element_type::qwat_od.element_type = 'subscriber'::qwat_od.element_type THEN
			DELETE FROM qwat_od.subscriber WHERE id = OLD.id;
		WHEN OLD.element_type::qwat_od.element_type = 'part'::qwat_od.element_type THEN
			DELETE FROM qwat_od.part WHERE id = OLD.id;
		WHEN OLD.element_type::qwat_od.element_type = 'installation'::qwat_od.element_type THEN
			DELETE FROM qwat_od.vw_qwat_installation WHERE id = OLD.id;
		WHEN OLD.element_type::qwat_od.element_type = 'hydrant'::qwat_od.element_type THEN
			DELETE FROM qwat_od.hydrant WHERE id = OLD.id;
		WHEN OLD.element_type::qwat_od.element_type = 'samplingpoint'::qwat_od.element_type THEN
			DELETE FROM qwat_od.samplingpoint WHERE id = OLD.id;
		WHEN OLD.element_type::qwat_od.element_type = 'valve'::qwat_od.element_type THEN
			DELETE FROM qwat_od.valve WHERE id = OLD.id;
		WHEN OLD.element_type::qwat_od.element_type = 'meter'::qwat_od.element_type THEN
			DELETE FROM qwat_od.meter WHERE id = OLD.id;
	END CASE;
	DELETE FROM qwat_od.vw_node_element WHERE id = OLD.id;
	RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_network_element_delete() OWNER TO postgres;

--
-- Name: ft_vw_qwat_network_element_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_network_element_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		INSERT INTO qwat_od.vw_node_element (
			id
			, fk_district
			, fk_pressurezone
			, fk_printmap
			, _printmaps
			, _geometry_alt1_used
			, _geometry_alt2_used
			, _pipe_node_type
			, _pipe_orientation
			, _pipe_schema_visible
			, geometry
			, geometry_alt1
			, geometry_alt2
			, update_geometry_alt1
			, update_geometry_alt2
			, identification
			, fk_distributor
			, fk_status
			, fk_folder
			, fk_locationtype
			, fk_precision
			, fk_precisionalti
			, fk_object_reference
			, altitude
			, year
			, year_end
			, orientation
			, remark
			, schema_force_visible
			, label_1_visible
			, label_1_x
			, label_1_y
			, label_1_rotation
			, label_1_text
			, label_2_visible
			, label_2_x
			, label_2_y
			, label_2_rotation
			, label_2_text
		) VALUES (
			NEW.id 
			, NEW.fk_district
			, NEW.fk_pressurezone
			, NEW.fk_printmap
			, NEW._printmaps
			, NEW._geometry_alt1_used
			, NEW._geometry_alt2_used
			, NEW._pipe_node_type
			, NEW._pipe_orientation
			, NEW._pipe_schema_visible
			, NEW.geometry
			, NEW.geometry_alt1
			, NEW.geometry_alt2
			, NEW.update_geometry_alt1
			, NEW.update_geometry_alt2
			, NEW.identification
			, NEW.fk_distributor
			, NEW.fk_status
			, NEW.fk_folder
			, NEW.fk_locationtype
			, NEW.fk_precision
			, NEW.fk_precisionalti
			, NEW.fk_object_reference
			, NEW.altitude
			, NEW.year
			, NEW.year_end
			, NEW.orientation
			, NEW.remark
			, NEW.schema_force_visible
			, NEW.label_1_visible
			, NEW.label_1_x
			, NEW.label_1_y
			, NEW.label_1_rotation
			, NEW.label_1_text
			, NEW.label_2_visible
			, NEW.label_2_x
			, NEW.label_2_y
			, NEW.label_2_rotation
			, NEW.label_2_text
		) RETURNING id INTO NEW.id;

	CASE
		WHEN NEW.element_type::qwat_od.element_type = 'subscriber'::qwat_od.element_type
			THEN INSERT INTO qwat_od.subscriber (
				id 
				, fk_subscriber_type
				, fk_pipe
				, parcel
				, flow_current
				, flow_planned
			) VALUES (
				NEW.id
				, NEW.fk_subscriber_type
				, NEW.fk_pipe
				, NEW.parcel
				, NEW.flow_current
				, NEW.flow_planned
		);

		WHEN NEW.element_type::qwat_od.element_type = 'part'::qwat_od.element_type
			THEN INSERT INTO qwat_od.part (
				id 
				, fk_part_type
				, fk_pipe
			) VALUES (
				NEW.id
				, NEW.fk_part_type
				, qwat_od.fn_pipe_get_id(NEW.geometry)
		);

		WHEN NEW.element_type::qwat_od.element_type = 'installation'::qwat_od.element_type
			THEN INSERT INTO qwat_od.vw_qwat_installation (
				id 
				, installation_type
				, name
				, fk_parent
				, fk_remote
				, fk_watertype
				, parcel
				, eca
				, open_water_surface
				, geometry_polygon
				, fk_source_type
				, fk_source_quality
				, flow_lowest
				, flow_average
				, flow_concession
				, contract_end
				, gathering_chamber
				, fk_pump_type
				, fk_pipe_in
				, fk_pipe_out
				, fk_pump_operating
				, no_pumps
				, rejected_flow
				, manometric_height
				, fk_overflow
				, fk_tank_firestorage
				, storage_total
				, storage_supply
				, storage_fire
				, altitude_overflow
				, altitude_apron
				, height_max
				, fire_valve
				, fire_remote
				, _litrepercm
				, cistern1_fk_type
				, cistern1_dimension_1
				, cistern1_dimension_2
				, cistern1_storage
				, _cistern1_litrepercm
				, cistern2_fk_type
				, cistern2_dimension_1
				, cistern2_dimension_2
				, cistern2_storage
				, _cistern2_litrepercm
				, sanitization_uv
				, sanitization_chlorine_liquid
				, sanitization_chlorine_gazeous
				, sanitization_ozone
				, filtration_membrane
				, filtration_sandorgravel
				, flocculation
				, activatedcharcoal
				, settling
				, treatment_capacity
				, networkseparation
				, flow_meter
				, water_meter
				, manometer
				, depth
				, no_valves
				, fk_pressurecontrol_type
			) VALUES (
				NEW.id
				, NEW.installation_type
				, NEW.name
				, NEW.fk_parent
				, NEW.fk_remote
				, NEW.fk_watertype
				, NEW.parcel
				, NEW.eca
				, NEW.open_water_surface
				, NEW.geometry_polygon
				, NEW.fk_source_type
				, NEW.fk_source_quality
				, NEW.flow_lowest
				, NEW.flow_average
				, NEW.flow_concession
				, NEW.contract_end
				, NEW.gathering_chamber
				, NEW.fk_pump_type
				, NEW.fk_pipe_in
				, NEW.fk_pipe_out
				, NEW.fk_pump_operating
				, NEW.no_pumps
				, NEW.rejected_flow
				, NEW.manometric_height
				, NEW.fk_overflow
				, NEW.fk_tank_firestorage
				, NEW.storage_total
				, NEW.storage_supply
				, NEW.storage_fire
				, NEW.altitude_overflow
				, NEW.altitude_apron
				, NEW.height_max
				, NEW.fire_valve
				, NEW.fire_remote
				, NEW._litrepercm
				, NEW.cistern1_fk_type
				, NEW.cistern1_dimension_1
				, NEW.cistern1_dimension_2
				, NEW.cistern1_storage
				, NEW._cistern1_litrepercm
				, NEW.cistern2_fk_type
				, NEW.cistern2_dimension_1
				, NEW.cistern2_dimension_2
				, NEW.cistern2_storage
				, NEW._cistern2_litrepercm
				, NEW.sanitization_uv
				, NEW.sanitization_chlorine_liquid
				, NEW.sanitization_chlorine_gazeous
				, NEW.sanitization_ozone
				, NEW.filtration_membrane
				, NEW.filtration_sandorgravel
				, NEW.flocculation
				, NEW.activatedcharcoal
				, NEW.settling
				, NEW.treatment_capacity
				, NEW.networkseparation
				, NEW.flow_meter
				, NEW.water_meter
				, NEW.manometer
				, NEW.depth
				, NEW.no_valves
				, NEW.fk_pressurecontrol_type
		);

		WHEN NEW.element_type::qwat_od.element_type = 'hydrant'::qwat_od.element_type
			THEN INSERT INTO qwat_od.hydrant (
				id 
				, fk_provider
				, fk_model_sup
				, fk_model_inf
				, fk_material
				, fk_output
				, underground
				, marked
				, pressure_static
				, pressure_dynamic
				, flow
				, observation_date
				, observation_source
			) VALUES (
				NEW.id
				, NEW.fk_provider
				, NEW.fk_model_sup
				, NEW.fk_model_inf
				, NEW.fk_material
				, NEW.fk_output
				, NEW.underground
				, NEW.marked
				, NEW.pressure_static
				, NEW.pressure_dynamic
				, NEW.flow
				, NEW.observation_date
				, NEW.observation_source
		);

		WHEN NEW.element_type::qwat_od.element_type = 'samplingpoint'::qwat_od.element_type
			THEN INSERT INTO qwat_od.samplingpoint (
				id 
			) VALUES (
				NEW.id
		);

		WHEN NEW.element_type::qwat_od.element_type = 'valve'::qwat_od.element_type
			THEN INSERT INTO qwat_od.valve (
				id 
				, fk_valve_type
				, fk_valve_function
				, fk_valve_actuation
				, fk_pipe
				, fk_handle_precision
				, fk_handle_precisionalti
				, fk_maintenance
				, diameter_nominal
				, closed
				, networkseparation
				, handle_altitude
				, handle_geometry
			) VALUES (
				NEW.id
				, NEW.fk_valve_type
				, NEW.fk_valve_function
				, NEW.fk_valve_actuation
				, qwat_od.fn_pipe_get_id(NEW.geometry)
				, NEW.fk_handle_precision
				, NEW.fk_handle_precisionalti
				, NEW.fk_maintenance
				, NEW.diameter_nominal
				, NEW.closed
				, NEW.networkseparation
				, NEW.handle_altitude
				, NEW.handle_geometry
		);

		WHEN NEW.element_type::qwat_od.element_type = 'meter'::qwat_od.element_type
			THEN INSERT INTO qwat_od.meter (
				id 
				, fk_pipe
				, parcel
			) VALUES (
				NEW.id
				, NEW.fk_pipe
				, NEW.parcel
		);

	 END CASE;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_network_element_insert() OWNER TO postgres;

--
-- Name: ft_vw_qwat_network_element_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_network_element_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	UPDATE qwat_od.vw_node_element SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2,
			identification = NEW.identification,
			fk_distributor = NEW.fk_distributor,
			fk_status = NEW.fk_status,
			fk_folder = NEW.fk_folder,
			fk_locationtype = NEW.fk_locationtype,
			fk_precision = NEW.fk_precision,
			fk_precisionalti = NEW.fk_precisionalti,
			fk_object_reference = NEW.fk_object_reference,
			altitude = NEW.altitude,
			year = NEW.year,
			year_end = NEW.year_end,
			orientation = NEW.orientation,
			remark = NEW.remark,
			schema_force_visible = NEW.schema_force_visible,
			label_1_visible = NEW.label_1_visible,
			label_1_x = NEW.label_1_x,
			label_1_y = NEW.label_1_y,
			label_1_rotation = NEW.label_1_rotation,
			label_1_text = NEW.label_1_text,
			label_2_visible = NEW.label_2_visible,
			label_2_x = NEW.label_2_x,
			label_2_y = NEW.label_2_y,
			label_2_rotation = NEW.label_2_rotation,
			label_2_text = NEW.label_2_text
		WHERE id = OLD.id;
	-- detect if type has changed
	IF OLD.element_type <> NEW.element_type::qwat_od.element_type THEN
		RAISE EXCEPTION 'Type change not allowed for element'
			USING HINT = 'You cannot switch from ' || OLD.element_type || ' to ' || NEW.element_type; 
	END IF;
	CASE
	WHEN NEW.element_type::qwat_od.element_type = 'subscriber'::qwat_od.element_type
		THEN UPDATE qwat_od.subscriber SET
			fk_subscriber_type = NEW.fk_subscriber_type
			, fk_pipe = NEW.fk_pipe
			, parcel = NEW.parcel
			, flow_current = NEW.flow_current
			, flow_planned = NEW.flow_planned
		WHERE id = OLD.id;
	WHEN NEW.element_type::qwat_od.element_type = 'part'::qwat_od.element_type
		THEN UPDATE qwat_od.part SET
			fk_part_type = NEW.fk_part_type
			, fk_pipe = qwat_od.fn_pipe_get_id(NEW.geometry)
		WHERE id = OLD.id;
	WHEN NEW.element_type::qwat_od.element_type = 'installation'::qwat_od.element_type
		THEN UPDATE qwat_od.vw_qwat_installation SET
			installation_type = NEW.installation_type
			, name = NEW.name
			, fk_parent = NEW.fk_parent
			, fk_remote = NEW.fk_remote
			, fk_watertype = NEW.fk_watertype
			, parcel = NEW.parcel
			, eca = NEW.eca
			, open_water_surface = NEW.open_water_surface
			, geometry_polygon = NEW.geometry_polygon
			, fk_source_type = NEW.fk_source_type
			, fk_source_quality = NEW.fk_source_quality
			, flow_lowest = NEW.flow_lowest
			, flow_average = NEW.flow_average
			, flow_concession = NEW.flow_concession
			, contract_end = NEW.contract_end
			, gathering_chamber = NEW.gathering_chamber
			, fk_pump_type = NEW.fk_pump_type
			, fk_pipe_in = NEW.fk_pipe_in
			, fk_pipe_out = NEW.fk_pipe_out
			, fk_pump_operating = NEW.fk_pump_operating
			, no_pumps = NEW.no_pumps
			, rejected_flow = NEW.rejected_flow
			, manometric_height = NEW.manometric_height
			, fk_overflow = NEW.fk_overflow
			, fk_tank_firestorage = NEW.fk_tank_firestorage
			, storage_total = NEW.storage_total
			, storage_supply = NEW.storage_supply
			, storage_fire = NEW.storage_fire
			, altitude_overflow = NEW.altitude_overflow
			, altitude_apron = NEW.altitude_apron
			, height_max = NEW.height_max
			, fire_valve = NEW.fire_valve
			, fire_remote = NEW.fire_remote
			, _litrepercm = NEW._litrepercm
			, cistern1_fk_type = NEW.cistern1_fk_type
			, cistern1_dimension_1 = NEW.cistern1_dimension_1
			, cistern1_dimension_2 = NEW.cistern1_dimension_2
			, cistern1_storage = NEW.cistern1_storage
			, _cistern1_litrepercm = NEW._cistern1_litrepercm
			, cistern2_fk_type = NEW.cistern2_fk_type
			, cistern2_dimension_1 = NEW.cistern2_dimension_1
			, cistern2_dimension_2 = NEW.cistern2_dimension_2
			, cistern2_storage = NEW.cistern2_storage
			, _cistern2_litrepercm = NEW._cistern2_litrepercm
			, sanitization_uv = NEW.sanitization_uv
			, sanitization_chlorine_liquid = NEW.sanitization_chlorine_liquid
			, sanitization_chlorine_gazeous = NEW.sanitization_chlorine_gazeous
			, sanitization_ozone = NEW.sanitization_ozone
			, filtration_membrane = NEW.filtration_membrane
			, filtration_sandorgravel = NEW.filtration_sandorgravel
			, flocculation = NEW.flocculation
			, activatedcharcoal = NEW.activatedcharcoal
			, settling = NEW.settling
			, treatment_capacity = NEW.treatment_capacity
			, networkseparation = NEW.networkseparation
			, flow_meter = NEW.flow_meter
			, water_meter = NEW.water_meter
			, manometer = NEW.manometer
			, depth = NEW.depth
			, no_valves = NEW.no_valves
			, fk_pressurecontrol_type = NEW.fk_pressurecontrol_type
		WHERE id = OLD.id;
	WHEN NEW.element_type::qwat_od.element_type = 'hydrant'::qwat_od.element_type
		THEN UPDATE qwat_od.hydrant SET
			fk_provider = NEW.fk_provider
			, fk_model_sup = NEW.fk_model_sup
			, fk_model_inf = NEW.fk_model_inf
			, fk_material = NEW.fk_material
			, fk_output = NEW.fk_output
			, underground = NEW.underground
			, marked = NEW.marked
			, pressure_static = NEW.pressure_static
			, pressure_dynamic = NEW.pressure_dynamic
			, flow = NEW.flow
			, observation_date = NEW.observation_date
			, observation_source = NEW.observation_source
		WHERE id = OLD.id;
	WHEN NEW.element_type::qwat_od.element_type = 'samplingpoint'::qwat_od.element_type
		THEN 
		NULL;
	WHEN NEW.element_type::qwat_od.element_type = 'valve'::qwat_od.element_type
		THEN UPDATE qwat_od.valve SET
			fk_valve_type = NEW.fk_valve_type
			, fk_valve_function = NEW.fk_valve_function
			, fk_valve_actuation = NEW.fk_valve_actuation
			, fk_pipe = qwat_od.fn_pipe_get_id(NEW.geometry)
			, fk_handle_precision = NEW.fk_handle_precision
			, fk_handle_precisionalti = NEW.fk_handle_precisionalti
			, fk_maintenance = NEW.fk_maintenance
			, diameter_nominal = NEW.diameter_nominal
			, closed = NEW.closed
			, networkseparation = NEW.networkseparation
			, handle_altitude = NEW.handle_altitude
			, handle_geometry = NEW.handle_geometry
		WHERE id = OLD.id;
	WHEN NEW.element_type::qwat_od.element_type = 'meter'::qwat_od.element_type
		THEN UPDATE qwat_od.meter SET
			fk_pipe = NEW.fk_pipe
			, parcel = NEW.parcel
		WHERE id = OLD.id;
	END CASE;

	RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_network_element_update() OWNER TO postgres;

--
-- Name: ft_vw_qwat_node_delete(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_node_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
	CASE
		WHEN OLD.node_type::qwat_od.node_type = 'element'::qwat_od.node_type THEN
			DELETE FROM qwat_od.network_element WHERE id = OLD.id;
	END CASE;
	PERFORM qwat_od.fn_node_set_type(OLD.id);
	RETURN NULL;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_node_delete() OWNER TO postgres;

--
-- Name: ft_vw_qwat_node_insert(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_node_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		-- altitude is prioritary on Z value of the geometry (if both changed, only altitude is taken into account)
		IF NEW.altitude IS NULL THEN
			NEW.altitude := NULLIF( ST_Z(NEW.geometry), 0.0); -- 0 is the NULL value
		END IF;
		-- TODO handle going to NULL on update
		IF	NEW.altitude IS NULL     AND ST_Z(NEW.geometry) <> 0.0 OR
				NEW.altitude IS NOT NULL AND ( ST_Z(NEW.geometry) IS NULL OR ST_Z(NEW.geometry) <> NEW.altitude ) THEN
				NEW.geometry := ST_SetSRID( ST_MakePoint( ST_X(NEW.geometry), ST_Y(NEW.geometry), COALESCE(NEW.altitude,0) ), ST_SRID(NEW.geometry) );
		END IF;

		-- The function creates or gets a parent row.
		NEW.id := qwat_od.fn_node_create(NEW.geometry);
		-- If it previously existed with another subtype, it should raise an exception
		IF (SELECT _oid IS NOT NULL FROM 
			(
				SELECT id AS _oid FROM qwat_od.network_element
			) AS foo WHERE _oid = NEW.id
		) THEN
			RAISE EXCEPTION 'Cannot insert node as element since it already has another subtype. ID: %', NEW.id;
		END IF;
		-- Now update the existing or created feature in parent table
		UPDATE qwat_od.node SET
				fk_district = NEW.fk_district,
				fk_pressurezone = NEW.fk_pressurezone,
				fk_printmap = NEW.fk_printmap,
				_printmaps = NEW._printmaps,
				_geometry_alt1_used = NEW._geometry_alt1_used,
				_geometry_alt2_used = NEW._geometry_alt2_used,
				_pipe_node_type = NEW._pipe_node_type,
				_pipe_orientation = NEW._pipe_orientation,
				_pipe_schema_visible = NEW._pipe_schema_visible,
				geometry = NEW.geometry,
				geometry_alt1 = NEW.geometry_alt1,
				geometry_alt2 = NEW.geometry_alt2,
				update_geometry_alt1 = NEW.update_geometry_alt1,
				update_geometry_alt2 = NEW.update_geometry_alt2
			WHERE id = NEW.id;

	CASE
		WHEN NEW.node_type::qwat_od.node_type = 'element'::qwat_od.node_type
			THEN INSERT INTO qwat_od.network_element (
				id 
				, identification
				, fk_distributor
				, fk_status
				, fk_folder
				, fk_locationtype
				, fk_precision
				, fk_precisionalti
				, fk_object_reference
				, altitude
				, year
				, year_end
				, orientation
				, remark
				, schema_force_visible
				, label_1_visible
				, label_1_x
				, label_1_y
				, label_1_rotation
				, label_1_text
				, label_2_visible
				, label_2_x
				, label_2_y
				, label_2_rotation
				, label_2_text
			) VALUES (
				NEW.id
				, NEW.identification
				, NEW.fk_distributor
				, NEW.fk_status
				, NEW.fk_folder
				, NEW.fk_locationtype
				, NEW.fk_precision
				, NEW.fk_precisionalti
				, NEW.fk_object_reference
				, NEW.altitude
				, NEW.year
				, NEW.year_end
				, NEW.orientation
				, NEW.remark
				, NEW.schema_force_visible
				, NEW.label_1_visible
				, NEW.label_1_x
				, NEW.label_1_y
				, NEW.label_1_rotation
				, NEW.label_1_text
				, NEW.label_2_visible
				, NEW.label_2_x
				, NEW.label_2_y
				, NEW.label_2_rotation
				, NEW.label_2_text
		);

	 END CASE;
		RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_node_insert() OWNER TO postgres;

--
-- Name: ft_vw_qwat_node_update(); Type: FUNCTION; Schema: qwat_od; Owner: postgres
--

CREATE FUNCTION ft_vw_qwat_node_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN		-- altitude is prioritary on Z value of the geometry (if both changed, only altitude is taken into account)
		IF NEW.altitude IS NULL THEN
			NEW.altitude := NULLIF( ST_Z(NEW.geometry), 0.0); -- 0 is the NULL value
		END IF;
		-- TODO handle going to NULL on update
		IF	NEW.altitude IS NULL     AND ST_Z(NEW.geometry) <> 0.0 OR
				NEW.altitude IS NOT NULL AND ( ST_Z(NEW.geometry) IS NULL OR ST_Z(NEW.geometry) <> NEW.altitude ) THEN
				NEW.geometry := ST_SetSRID( ST_MakePoint( ST_X(NEW.geometry), ST_Y(NEW.geometry), COALESCE(NEW.altitude,0) ), ST_SRID(NEW.geometry) );
		END IF;


	UPDATE qwat_od.node SET
			fk_district = NEW.fk_district,
			fk_pressurezone = NEW.fk_pressurezone,
			fk_printmap = NEW.fk_printmap,
			_printmaps = NEW._printmaps,
			_geometry_alt1_used = NEW._geometry_alt1_used,
			_geometry_alt2_used = NEW._geometry_alt2_used,
			_pipe_node_type = NEW._pipe_node_type,
			_pipe_orientation = NEW._pipe_orientation,
			_pipe_schema_visible = NEW._pipe_schema_visible,
			geometry = NEW.geometry,
			geometry_alt1 = NEW.geometry_alt1,
			geometry_alt2 = NEW.geometry_alt2,
			update_geometry_alt1 = NEW.update_geometry_alt1,
			update_geometry_alt2 = NEW.update_geometry_alt2
		WHERE id = OLD.id;
	-- detect if type has changed
	IF OLD.node_type <> NEW.node_type::qwat_od.node_type THEN
		RAISE EXCEPTION 'Type change not allowed for node'
			USING HINT = 'You cannot switch from ' || OLD.node_type || ' to ' || NEW.node_type; 
	END IF;
	CASE
	WHEN NEW.node_type::qwat_od.node_type = 'element'::qwat_od.node_type
		THEN UPDATE qwat_od.network_element SET
			identification = NEW.identification
			, fk_distributor = NEW.fk_distributor
			, fk_status = NEW.fk_status
			, fk_folder = NEW.fk_folder
			, fk_locationtype = NEW.fk_locationtype
			, fk_precision = NEW.fk_precision
			, fk_precisionalti = NEW.fk_precisionalti
			, fk_object_reference = NEW.fk_object_reference
			, altitude = NEW.altitude
			, year = NEW.year
			, year_end = NEW.year_end
			, orientation = NEW.orientation
			, remark = NEW.remark
			, schema_force_visible = NEW.schema_force_visible
			, label_1_visible = NEW.label_1_visible
			, label_1_x = NEW.label_1_x
			, label_1_y = NEW.label_1_y
			, label_1_rotation = NEW.label_1_rotation
			, label_1_text = NEW.label_1_text
			, label_2_visible = NEW.label_2_visible
			, label_2_x = NEW.label_2_x
			, label_2_y = NEW.label_2_y
			, label_2_rotation = NEW.label_2_rotation
			, label_2_text = NEW.label_2_text
		WHERE id = OLD.id;
	END CASE;

	RETURN NEW;
	END;
	$$;


ALTER FUNCTION qwat_od.ft_vw_qwat_node_update() OWNER TO postgres;

SET search_path = qwat_sys, pg_catalog;

--
-- Name: audit_table(regclass); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION audit_table(target_table regclass) RETURNS void
    LANGUAGE sql
    AS $_$
SELECT qwat_sys.audit_table($1, BOOLEAN 't', BOOLEAN 't');
$_$;


ALTER FUNCTION qwat_sys.audit_table(target_table regclass) OWNER TO postgres;

--
-- Name: audit_table(regclass, boolean, boolean); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean) RETURNS void
    LANGUAGE sql
    AS $_$
SELECT qwat_sys.audit_table($1, $2, $3, ARRAY[]::text[]);
$_$;


ALTER FUNCTION qwat_sys.audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean) OWNER TO postgres;

--
-- Name: audit_table(regclass, boolean, boolean, text[]); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean, ignored_cols text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  stm_targets text = 'INSERT OR UPDATE OR DELETE OR TRUNCATE';
  _q_txt text;
  _ignored_cols_snip text = '';
BEGIN
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_row ON ' || target_table::text;
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_stm ON ' || target_table::text;
 
    IF audit_rows THEN
        IF array_length(ignored_cols,1) > 0 THEN
            _ignored_cols_snip = ', ' || quote_literal(ignored_cols);
        END IF;
        _q_txt = 'CREATE TRIGGER audit_trigger_row AFTER INSERT OR UPDATE OR DELETE ON ' || 
                 target_table::text || 
                 ' FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func(' ||
                 quote_literal(audit_query_text) || _ignored_cols_snip || ');';
        RAISE NOTICE '%',_q_txt;
        EXECUTE _q_txt;
        stm_targets = 'TRUNCATE';
    ELSE
    END IF;
 
    _q_txt = 'CREATE TRIGGER audit_trigger_stm AFTER ' || stm_targets || ' ON ' ||
             target_table::text ||
             ' FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('||
             quote_literal(audit_query_text) || ');';
    RAISE NOTICE '%',_q_txt;
    EXECUTE _q_txt;
 
END;
$$;


ALTER FUNCTION qwat_sys.audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean, ignored_cols text[]) OWNER TO postgres;

--
-- Name: FUNCTION audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean, ignored_cols text[]); Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON FUNCTION audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean, ignored_cols text[]) IS '
ADD auditing support TO a TABLE.
 
Arguments:
   target_table:     TABLE name, schema qualified IF NOT ON search_path
   audit_rows:       Record each row CHANGE, OR only audit at a statement level
   audit_query_text: Record the text of the client query that triggered the audit event?
   ignored_cols:     COLUMNS TO exclude FROM UPDATE diffs, IGNORE updates that CHANGE only ignored cols.
';


--
-- Name: fn_enable_schemaview(text); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION fn_enable_schemaview(_table_name text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		/* Add columns */
		EXECUTE format('ALTER TABLE qwat_od.%I ADD COLUMN schema_force_visible boolean default NULL;',
						_table_name);
		/* Constraint */
		EXECUTE format('ALTER TABLE qwat_od.%1$I ADD CONSTRAINT %2$I FOREIGN KEY (schema_force_visible) REFERENCES qwat_vl.visible(vl_code) MATCH FULL;
						CREATE INDEX %3$I ON qwat_od.%1$I(schema_force_visible);',
							_table_name, 
							_table_name||'_schema_force_visible',
							'fki_'||_table_name||'_schema_force_visible'
						);
	END;
$_$;


ALTER FUNCTION qwat_sys.fn_enable_schemaview(_table_name text) OWNER TO postgres;

--
-- Name: FUNCTION fn_enable_schemaview(_table_name text); Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON FUNCTION fn_enable_schemaview(_table_name text) IS 'Add a column schema_force_visible used to overwrite the schema_view defined by the auxiliary table (pipe_function for instance).';


--
-- Name: fn_label_create_fields(text, boolean, boolean); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION fn_label_create_fields(_tbl text, _position boolean DEFAULT true, _rotation boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN
    /* Creates columns */
   EXECUTE format('ALTER TABLE qwat_od.%I ADD COLUMN label_1_visible smallint default 1', _tbl);

   IF _position THEN
       EXECUTE format('ALTER TABLE qwat_od.%I
           ADD COLUMN label_1_x double precision default null
         , ADD COLUMN label_1_y double precision default null', _tbl);
   END IF;
   IF _rotation THEN
       EXECUTE format('ALTER TABLE qwat_od.%I ADD COLUMN label_1_rotation double precision default null' , _tbl);
   END IF;

   EXECUTE format('ALTER TABLE qwat_od.%I
           ADD COLUMN label_1_text varchar(120)    
         , ADD COLUMN label_2_visible  smallint default 1', _tbl);

   IF _position THEN
       EXECUTE format('ALTER TABLE qwat_od.%I
           ADD COLUMN label_2_x double precision default null
         , ADD COLUMN label_2_y double precision default null', _tbl);
   END IF;
   IF _rotation THEN
       EXECUTE format('ALTER TABLE qwat_od.%I ADD COLUMN label_2_rotation double precision default null', _tbl);
   END IF;

   EXECUTE format('ALTER TABLE qwat_od.%I ADD COLUMN label_2_text varchar(120)', _tbl);

   /* Creates constraints */
   EXECUTE format('ALTER TABLE qwat_od.%1$I
           ADD CONSTRAINT %2$I FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int)
         , ADD CONSTRAINT %3$I FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);
     CREATE INDEX %4$I ON qwat_od.%1$I(label_1_visible);
     CREATE INDEX %5$I ON qwat_od.%1$I(label_2_visible)'
   , _tbl
   , _tbl || '_label_1_visible'
   , _tbl || '_label_2_visible'
   , 'fki_' || _tbl || '_label_1_visible'
   , 'fki_' || _tbl || '_label_2_visible');
END
$_$;


ALTER FUNCTION qwat_sys.fn_label_create_fields(_tbl text, _position boolean, _rotation boolean) OWNER TO postgres;

--
-- Name: FUNCTION fn_label_create_fields(_tbl text, _position boolean, _rotation boolean); Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON FUNCTION fn_label_create_fields(_tbl text, _position boolean, _rotation boolean) IS 'Creates the fields and constraints for customization of labels.';


--
-- Name: fn_setting_srid(); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION fn_setting_srid() RETURNS integer
    LANGUAGE sql
    AS $$SELECT value::integer from qwat_sys.settings where name = 'srid'$$;


ALTER FUNCTION qwat_sys.fn_setting_srid() OWNER TO postgres;

--
-- Name: ft_setting_create_fn_get(); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION ft_setting_create_fn_get() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		IF TG_OP <> 'INSERT' THEN
			EXECUTE format($$DROP FUNCTION IF EXISTS qwat_sys.fn_setting_%1$I();$$, OLD.name);
		END IF;
		IF TG_OP <> 'DELETE' THEN
			EXECUTE format($$
				CREATE FUNCTION qwat_sys.fn_setting_%1$I() RETURNS %2$s AS
					'SELECT value::%2$s from qwat_sys.settings where name = ''%1$I''' language sql
			$$, NEW.name, NEW.type::regtype );
		END	IF;
		RETURN NEW;
	END;
	$_$;


ALTER FUNCTION qwat_sys.ft_setting_create_fn_get() OWNER TO postgres;

--
-- Name: if_modified_func(); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION if_modified_func() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO pg_catalog, public
    AS $$
DECLARE
    audit_row qwat_sys.logged_actions;
    include_values BOOLEAN;
    log_diffs BOOLEAN;
    h_old hstore;
    h_new hstore;
    excluded_cols text[] = ARRAY[]::text[];
BEGIN
    IF TG_WHEN <> 'AFTER' THEN
        RAISE EXCEPTION 'qwat_sys.if_modified_func() may only run as an AFTER trigger';
    END IF;
 
    audit_row = ROW(
        NEXTVAL('qwat_sys.logged_actions_event_id_seq'), -- event_id
        TG_TABLE_SCHEMA::text,                        -- schema_name
        TG_TABLE_NAME::text,                          -- table_name
        TG_RELID,                                     -- relation OID for much quicker searches
        session_user::text,                           -- session_user_name
        current_timestamp,                            -- action_tstamp_tx
        statement_timestamp(),                        -- action_tstamp_stm
        clock_timestamp(),                            -- action_tstamp_clk
        txid_current(),                               -- transaction ID
        (SELECT setting FROM pg_settings WHERE name = 'application_name'),
        inet_client_addr(),                           -- client_addr
        inet_client_port(),                           -- client_port
        current_query(),                              -- top-level query or queries (if multistatement) from client
        substring(TG_OP,1,1),                         -- action
        NULL, NULL,                                   -- row_data, changed_fields
        'f'                                           -- statement_only
        );
 
    IF NOT TG_ARGV[0]::BOOLEAN IS DISTINCT FROM 'f'::BOOLEAN THEN
        audit_row.client_query = NULL;
    END IF;
 
    IF TG_ARGV[1] IS NOT NULL THEN
        excluded_cols = TG_ARGV[1]::text[];
    END IF;
 
    IF (TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*);
        audit_row.changed_fields =  (hstore(NEW.*) - audit_row.row_data) - excluded_cols;
        IF audit_row.changed_fields = hstore('') THEN
            -- All changed fields are ignored. Skip this update.
            RETURN NULL;
        END IF;
    ELSIF (TG_OP = 'DELETE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*) - excluded_cols;
    ELSIF (TG_OP = 'INSERT' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(NEW.*) - excluded_cols;
    ELSIF (TG_LEVEL = 'STATEMENT' AND TG_OP IN ('INSERT','UPDATE','DELETE','TRUNCATE')) THEN
        audit_row.statement_only = 't';
    ELSE
        RAISE EXCEPTION '[qwat_sys.if_modified_func] - Trigger func added as trigger for unhandled case: %, %',TG_OP, TG_LEVEL;
        RETURN NULL;
    END IF;
    INSERT INTO qwat_sys.logged_actions VALUES (audit_row.*);
    RETURN NULL;
END;
$$;


ALTER FUNCTION qwat_sys.if_modified_func() OWNER TO postgres;

--
-- Name: FUNCTION if_modified_func(); Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON FUNCTION if_modified_func() IS '
Track changes TO a TABLE at the statement AND/OR row level.
 
Optional parameters TO TRIGGER IN CREATE TRIGGER call:
 
param 0: BOOLEAN, whether TO log the query text. default ''t''.
 
param 1: text[], COLUMNS TO IGNORE IN updates. default [].
 
         Updates TO ignored cols are omitted FROM changed_fields.
 
         Updates WITH only ignored cols changed are NOT inserted
         INTO the audit log.
 
         Almost ALL the processing work IS still done FOR updates
         that ignored. IF you need TO save the LOAD, you need TO USE
         WHEN clause ON the TRIGGER instead.
 
         No warning OR error IS issued IF ignored_cols contains COLUMNS
         that do NOT exist IN the target TABLE. This lets you specify
         a standard SET of ignored COLUMNS.
 
There IS no parameter TO disable logging of VALUES. ADD this TRIGGER AS
a ''FOR EACH STATEMENT'' rather than ''FOR EACH ROW'' TRIGGER IF you do NOT
want TO log row VALUES.
 
Note that the user name logged IS the login role FOR the session. The audit TRIGGER
cannot obtain the active role because it IS reset BY the SECURITY DEFINER invocation
of the audit TRIGGER its self.
';


--
-- Name: version_dump(character varying); Type: FUNCTION; Schema: qwat_sys; Owner: postgres
--

CREATE FUNCTION version_dump(version character varying) RETURNS version_result
    LANGUAGE sql
    AS $_$
select
    a[1], a[2]::int, a[3]::int, a[4]::int, a[5], a[6]
from
    regexp_matches(version, '^v?((\d+)\.(\d+)\.(\d+))(?:-([\dA-Za-z\-]+(?:\.[\dA-Za-z\-]+)*))?(?:\+([\dA-Za-z\-]+(?:\.[\dA-Za-z\-]+)*))?$') as a
$_$;


ALTER FUNCTION qwat_sys.version_dump(version character varying) OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: pipe_material_displayname(); Type: FUNCTION; Schema: qwat_vl; Owner: postgres
--

CREATE FUNCTION pipe_material_displayname() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.diameter IS NULL OR NEW.diameter = '' THEN
			NEW._displayname_en := NEW.short_en;
			NEW._displayname_fr := NEW.short_fr;
                 	NEW._displayname_ro := NEW.short_ro;
                ELSE
			NEW._displayname_en := NEW.short_en||' '||NEW.diameter||COALESCE(' PN'||NEW.pressure_nominal,'');
		 	NEW._displayname_fr := NEW.short_fr||' '||NEW.diameter||COALESCE(' PN'||NEW.pressure_nominal,'');
                 	NEW._displayname_ro := NEW.short_ro||' '||NEW.diameter||COALESCE(' PN'||NEW.pressure_nominal,'');
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION qwat_vl.pipe_material_displayname() OWNER TO postgres;

--
-- Name: FUNCTION pipe_material_displayname(); Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON FUNCTION pipe_material_displayname() IS 'Fcn/Trigger: updates the fancy value_fr, value_ro and value_en in the material table.';


SET search_path = qwat_dr, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: annotationline; Type: TABLE; Schema: qwat_dr; Owner: postgres
--

CREATE TABLE annotationline (
    id integer NOT NULL,
    labelvisible boolean DEFAULT true NOT NULL,
    text_size numeric(7,2),
    text_orientation numeric(7,2),
    annotation text,
    scale_1 boolean DEFAULT true,
    scale_2 boolean DEFAULT true,
    geometry public.geometry(LineString,21781)
);


ALTER TABLE annotationline OWNER TO postgres;

--
-- Name: TABLE annotationline; Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON TABLE annotationline IS 'Table for annotationlines.';


--
-- Name: annotationline_id_seq; Type: SEQUENCE; Schema: qwat_dr; Owner: postgres
--

CREATE SEQUENCE annotationline_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE annotationline_id_seq OWNER TO postgres;

--
-- Name: annotationline_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_dr; Owner: postgres
--

ALTER SEQUENCE annotationline_id_seq OWNED BY annotationline.id;


--
-- Name: annotationpoint; Type: TABLE; Schema: qwat_dr; Owner: postgres
--

CREATE TABLE annotationpoint (
    id integer NOT NULL,
    text_size numeric(7,2),
    text_orientation numeric(7,2),
    annotation text,
    scale_1 boolean DEFAULT true,
    scale_2 boolean DEFAULT true,
    geometry public.geometry(Point,21781)
);


ALTER TABLE annotationpoint OWNER TO postgres;

--
-- Name: TABLE annotationpoint; Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON TABLE annotationpoint IS 'Table for annotationpoints.';


--
-- Name: annotationpoint_id_seq; Type: SEQUENCE; Schema: qwat_dr; Owner: postgres
--

CREATE SEQUENCE annotationpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE annotationpoint_id_seq OWNER TO postgres;

--
-- Name: annotationpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_dr; Owner: postgres
--

ALTER SEQUENCE annotationpoint_id_seq OWNED BY annotationpoint.id;


--
-- Name: constructionpoint; Type: TABLE; Schema: qwat_dr; Owner: postgres
--

CREATE TABLE constructionpoint (
    id integer NOT NULL,
    altitude numeric(10,3),
    fk_object_reference integer,
    code character varying(15),
    measurement_campaign character varying(200),
    remark text,
    geometry public.geometry(PointZ,21781)
);


ALTER TABLE constructionpoint OWNER TO postgres;

--
-- Name: TABLE constructionpoint; Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON TABLE constructionpoint IS 'construction points are artificials points to build objects.';


--
-- Name: constructionpoint_id_seq; Type: SEQUENCE; Schema: qwat_dr; Owner: postgres
--

CREATE SEQUENCE constructionpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE constructionpoint_id_seq OWNER TO postgres;

--
-- Name: constructionpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_dr; Owner: postgres
--

ALTER SEQUENCE constructionpoint_id_seq OWNED BY constructionpoint.id;


--
-- Name: dimension_distance; Type: TABLE; Schema: qwat_dr; Owner: postgres
--

CREATE TABLE dimension_distance (
    id integer NOT NULL,
    observation character varying(120),
    _calculation double precision,
    remark text,
    geometry public.geometry(LineString,21781)
);


ALTER TABLE dimension_distance OWNER TO postgres;

--
-- Name: TABLE dimension_distance; Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON TABLE dimension_distance IS 'dimension arcs displays measures done on the field. For example: distances to buildings corner';


--
-- Name: dimension_distance_id_seq; Type: SEQUENCE; Schema: qwat_dr; Owner: postgres
--

CREATE SEQUENCE dimension_distance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dimension_distance_id_seq OWNER TO postgres;

--
-- Name: dimension_distance_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_dr; Owner: postgres
--

ALTER SEQUENCE dimension_distance_id_seq OWNED BY dimension_distance.id;


--
-- Name: dimension_orientation; Type: TABLE; Schema: qwat_dr; Owner: postgres
--

CREATE TABLE dimension_orientation (
    id integer NOT NULL,
    observation character varying(120),
    remark text,
    geometry public.geometry(LineString,21781)
);


ALTER TABLE dimension_orientation OWNER TO postgres;

--
-- Name: TABLE dimension_orientation; Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON TABLE dimension_orientation IS 'dimension arcs displays measures done on the field. For example: orientations to buildings corner';


--
-- Name: dimension_orientation_id_seq; Type: SEQUENCE; Schema: qwat_dr; Owner: postgres
--

CREATE SEQUENCE dimension_orientation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dimension_orientation_id_seq OWNER TO postgres;

--
-- Name: dimension_orientation_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_dr; Owner: postgres
--

ALTER SEQUENCE dimension_orientation_id_seq OWNED BY dimension_orientation.id;


SET search_path = qwat_od, pg_catalog;

--
-- Name: chamber; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE chamber (
    id integer NOT NULL,
    networkseparation boolean,
    flow_meter boolean,
    water_meter boolean,
    manometer boolean,
    depth numeric(10,3),
    no_valves smallint
);


ALTER TABLE chamber OWNER TO postgres;

--
-- Name: COLUMN chamber.flow_meter; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN chamber.flow_meter IS 'is a flow_meter present?';


--
-- Name: COLUMN chamber.water_meter; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN chamber.water_meter IS 'is a water_meter present?';


--
-- Name: COLUMN chamber.manometer; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN chamber.manometer IS 'is a manometer present?';


--
-- Name: consumptionzone; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE consumptionzone (
    id integer NOT NULL,
    name character varying(50),
    population integer DEFAULT 0,
    colorcode smallint
);


ALTER TABLE consumptionzone OWNER TO postgres;

--
-- Name: TABLE consumptionzone; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE consumptionzone IS 'consumption zones.';


--
-- Name: consumptionzone_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE consumptionzone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE consumptionzone_id_seq OWNER TO postgres;

--
-- Name: consumptionzone_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE consumptionzone_id_seq OWNED BY consumptionzone.id;


--
-- Name: cover; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE cover (
    id integer NOT NULL,
    identification character varying(50),
    fk_distributor integer,
    fk_status integer,
    fk_cover_type integer,
    fk_installation integer,
    year smallint,
    altitude numeric(8,3),
    circular boolean DEFAULT true,
    form_dimension numeric(10,3),
    remark text,
    geometry public.geometry(PointZ,21781) NOT NULL,
    geometry_polygon public.geometry(Polygon,21781),
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120),
    CONSTRAINT cover_year_check CHECK (((year IS NULL) OR ((year > 1800) AND (year < 2100))))
);


ALTER TABLE cover OWNER TO postgres;

--
-- Name: TABLE cover; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE cover IS 'Table for installation covers.  Inherits from node.';


--
-- Name: COLUMN cover.form_dimension; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN cover.form_dimension IS 'depending on the cover form, it represents either the diameter of circle or the length of a square side';


--
-- Name: cover_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE cover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cover_id_seq OWNER TO postgres;

--
-- Name: cover_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE cover_id_seq OWNED BY cover.id;


--
-- Name: crossing; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE crossing (
    id integer NOT NULL,
    disabled boolean DEFAULT false NOT NULL,
    controled boolean DEFAULT false NOT NULL,
    hide_pipe smallint DEFAULT 1 NOT NULL,
    _pipe1_id integer,
    _pipe2_id integer,
    _pipe1_angle double precision,
    _pipe2_angle double precision,
    geometry public.geometry(Point,21781) NOT NULL
);


ALTER TABLE crossing OWNER TO postgres;

--
-- Name: crossing_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE crossing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE crossing_id_seq OWNER TO postgres;

--
-- Name: crossing_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE crossing_id_seq OWNED BY crossing.id;


--
-- Name: distributor; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE distributor (
    id integer NOT NULL,
    name character varying(30)
);


ALTER TABLE distributor OWNER TO postgres;

--
-- Name: TABLE distributor; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE distributor IS 'Companies and distributors list.';


--
-- Name: distributor_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE distributor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE distributor_id_seq OWNER TO postgres;

--
-- Name: distributor_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE distributor_id_seq OWNED BY distributor.id;


--
-- Name: district; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE district (
    id integer NOT NULL,
    name character varying(40) NOT NULL,
    shortname character varying(12),
    zip character varying(12),
    land_registry character varying(12),
    prefix character varying(12),
    colorcode smallint DEFAULT 1,
    geometry public.geometry(MultiPolygon,21781),
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120)
);


ALTER TABLE district OWNER TO postgres;

--
-- Name: TABLE district; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE district IS 'Districts.';


--
-- Name: district_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE district_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE district_id_seq OWNER TO postgres;

--
-- Name: district_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE district_id_seq OWNED BY district.id;


--
-- Name: folder; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE folder (
    id integer NOT NULL,
    identification character varying(50) NOT NULL,
    description text,
    date_start date,
    date_end date,
    geometry_polygon public.geometry(MultiPolygon,21781),
    geometry_line public.geometry(MultiLineString,21781)
);


ALTER TABLE folder OWNER TO postgres;

--
-- Name: TABLE folder; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE folder IS 'Technical folders.';


--
-- Name: folder_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE folder_id_seq OWNER TO postgres;

--
-- Name: folder_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE folder_id_seq OWNED BY folder.id;


--
-- Name: hydrant; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE hydrant (
    id integer NOT NULL,
    fk_provider integer,
    fk_model_sup integer NOT NULL,
    fk_model_inf integer NOT NULL,
    fk_material integer NOT NULL,
    fk_output integer NOT NULL,
    underground boolean DEFAULT false,
    marked boolean DEFAULT false,
    pressure_static numeric(5,2),
    pressure_dynamic numeric(5,2),
    flow numeric(8,2),
    observation_date date,
    observation_source character varying(45)
);


ALTER TABLE hydrant OWNER TO postgres;

--
-- Name: TABLE hydrant; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE hydrant IS 'hydrant. Inherits from node.';


--
-- Name: COLUMN hydrant.marked; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN hydrant.marked IS 'does it have markings pointing to it';


--
-- Name: COLUMN hydrant.pressure_static; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN hydrant.pressure_static IS 'pression statique [bar]';


--
-- Name: COLUMN hydrant.pressure_dynamic; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN hydrant.pressure_dynamic IS 'pression dynamique [bar]';


--
-- Name: COLUMN hydrant.flow; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN hydrant.flow IS 'debit dynamique pour une pression dynamique de 2 bars [l/min]';


--
-- Name: installation; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE installation (
    id integer NOT NULL,
    name character varying(60),
    fk_parent integer,
    fk_remote integer,
    fk_watertype integer NOT NULL,
    parcel character varying(30),
    eca character varying(30),
    open_water_surface boolean DEFAULT false,
    geometry_polygon public.geometry(MultiPolygon,21781)
);


ALTER TABLE installation OWNER TO postgres;

--
-- Name: TABLE installation; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE installation IS 'This is the base table for all installation types.';


--
-- Name: leak; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE leak (
    id integer NOT NULL,
    fk_cause integer NOT NULL,
    fk_pipe integer,
    widespread_damage boolean NOT NULL,
    detection_date date,
    repair_date date,
    _repaired boolean,
    address text,
    pipe_replaced boolean,
    description text,
    repair text,
    geometry public.geometry(Point,21781),
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120)
);


ALTER TABLE leak OWNER TO postgres;

--
-- Name: TABLE leak; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE leak IS 'pipe leaks';


--
-- Name: leak_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE leak_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE leak_id_seq OWNER TO postgres;

--
-- Name: leak_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE leak_id_seq OWNED BY leak.id;


--
-- Name: meter; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE meter (
    id integer NOT NULL,
    fk_pipe integer,
    parcel character varying(50)
);


ALTER TABLE meter OWNER TO postgres;

--
-- Name: TABLE meter; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE meter IS 'Table for meters. Inherits from node.';


--
-- Name: meter_reference; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE meter_reference (
    id integer NOT NULL,
    fk_meter integer NOT NULL,
    geometry public.geometry(Point,21781)
);


ALTER TABLE meter_reference OWNER TO postgres;

--
-- Name: TABLE meter_reference; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE meter_reference IS 'Table for meter references. These are used to place references to meters if they rely far away from their pipe (i.e. on another printed map). Hence, the reference is printed on the same map than the pipe.';


--
-- Name: meter_reference_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE meter_reference_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE meter_reference_id_seq OWNER TO postgres;

--
-- Name: meter_reference_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE meter_reference_id_seq OWNED BY meter_reference.id;


--
-- Name: network_element; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE network_element (
    id integer NOT NULL,
    identification character varying(50),
    fk_distributor integer NOT NULL,
    fk_status integer NOT NULL,
    fk_folder integer,
    fk_locationtype integer[],
    fk_precision integer NOT NULL,
    fk_precisionalti integer,
    fk_object_reference integer,
    altitude numeric(10,3) DEFAULT NULL::numeric,
    year smallint,
    year_end smallint,
    orientation double precision,
    remark text,
    schema_force_visible boolean,
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120),
    CONSTRAINT chk_element_altitude_obj_ref CHECK (((fk_object_reference IS NOT NULL) OR (altitude IS NULL))),
    CONSTRAINT chk_element_altitude_precisionalti CHECK (((fk_precisionalti IS NOT NULL) OR (altitude IS NULL))),
    CONSTRAINT network_element_year_check CHECK (((year IS NULL) OR ((year > 1800) AND (year < 2100)))),
    CONSTRAINT network_element_year_end_check CHECK (((year_end IS NULL) OR ((year_end > 1800) AND (year_end < 2100))))
);


ALTER TABLE network_element OWNER TO postgres;

--
-- Name: TABLE network_element; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE network_element IS 'Tables for network network_elements.
Every network_element of the network (hydrants, valves, network_element, installations, etc.) inherit from network_element which itself inherits from node.';


--
-- Name: COLUMN network_element.orientation; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN network_element.orientation IS 'orientation field aims at overwrtiting qwat_od.node._pipe_orientation which is automatically calculated from the pipes. In the editable views, orientation will be COALESCE(netwrok_element.orientation, node._pipe_orientation). Update will be forwarded to network_element.';


--
-- Name: node; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE node (
    id integer NOT NULL,
    fk_district integer,
    fk_pressurezone integer,
    fk_printmap integer[],
    _printmaps text,
    _geometry_alt1_used boolean,
    _geometry_alt2_used boolean,
    _pipe_node_type pipe_connection,
    _pipe_orientation double precision DEFAULT 0,
    _pipe_schema_visible boolean DEFAULT false,
    geometry public.geometry(PointZ,21781) NOT NULL,
    geometry_alt1 public.geometry(PointZ,21781),
    geometry_alt2 public.geometry(PointZ,21781),
    update_geometry_alt1 boolean,
    update_geometry_alt2 boolean
);


ALTER TABLE node OWNER TO postgres;

--
-- Name: TABLE node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE node IS 'Tables for network nodes.
Every element of the network (hydrants, valves, element, installations, etc.) inherit from element which itself inherits from node.
Node should only contain geometric fields and automatic attributes (district, pressurezone, printmaps, etc).';


--
-- Name: node_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE node_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE node_id_seq OWNER TO postgres;

--
-- Name: node_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE node_id_seq OWNED BY node.id;


--
-- Name: part; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE part (
    id integer NOT NULL,
    fk_part_type integer NOT NULL,
    fk_pipe integer
);


ALTER TABLE part OWNER TO postgres;

--
-- Name: TABLE part; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE part IS 'Table for installation parts. Inherits from node.';


--
-- Name: pipe; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE pipe (
    id integer NOT NULL,
    fk_parent integer,
    fk_function integer NOT NULL,
    fk_installmethod integer NOT NULL,
    fk_material integer NOT NULL,
    fk_distributor integer NOT NULL,
    fk_precision integer NOT NULL,
    fk_bedding integer NOT NULL,
    fk_protection integer,
    fk_status integer NOT NULL,
    fk_watertype integer NOT NULL,
    fk_locationtype integer[],
    fk_folder integer,
    year smallint,
    year_rehabilitation smallint,
    year_end smallint,
    tunnel_or_bridge boolean DEFAULT false,
    pressure_nominal smallint DEFAULT 16,
    remark text,
    _valve_count smallint,
    _valve_closed boolean,
    schema_force_visible boolean,
    label_1_visible smallint DEFAULT 1,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_text character varying(120),
    fk_node_a integer NOT NULL,
    fk_node_b integer NOT NULL,
    fk_district integer,
    fk_pressurezone integer,
    fk_printmap integer[],
    _length2d numeric(8,2),
    _length3d numeric(8,2),
    _diff_elevation numeric(8,2),
    _printmaps character varying(100),
    _geometry_alt1_used boolean,
    _geometry_alt2_used boolean,
    update_geometry_alt1 boolean,
    update_geometry_alt2 boolean,
    geometry public.geometry(LineStringZ,21781) NOT NULL,
    geometry_alt1 public.geometry(LineStringZ,21781),
    geometry_alt2 public.geometry(LineStringZ,21781),
    CONSTRAINT pipe_year_check CHECK (((year IS NULL) OR ((year > 1800) AND (year < 2100)))),
    CONSTRAINT pipe_year_end_check CHECK (((year_end IS NULL) OR ((year_end > 1800) AND (year_end < 2100)))),
    CONSTRAINT pipe_year_rehabilitation_check CHECK (((year_rehabilitation IS NULL) OR ((year_rehabilitation > 1800) AND (year_rehabilitation < 2100))))
);


ALTER TABLE pipe OWNER TO postgres;

--
-- Name: TABLE pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE pipe IS 'Table for pipes.';


--
-- Name: pipe_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE pipe_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pipe_id_seq OWNER TO postgres;

--
-- Name: pipe_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE pipe_id_seq OWNED BY pipe.id;


--
-- Name: pressurecontrol; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE pressurecontrol (
    id integer NOT NULL,
    fk_pressurecontrol_type integer NOT NULL
);


ALTER TABLE pressurecontrol OWNER TO postgres;

--
-- Name: pressurezone; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE pressurezone (
    id integer NOT NULL,
    fk_distributor integer NOT NULL,
    fk_consumptionzone integer,
    name character varying(50) NOT NULL,
    population integer,
    subscriber integer,
    colorcode smallint,
    geometry public.geometry(MultiPolygon,21781),
    geometry_alt1 public.geometry(MultiPolygon,21781),
    geometry_alt2 public.geometry(MultiPolygon,21781),
    _geometry_alt1_used boolean,
    _geometry_alt2_used boolean,
    update_geometry_alt1 boolean,
    update_geometry_alt2 boolean,
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120)
);


ALTER TABLE pressurezone OWNER TO postgres;

--
-- Name: TABLE pressurezone; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE pressurezone IS 'Pressure zones.';


--
-- Name: pressurezone_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE pressurezone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pressurezone_id_seq OWNER TO postgres;

--
-- Name: pressurezone_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE pressurezone_id_seq OWNED BY pressurezone.id;


--
-- Name: printmap; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE printmap (
    id integer NOT NULL,
    name character varying(20),
    fk_district smallint,
    remark text,
    version_date date,
    x_min double precision,
    y_min double precision,
    x_max double precision,
    y_max double precision,
    geometry public.geometry(Polygon,21781),
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120)
);


ALTER TABLE printmap OWNER TO postgres;

--
-- Name: TABLE printmap; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE printmap IS 'This table is used for polygons for predefined printable maps. shortname would be used as label string, and long_mame would be used in the print composer.';


--
-- Name: printmap_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE printmap_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE printmap_id_seq OWNER TO postgres;

--
-- Name: printmap_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE printmap_id_seq OWNED BY printmap.id;


--
-- Name: protectionzone; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE protectionzone (
    id integer NOT NULL,
    fk_type integer,
    name character varying(40),
    validated boolean DEFAULT true,
    date date,
    agent character varying(40),
    geometry public.geometry(MultiPolygon,21781)
);


ALTER TABLE protectionzone OWNER TO postgres;

--
-- Name: TABLE protectionzone; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE protectionzone IS 'protectionzones.';


--
-- Name: protectionzone_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE protectionzone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE protectionzone_id_seq OWNER TO postgres;

--
-- Name: protectionzone_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE protectionzone_id_seq OWNED BY protectionzone.id;


--
-- Name: pump; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE pump (
    id integer NOT NULL,
    fk_pump_type smallint,
    fk_pipe_in integer,
    fk_pipe_out integer,
    fk_pump_operating smallint,
    no_pumps smallint,
    rejected_flow numeric(10,2),
    manometric_height numeric(10,2)
);


ALTER TABLE pump OWNER TO postgres;

--
-- Name: remote; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE remote (
    id integer NOT NULL,
    fk_distributor integer,
    fk_status integer,
    fk_precision integer,
    fk_material integer,
    identification character varying(15),
    year smallint,
    origin character varying(150),
    destination character varying(150),
    folder character varying(50),
    plan character varying(50),
    remark text,
    _geometry_alt1_used boolean,
    _geometry_alt2_used boolean,
    update_geometry_alt1 boolean,
    update_geometry_alt2 boolean,
    geometry public.geometry(MultiLineString,21781) NOT NULL,
    geometry_alt1 public.geometry(MultiLineString,21781),
    geometry_alt2 public.geometry(MultiLineString,21781),
    label_1_visible smallint DEFAULT 1,
    label_1_x double precision,
    label_1_y double precision,
    label_1_rotation double precision,
    label_1_text character varying(120),
    label_2_visible smallint DEFAULT 1,
    label_2_x double precision,
    label_2_y double precision,
    label_2_rotation double precision,
    label_2_text character varying(120),
    CONSTRAINT remote_year_check CHECK (((year IS NULL) OR ((year > 1800) AND (year < 2100))))
);


ALTER TABLE remote OWNER TO postgres;

--
-- Name: TABLE remote; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE remote IS 'Table for installation remotes.';


--
-- Name: remote_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE remote_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE remote_id_seq OWNER TO postgres;

--
-- Name: remote_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE remote_id_seq OWNED BY remote.id;


--
-- Name: samplingpoint; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE samplingpoint (
    id integer NOT NULL
);


ALTER TABLE samplingpoint OWNER TO postgres;

--
-- Name: TABLE samplingpoint; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE samplingpoint IS 'Table for sampling points. Inherits from node.';


--
-- Name: source; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE source (
    id integer NOT NULL,
    fk_source_type smallint,
    fk_source_quality smallint,
    flow_lowest numeric(10,3),
    flow_average numeric(10,3),
    flow_concession numeric(10,2),
    contract_end date,
    gathering_chamber boolean
);


ALTER TABLE source OWNER TO postgres;

--
-- Name: subscriber; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE subscriber (
    id integer NOT NULL,
    fk_subscriber_type integer NOT NULL,
    fk_pipe integer,
    parcel character varying(12),
    flow_current numeric(8,2),
    flow_planned numeric(8,2)
);


ALTER TABLE subscriber OWNER TO postgres;

--
-- Name: TABLE subscriber; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE subscriber IS 'Table for subscriber. Inherits from node.';


--
-- Name: subscriber_reference; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE subscriber_reference (
    id integer NOT NULL,
    fk_subscriber integer NOT NULL,
    geometry public.geometry(Point,21781)
);


ALTER TABLE subscriber_reference OWNER TO postgres;

--
-- Name: TABLE subscriber_reference; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE subscriber_reference IS 'Table for subscriber references. These are used to place references to subscribers if they rely far away from their pipe (i.e. on another printed map). Hence, the reference is printed on the same map than the pipe.';


--
-- Name: subscriber_reference_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE subscriber_reference_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE subscriber_reference_id_seq OWNER TO postgres;

--
-- Name: subscriber_reference_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE subscriber_reference_id_seq OWNED BY subscriber_reference.id;


--
-- Name: surveypoint; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE surveypoint (
    id integer NOT NULL,
    fk_survey_type integer NOT NULL,
    fk_worker integer,
    code character varying(50),
    description text,
    date date,
    fk_folder integer,
    altitude numeric(10,3) DEFAULT NULL::numeric,
    geometry public.geometry(PointZ,21781)
);


ALTER TABLE surveypoint OWNER TO postgres;

--
-- Name: TABLE surveypoint; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE surveypoint IS 'Table for sampling points. Inherits from surveypoint.';


--
-- Name: tank; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE tank (
    id integer NOT NULL,
    fk_overflow integer,
    fk_tank_firestorage integer,
    storage_total numeric(10,1),
    storage_supply numeric(10,1),
    storage_fire numeric(10,1),
    altitude_overflow numeric(7,3),
    altitude_apron numeric(7,3),
    height_max numeric(7,3),
    fire_valve boolean,
    fire_remote boolean,
    _litrepercm numeric(9,3),
    cistern1_fk_type integer,
    cistern1_dimension_1 numeric(10,2),
    cistern1_dimension_2 numeric(10,2),
    cistern1_storage numeric(10,2),
    _cistern1_litrepercm numeric(9,3),
    cistern2_fk_type integer,
    cistern2_dimension_1 numeric(10,2),
    cistern2_dimension_2 numeric(10,2),
    cistern2_storage numeric(10,2),
    _cistern2_litrepercm numeric(9,3)
);


ALTER TABLE tank OWNER TO postgres;

--
-- Name: COLUMN tank.storage_total; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN tank.storage_total IS 'litres';


--
-- Name: COLUMN tank.storage_supply; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN tank.storage_supply IS 'litres';


--
-- Name: COLUMN tank.storage_fire; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON COLUMN tank.storage_fire IS 'litres';


--
-- Name: treatment; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE treatment (
    id integer NOT NULL,
    sanitization_uv boolean,
    sanitization_chlorine_liquid boolean,
    sanitization_chlorine_gazeous boolean,
    sanitization_ozone boolean,
    filtration_membrane boolean,
    filtration_sandorgravel boolean,
    flocculation boolean,
    activatedcharcoal boolean,
    settling boolean,
    treatment_capacity numeric(10,2)
);


ALTER TABLE treatment OWNER TO postgres;

--
-- Name: valve; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE valve (
    id integer NOT NULL,
    fk_valve_type integer NOT NULL,
    fk_valve_function integer NOT NULL,
    fk_valve_actuation integer NOT NULL,
    fk_pipe integer,
    fk_handle_precision integer,
    fk_handle_precisionalti integer,
    fk_maintenance integer[],
    diameter_nominal character varying(10),
    closed boolean DEFAULT false,
    networkseparation boolean DEFAULT false,
    handle_altitude numeric(10,3),
    handle_geometry public.geometry(PointZ,21781)
);


ALTER TABLE valve OWNER TO postgres;

--
-- Name: TABLE valve; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE valve IS 'Table for valve. Inherits from node.';


--
-- Name: vw_consumptionzone; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_consumptionzone AS
 SELECT co.id,
    co.name,
    co.population,
    co.colorcode,
    pr._sum_population,
    pr._sum_subscriber,
    pr.geometry
   FROM consumptionzone co,
    ( SELECT pr_1.fk_consumptionzone,
            sum(pr_1.population) AS _sum_population,
            sum(pr_1.subscriber) AS _sum_subscriber,
            (public.st_multi(public.st_collectionhomogenize(public.st_union(pr_1.geometry))))::public.geometry(MultiPolygon,21781) AS geometry
           FROM pressurezone pr_1
          GROUP BY pr_1.fk_consumptionzone) pr
  WHERE (pr.fk_consumptionzone = co.id);


ALTER TABLE vw_consumptionzone OWNER TO postgres;

--
-- Name: vw_node_element; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_node_element AS
 SELECT node.id,
    node.fk_district,
    node.fk_pressurezone,
    node.fk_printmap,
    node._printmaps,
    node._geometry_alt1_used,
    node._geometry_alt2_used,
    node._pipe_node_type,
    node._pipe_orientation,
    node._pipe_schema_visible,
    node.geometry,
    node.geometry_alt1,
    node.geometry_alt2,
    node.update_geometry_alt1,
    node.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    COALESCE(element.orientation, (- node._pipe_orientation)) AS orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text
   FROM (network_element element
     JOIN node node ON ((element.id = node.id)));


ALTER TABLE vw_node_element OWNER TO postgres;

--
-- Name: vw_element_hydrant; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_hydrant AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
    hydrant.fk_provider,
    hydrant.fk_model_sup,
    hydrant.fk_model_inf,
    hydrant.fk_material,
    hydrant.fk_output,
    hydrant.underground,
    hydrant.marked,
    hydrant.pressure_static,
    hydrant.pressure_dynamic,
    hydrant.flow,
    hydrant.observation_date,
    hydrant.observation_source
   FROM (hydrant hydrant
     JOIN vw_node_element element ON ((hydrant.id = element.id)));


ALTER TABLE vw_element_hydrant OWNER TO postgres;

--
-- Name: vw_qwat_installation; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_qwat_installation AS
 SELECT
        CASE
            WHEN (source.id IS NOT NULL) THEN 'source'::installation_type
            WHEN (pump.id IS NOT NULL) THEN 'pump'::installation_type
            WHEN (tank.id IS NOT NULL) THEN 'tank'::installation_type
            WHEN (treatment.id IS NOT NULL) THEN 'treatment'::installation_type
            WHEN (chamber.id IS NOT NULL) THEN 'chamber'::installation_type
            WHEN (pressurecontrol.id IS NOT NULL) THEN 'pressurecontrol'::installation_type
            ELSE 'installation'::installation_type
        END AS installation_type,
    installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    source.fk_source_type,
    source.fk_source_quality,
    source.flow_lowest,
    source.flow_average,
    source.flow_concession,
    source.contract_end,
    source.gathering_chamber,
    pump.fk_pump_type,
    pump.fk_pipe_in,
    pump.fk_pipe_out,
    pump.fk_pump_operating,
    pump.no_pumps,
    pump.rejected_flow,
    pump.manometric_height,
    tank.fk_overflow,
    tank.fk_tank_firestorage,
    tank.storage_total,
    tank.storage_supply,
    tank.storage_fire,
    tank.altitude_overflow,
    tank.altitude_apron,
    tank.height_max,
    tank.fire_valve,
    tank.fire_remote,
    tank._litrepercm,
    tank.cistern1_fk_type,
    tank.cistern1_dimension_1,
    tank.cistern1_dimension_2,
    tank.cistern1_storage,
    tank._cistern1_litrepercm,
    tank.cistern2_fk_type,
    tank.cistern2_dimension_1,
    tank.cistern2_dimension_2,
    tank.cistern2_storage,
    tank._cistern2_litrepercm,
    treatment.sanitization_uv,
    treatment.sanitization_chlorine_liquid,
    treatment.sanitization_chlorine_gazeous,
    treatment.sanitization_ozone,
    treatment.filtration_membrane,
    treatment.filtration_sandorgravel,
    treatment.flocculation,
    treatment.activatedcharcoal,
    treatment.settling,
    treatment.treatment_capacity,
    chamber.networkseparation,
    chamber.flow_meter,
    chamber.water_meter,
    chamber.manometer,
    chamber.depth,
    chamber.no_valves,
    pressurecontrol.fk_pressurecontrol_type
   FROM ((((((installation installation
     LEFT JOIN source source ON ((installation.id = source.id)))
     LEFT JOIN pump pump ON ((installation.id = pump.id)))
     LEFT JOIN tank tank ON ((installation.id = tank.id)))
     LEFT JOIN treatment treatment ON ((installation.id = treatment.id)))
     LEFT JOIN chamber chamber ON ((installation.id = chamber.id)))
     LEFT JOIN pressurecontrol pressurecontrol ON ((installation.id = pressurecontrol.id)));


ALTER TABLE vw_qwat_installation OWNER TO postgres;

--
-- Name: vw_element_installation; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_installation AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
    installation.installation_type,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    installation.fk_source_type,
    installation.fk_source_quality,
    installation.flow_lowest,
    installation.flow_average,
    installation.flow_concession,
    installation.contract_end,
    installation.gathering_chamber,
    installation.fk_pump_type,
    installation.fk_pipe_in,
    installation.fk_pipe_out,
    installation.fk_pump_operating,
    installation.no_pumps,
    installation.rejected_flow,
    installation.manometric_height,
    installation.fk_overflow,
    installation.fk_tank_firestorage,
    installation.storage_total,
    installation.storage_supply,
    installation.storage_fire,
    installation.altitude_overflow,
    installation.altitude_apron,
    installation.height_max,
    installation.fire_valve,
    installation.fire_remote,
    installation._litrepercm,
    installation.cistern1_fk_type,
    installation.cistern1_dimension_1,
    installation.cistern1_dimension_2,
    installation.cistern1_storage,
    installation._cistern1_litrepercm,
    installation.cistern2_fk_type,
    installation.cistern2_dimension_1,
    installation.cistern2_dimension_2,
    installation.cistern2_storage,
    installation._cistern2_litrepercm,
    installation.sanitization_uv,
    installation.sanitization_chlorine_liquid,
    installation.sanitization_chlorine_gazeous,
    installation.sanitization_ozone,
    installation.filtration_membrane,
    installation.filtration_sandorgravel,
    installation.flocculation,
    installation.activatedcharcoal,
    installation.settling,
    installation.treatment_capacity,
    installation.networkseparation,
    installation.flow_meter,
    installation.water_meter,
    installation.manometer,
    installation.depth,
    installation.no_valves,
    installation.fk_pressurecontrol_type
   FROM (vw_qwat_installation installation
     JOIN vw_node_element element ON ((installation.id = element.id)));


ALTER TABLE vw_element_installation OWNER TO postgres;

--
-- Name: vw_element_meter; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_meter AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
    meter.fk_pipe,
    meter.parcel
   FROM (meter meter
     JOIN vw_node_element element ON ((meter.id = element.id)));


ALTER TABLE vw_element_meter OWNER TO postgres;

--
-- Name: vw_element_part; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_part AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
    part.fk_part_type,
    part.fk_pipe
   FROM (part part
     JOIN vw_node_element element ON ((part.id = element.id)));


ALTER TABLE vw_element_part OWNER TO postgres;

--
-- Name: vw_element_samplingpoint; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_samplingpoint AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text
   FROM (samplingpoint samplingpoint
     JOIN vw_node_element element ON ((samplingpoint.id = element.id)));


ALTER TABLE vw_element_samplingpoint OWNER TO postgres;

--
-- Name: vw_element_subscriber; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_subscriber AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
    subscriber.fk_subscriber_type,
    subscriber.fk_pipe,
    subscriber.parcel,
    subscriber.flow_current,
    subscriber.flow_planned
   FROM (subscriber subscriber
     JOIN vw_node_element element ON ((subscriber.id = element.id)));


ALTER TABLE vw_element_subscriber OWNER TO postgres;

--
-- Name: vw_element_valve; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_element_valve AS
 SELECT element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
    valve.fk_valve_type,
    valve.fk_valve_function,
    valve.fk_valve_actuation,
    valve.fk_pipe,
    valve.fk_handle_precision,
    valve.fk_handle_precisionalti,
    valve.fk_maintenance,
    valve.diameter_nominal,
    valve.closed,
    valve.networkseparation,
    valve.handle_altitude,
    valve.handle_geometry
   FROM (valve valve
     JOIN vw_node_element element ON ((valve.id = element.id)));


ALTER TABLE vw_element_valve OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: value_list_base; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE value_list_base (
    id integer NOT NULL,
    vl_active boolean DEFAULT true,
    short_fr character varying(10),
    short_en character varying(10),
    short_ro character varying(10),
    value_fr character varying(50),
    value_en character varying(50),
    value_ro character varying(50),
    description_fr text,
    description_en text,
    description_ro text
);


ALTER TABLE value_list_base OWNER TO postgres;

--
-- Name: TABLE value_list_base; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE value_list_base IS 'Master tables for value lists. It will be inherited by value list tables. This table shall not be filled. Be warned that value list table shal have its own unique index on id since PG does not propagate indexes. Therefore unicity of id cannot be garanteed over all value lists.';


--
-- Name: hydrant_material; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE hydrant_material (
    pressure_nominal smallint
)
INHERITS (value_list_base);


ALTER TABLE hydrant_material OWNER TO postgres;

--
-- Name: COLUMN hydrant_material.pressure_nominal; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON COLUMN hydrant_material.pressure_nominal IS 'nominal pressure in bars';


--
-- Name: hydrant_model_inf; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE hydrant_model_inf (
)
INHERITS (value_list_base);


ALTER TABLE hydrant_model_inf OWNER TO postgres;

--
-- Name: hydrant_model_sup; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE hydrant_model_sup (
)
INHERITS (value_list_base);


ALTER TABLE hydrant_model_sup OWNER TO postgres;

--
-- Name: hydrant_output; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE hydrant_output (
)
INHERITS (value_list_base);


ALTER TABLE hydrant_output OWNER TO postgres;

--
-- Name: hydrant_provider; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE hydrant_provider (
)
INHERITS (value_list_base);


ALTER TABLE hydrant_provider OWNER TO postgres;

--
-- Name: TABLE hydrant_provider; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE hydrant_provider IS 'hydrant providers list.';


--
-- Name: object_reference; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE object_reference (
)
INHERITS (value_list_base);


ALTER TABLE object_reference OWNER TO postgres;

--
-- Name: TABLE object_reference; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE object_reference IS 'Reference for object measurements depicting where the measurement took place on the object, with respect to the sea-level';


--
-- Name: precision; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE "precision" (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE "precision" OWNER TO postgres;

--
-- Name: TABLE "precision"; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE "precision" IS 'pressure precision.';


--
-- Name: precisionalti; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE precisionalti (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE precisionalti OWNER TO postgres;

--
-- Name: TABLE precisionalti; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE precisionalti IS 'precision of altitude';


--
-- Name: status; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE status (
    active boolean DEFAULT true,
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE status OWNER TO postgres;

--
-- Name: TABLE status; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE status IS 'Status table, with SIRE id.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_hydrant; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_hydrant AS
 SELECT vw_element_hydrant.id,
    vw_element_hydrant.fk_district,
    vw_element_hydrant.fk_pressurezone,
    vw_element_hydrant.fk_printmap,
    vw_element_hydrant._printmaps,
    vw_element_hydrant._geometry_alt1_used,
    vw_element_hydrant._geometry_alt2_used,
    vw_element_hydrant._pipe_node_type,
    vw_element_hydrant._pipe_orientation,
    vw_element_hydrant._pipe_schema_visible,
    vw_element_hydrant.geometry,
    vw_element_hydrant.geometry_alt1,
    vw_element_hydrant.geometry_alt2,
    vw_element_hydrant.update_geometry_alt1,
    vw_element_hydrant.update_geometry_alt2,
    vw_element_hydrant.identification,
    vw_element_hydrant.fk_distributor,
    vw_element_hydrant.fk_status,
    vw_element_hydrant.fk_folder,
    vw_element_hydrant.fk_locationtype,
    vw_element_hydrant.fk_precision,
    vw_element_hydrant.fk_precisionalti,
    vw_element_hydrant.fk_object_reference,
    vw_element_hydrant.altitude,
    vw_element_hydrant.year,
    vw_element_hydrant.year_end,
    vw_element_hydrant.orientation,
    vw_element_hydrant.remark,
    vw_element_hydrant.schema_force_visible,
    vw_element_hydrant.label_1_visible,
    vw_element_hydrant.label_1_x,
    vw_element_hydrant.label_1_y,
    vw_element_hydrant.label_1_rotation,
    vw_element_hydrant.label_1_text,
    vw_element_hydrant.label_2_visible,
    vw_element_hydrant.label_2_x,
    vw_element_hydrant.label_2_y,
    vw_element_hydrant.label_2_rotation,
    vw_element_hydrant.label_2_text,
    vw_element_hydrant.fk_provider,
    vw_element_hydrant.fk_model_sup,
    vw_element_hydrant.fk_model_inf,
    vw_element_hydrant.fk_material,
    vw_element_hydrant.fk_output,
    vw_element_hydrant.underground,
    vw_element_hydrant.marked,
    vw_element_hydrant.pressure_static,
    vw_element_hydrant.pressure_dynamic,
    vw_element_hydrant.flow,
    vw_element_hydrant.observation_date,
    vw_element_hydrant.observation_source,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    model_inf.vl_active AS model_inf_vl_active,
    model_inf.short_fr AS model_inf_short_fr,
    model_inf.short_en AS model_inf_short_en,
    model_inf.short_ro AS model_inf_short_ro,
    model_inf.value_fr AS model_inf_value_fr,
    model_inf.value_en AS model_inf_value_en,
    model_inf.value_ro AS model_inf_value_ro,
    model_inf.description_fr AS model_inf_description_fr,
    model_inf.description_en AS model_inf_description_en,
    model_inf.description_ro AS model_inf_description_ro,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    material.vl_active AS material_vl_active,
    material.short_fr AS material_short_fr,
    material.short_en AS material_short_en,
    material.short_ro AS material_short_ro,
    material.value_fr AS material_value_fr,
    material.value_en AS material_value_en,
    material.value_ro AS material_value_ro,
    material.description_fr AS material_description_fr,
    material.description_en AS material_description_en,
    material.description_ro AS material_description_ro,
    material.pressure_nominal AS material_pressure_nominal,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    model_sup.vl_active AS model_sup_vl_active,
    model_sup.short_fr AS model_sup_short_fr,
    model_sup.short_en AS model_sup_short_en,
    model_sup.short_ro AS model_sup_short_ro,
    model_sup.value_fr AS model_sup_value_fr,
    model_sup.value_en AS model_sup_value_en,
    model_sup.value_ro AS model_sup_value_ro,
    model_sup.description_fr AS model_sup_description_fr,
    model_sup.description_en AS model_sup_description_en,
    model_sup.description_ro AS model_sup_description_ro,
    object_reference.vl_active AS object_reference_vl_active,
    object_reference.short_fr AS object_reference_short_fr,
    object_reference.short_en AS object_reference_short_en,
    object_reference.short_ro AS object_reference_short_ro,
    object_reference.value_fr AS object_reference_value_fr,
    object_reference.value_en AS object_reference_value_en,
    object_reference.value_ro AS object_reference_value_ro,
    object_reference.description_fr AS object_reference_description_fr,
    object_reference.description_en AS object_reference_description_en,
    object_reference.description_ro AS object_reference_description_ro,
    provider.vl_active AS provider_vl_active,
    provider.short_fr AS provider_short_fr,
    provider.short_en AS provider_short_en,
    provider.short_ro AS provider_short_ro,
    provider.value_fr AS provider_value_fr,
    provider.value_en AS provider_value_en,
    provider.value_ro AS provider_value_ro,
    provider.description_fr AS provider_description_fr,
    provider.description_en AS provider_description_en,
    provider.description_ro AS provider_description_ro,
    distributor.name AS distributor_name,
    output.vl_active AS output_vl_active,
    output.short_fr AS output_short_fr,
    output.short_en AS output_short_en,
    output.short_ro AS output_short_ro,
    output.value_fr AS output_value_fr,
    output.value_en AS output_value_en,
    output.value_ro AS output_value_ro,
    output.description_fr AS output_description_fr,
    output.description_en AS output_description_en,
    output.description_ro AS output_description_ro,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    precisionalti.vl_active AS precisionalti_vl_active,
    precisionalti.short_fr AS precisionalti_short_fr,
    precisionalti.short_en AS precisionalti_short_en,
    precisionalti.short_ro AS precisionalti_short_ro,
    precisionalti.value_fr AS precisionalti_value_fr,
    precisionalti.value_en AS precisionalti_value_en,
    precisionalti.value_ro AS precisionalti_value_ro,
    precisionalti.description_fr AS precisionalti_description_fr,
    precisionalti.description_en AS precisionalti_description_en,
    precisionalti.description_ro AS precisionalti_description_ro,
    precisionalti.code_sire AS precisionalti_code_sire
   FROM (((((((((((((vw_element_hydrant
     LEFT JOIN qwat_vl.status status ON ((vw_element_hydrant.fk_status = status.id)))
     LEFT JOIN district district ON ((vw_element_hydrant.fk_district = district.id)))
     LEFT JOIN qwat_vl.hydrant_model_inf model_inf ON ((vw_element_hydrant.fk_model_inf = model_inf.id)))
     LEFT JOIN pressurezone pressurezone ON ((vw_element_hydrant.fk_pressurezone = pressurezone.id)))
     LEFT JOIN qwat_vl.hydrant_material material ON ((vw_element_hydrant.fk_material = material.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((vw_element_hydrant.fk_precision = "precision".id)))
     LEFT JOIN qwat_vl.hydrant_model_sup model_sup ON ((vw_element_hydrant.fk_model_sup = model_sup.id)))
     LEFT JOIN qwat_vl.object_reference object_reference ON ((vw_element_hydrant.fk_object_reference = object_reference.id)))
     LEFT JOIN qwat_vl.hydrant_provider provider ON ((vw_element_hydrant.fk_provider = provider.id)))
     LEFT JOIN distributor distributor ON ((vw_element_hydrant.fk_distributor = distributor.id)))
     LEFT JOIN qwat_vl.hydrant_output output ON ((vw_element_hydrant.fk_output = output.id)))
     LEFT JOIN folder folder ON ((vw_element_hydrant.fk_folder = folder.id)))
     LEFT JOIN qwat_vl.precisionalti precisionalti ON ((vw_element_hydrant.fk_precisionalti = precisionalti.id)));


ALTER TABLE vw_export_hydrant OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: cistern; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE cistern (
)
INHERITS (value_list_base);


ALTER TABLE cistern OWNER TO postgres;

--
-- Name: overflow; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE overflow (
)
INHERITS (value_list_base);


ALTER TABLE overflow OWNER TO postgres;

--
-- Name: pressurecontrol_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pressurecontrol_type (
)
INHERITS (value_list_base);


ALTER TABLE pressurecontrol_type OWNER TO postgres;

--
-- Name: pump_operating; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pump_operating (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE pump_operating OWNER TO postgres;

--
-- Name: pump_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pump_type (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE pump_type OWNER TO postgres;

--
-- Name: remote_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE remote_type (
)
INHERITS (value_list_base);


ALTER TABLE remote_type OWNER TO postgres;

--
-- Name: source_quality; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE source_quality (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE source_quality OWNER TO postgres;

--
-- Name: source_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE source_type (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE source_type OWNER TO postgres;

--
-- Name: tank_firestorage; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE tank_firestorage (
)
INHERITS (value_list_base);


ALTER TABLE tank_firestorage OWNER TO postgres;

--
-- Name: watertype; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE watertype (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE watertype OWNER TO postgres;

--
-- Name: TABLE watertype; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE watertype IS 'Water type table, with SIRE code.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_installation; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_installation AS
 SELECT vw_element_installation.id,
    vw_element_installation.fk_district,
    vw_element_installation.fk_pressurezone,
    vw_element_installation.fk_printmap,
    vw_element_installation._printmaps,
    vw_element_installation._geometry_alt1_used,
    vw_element_installation._geometry_alt2_used,
    vw_element_installation._pipe_node_type,
    vw_element_installation._pipe_orientation,
    vw_element_installation._pipe_schema_visible,
    vw_element_installation.geometry,
    vw_element_installation.geometry_alt1,
    vw_element_installation.geometry_alt2,
    vw_element_installation.update_geometry_alt1,
    vw_element_installation.update_geometry_alt2,
    vw_element_installation.identification,
    vw_element_installation.fk_distributor,
    vw_element_installation.fk_status,
    vw_element_installation.fk_folder,
    vw_element_installation.fk_locationtype,
    vw_element_installation.fk_precision,
    vw_element_installation.fk_precisionalti,
    vw_element_installation.fk_object_reference,
    vw_element_installation.altitude,
    vw_element_installation.year,
    vw_element_installation.year_end,
    vw_element_installation.orientation,
    vw_element_installation.remark,
    vw_element_installation.schema_force_visible,
    vw_element_installation.label_1_visible,
    vw_element_installation.label_1_x,
    vw_element_installation.label_1_y,
    vw_element_installation.label_1_rotation,
    vw_element_installation.label_1_text,
    vw_element_installation.label_2_visible,
    vw_element_installation.label_2_x,
    vw_element_installation.label_2_y,
    vw_element_installation.label_2_rotation,
    vw_element_installation.label_2_text,
    vw_element_installation.installation_type,
    vw_element_installation.name,
    vw_element_installation.fk_parent,
    vw_element_installation.fk_remote,
    vw_element_installation.fk_watertype,
    vw_element_installation.parcel,
    vw_element_installation.eca,
    vw_element_installation.open_water_surface,
    vw_element_installation.geometry_polygon,
    vw_element_installation.fk_source_type,
    vw_element_installation.fk_source_quality,
    vw_element_installation.flow_lowest,
    vw_element_installation.flow_average,
    vw_element_installation.flow_concession,
    vw_element_installation.contract_end,
    vw_element_installation.gathering_chamber,
    vw_element_installation.fk_pump_type,
    vw_element_installation.fk_pipe_in,
    vw_element_installation.fk_pipe_out,
    vw_element_installation.fk_pump_operating,
    vw_element_installation.no_pumps,
    vw_element_installation.rejected_flow,
    vw_element_installation.manometric_height,
    vw_element_installation.fk_overflow,
    vw_element_installation.fk_tank_firestorage,
    vw_element_installation.storage_total,
    vw_element_installation.storage_supply,
    vw_element_installation.storage_fire,
    vw_element_installation.altitude_overflow,
    vw_element_installation.altitude_apron,
    vw_element_installation.height_max,
    vw_element_installation.fire_valve,
    vw_element_installation.fire_remote,
    vw_element_installation._litrepercm,
    vw_element_installation.cistern1_fk_type,
    vw_element_installation.cistern1_dimension_1,
    vw_element_installation.cistern1_dimension_2,
    vw_element_installation.cistern1_storage,
    vw_element_installation._cistern1_litrepercm,
    vw_element_installation.cistern2_fk_type,
    vw_element_installation.cistern2_dimension_1,
    vw_element_installation.cistern2_dimension_2,
    vw_element_installation.cistern2_storage,
    vw_element_installation._cistern2_litrepercm,
    vw_element_installation.sanitization_uv,
    vw_element_installation.sanitization_chlorine_liquid,
    vw_element_installation.sanitization_chlorine_gazeous,
    vw_element_installation.sanitization_ozone,
    vw_element_installation.filtration_membrane,
    vw_element_installation.filtration_sandorgravel,
    vw_element_installation.flocculation,
    vw_element_installation.activatedcharcoal,
    vw_element_installation.settling,
    vw_element_installation.treatment_capacity,
    vw_element_installation.networkseparation,
    vw_element_installation.flow_meter,
    vw_element_installation.water_meter,
    vw_element_installation.manometer,
    vw_element_installation.depth,
    vw_element_installation.no_valves,
    vw_element_installation.fk_pressurecontrol_type,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    watertype.vl_active AS watertype_vl_active,
    watertype.short_fr AS watertype_short_fr,
    watertype.short_en AS watertype_short_en,
    watertype.short_ro AS watertype_short_ro,
    watertype.value_fr AS watertype_value_fr,
    watertype.value_en AS watertype_value_en,
    watertype.value_ro AS watertype_value_ro,
    watertype.description_fr AS watertype_description_fr,
    watertype.description_en AS watertype_description_en,
    watertype.description_ro AS watertype_description_ro,
    watertype.code_sire AS watertype_code_sire,
    pump_type.vl_active AS pump_type_vl_active,
    pump_type.short_fr AS pump_type_short_fr,
    pump_type.short_en AS pump_type_short_en,
    pump_type.short_ro AS pump_type_short_ro,
    pump_type.value_fr AS pump_type_value_fr,
    pump_type.value_en AS pump_type_value_en,
    pump_type.value_ro AS pump_type_value_ro,
    pump_type.description_fr AS pump_type_description_fr,
    pump_type.description_en AS pump_type_description_en,
    pump_type.description_ro AS pump_type_description_ro,
    pump_type.code_sire AS pump_type_code_sire,
    object_reference.vl_active AS object_reference_vl_active,
    object_reference.short_fr AS object_reference_short_fr,
    object_reference.short_en AS object_reference_short_en,
    object_reference.short_ro AS object_reference_short_ro,
    object_reference.value_fr AS object_reference_value_fr,
    object_reference.value_en AS object_reference_value_en,
    object_reference.value_ro AS object_reference_value_ro,
    object_reference.description_fr AS object_reference_description_fr,
    object_reference.description_en AS object_reference_description_en,
    object_reference.description_ro AS object_reference_description_ro,
    cistern2.vl_active AS cistern2_vl_active,
    cistern2.short_fr AS cistern2_short_fr,
    cistern2.short_en AS cistern2_short_en,
    cistern2.short_ro AS cistern2_short_ro,
    cistern2.value_fr AS cistern2_value_fr,
    cistern2.value_en AS cistern2_value_en,
    cistern2.value_ro AS cistern2_value_ro,
    cistern2.description_fr AS cistern2_description_fr,
    cistern2.description_en AS cistern2_description_en,
    cistern2.description_ro AS cistern2_description_ro,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    tank_firestorage.vl_active AS tank_firestorage_vl_active,
    tank_firestorage.short_fr AS tank_firestorage_short_fr,
    tank_firestorage.short_en AS tank_firestorage_short_en,
    tank_firestorage.short_ro AS tank_firestorage_short_ro,
    tank_firestorage.value_fr AS tank_firestorage_value_fr,
    tank_firestorage.value_en AS tank_firestorage_value_en,
    tank_firestorage.value_ro AS tank_firestorage_value_ro,
    tank_firestorage.description_fr AS tank_firestorage_description_fr,
    tank_firestorage.description_en AS tank_firestorage_description_en,
    tank_firestorage.description_ro AS tank_firestorage_description_ro,
    cistern1.vl_active AS cistern1_vl_active,
    cistern1.short_fr AS cistern1_short_fr,
    cistern1.short_en AS cistern1_short_en,
    cistern1.short_ro AS cistern1_short_ro,
    cistern1.value_fr AS cistern1_value_fr,
    cistern1.value_en AS cistern1_value_en,
    cistern1.value_ro AS cistern1_value_ro,
    cistern1.description_fr AS cistern1_description_fr,
    cistern1.description_en AS cistern1_description_en,
    cistern1.description_ro AS cistern1_description_ro,
    source_type.vl_active AS source_type_vl_active,
    source_type.short_fr AS source_type_short_fr,
    source_type.short_en AS source_type_short_en,
    source_type.short_ro AS source_type_short_ro,
    source_type.value_fr AS source_type_value_fr,
    source_type.value_en AS source_type_value_en,
    source_type.value_ro AS source_type_value_ro,
    source_type.description_fr AS source_type_description_fr,
    source_type.description_en AS source_type_description_en,
    source_type.description_ro AS source_type_description_ro,
    source_type.code_sire AS source_type_code_sire,
    source_quality.vl_active AS source_quality_vl_active,
    source_quality.short_fr AS source_quality_short_fr,
    source_quality.short_en AS source_quality_short_en,
    source_quality.short_ro AS source_quality_short_ro,
    source_quality.value_fr AS source_quality_value_fr,
    source_quality.value_en AS source_quality_value_en,
    source_quality.value_ro AS source_quality_value_ro,
    source_quality.description_fr AS source_quality_description_fr,
    source_quality.description_en AS source_quality_description_en,
    source_quality.description_ro AS source_quality_description_ro,
    source_quality.code_sire AS source_quality_code_sire,
    distributor.name AS distributor_name,
    overflow.vl_active AS overflow_vl_active,
    overflow.short_fr AS overflow_short_fr,
    overflow.short_en AS overflow_short_en,
    overflow.short_ro AS overflow_short_ro,
    overflow.value_fr AS overflow_value_fr,
    overflow.value_en AS overflow_value_en,
    overflow.value_ro AS overflow_value_ro,
    overflow.description_fr AS overflow_description_fr,
    overflow.description_en AS overflow_description_en,
    overflow.description_ro AS overflow_description_ro,
    pressurecontrol_type.vl_active AS pressurecontrol_type_vl_active,
    pressurecontrol_type.short_fr AS pressurecontrol_type_short_fr,
    pressurecontrol_type.short_en AS pressurecontrol_type_short_en,
    pressurecontrol_type.short_ro AS pressurecontrol_type_short_ro,
    pressurecontrol_type.value_fr AS pressurecontrol_type_value_fr,
    pressurecontrol_type.value_en AS pressurecontrol_type_value_en,
    pressurecontrol_type.value_ro AS pressurecontrol_type_value_ro,
    pressurecontrol_type.description_fr AS pressurecontrol_type_description_fr,
    pressurecontrol_type.description_en AS pressurecontrol_type_description_en,
    pressurecontrol_type.description_ro AS pressurecontrol_type_description_ro,
    remote.vl_active AS remote_vl_active,
    remote.short_fr AS remote_short_fr,
    remote.short_en AS remote_short_en,
    remote.short_ro AS remote_short_ro,
    remote.value_fr AS remote_value_fr,
    remote.value_en AS remote_value_en,
    remote.value_ro AS remote_value_ro,
    remote.description_fr AS remote_description_fr,
    remote.description_en AS remote_description_en,
    remote.description_ro AS remote_description_ro,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    precisionalti.vl_active AS precisionalti_vl_active,
    precisionalti.short_fr AS precisionalti_short_fr,
    precisionalti.short_en AS precisionalti_short_en,
    precisionalti.short_ro AS precisionalti_short_ro,
    precisionalti.value_fr AS precisionalti_value_fr,
    precisionalti.value_en AS precisionalti_value_en,
    precisionalti.value_ro AS precisionalti_value_ro,
    precisionalti.description_fr AS precisionalti_description_fr,
    precisionalti.description_en AS precisionalti_description_en,
    precisionalti.description_ro AS precisionalti_description_ro,
    precisionalti.code_sire AS precisionalti_code_sire,
    pump_operating.vl_active AS pump_operating_vl_active,
    pump_operating.short_fr AS pump_operating_short_fr,
    pump_operating.short_en AS pump_operating_short_en,
    pump_operating.short_ro AS pump_operating_short_ro,
    pump_operating.value_fr AS pump_operating_value_fr,
    pump_operating.value_en AS pump_operating_value_en,
    pump_operating.value_ro AS pump_operating_value_ro,
    pump_operating.description_fr AS pump_operating_description_fr,
    pump_operating.description_en AS pump_operating_description_en,
    pump_operating.description_ro AS pump_operating_description_ro,
    pump_operating.code_sire AS pump_operating_code_sire
   FROM (((((((((((((((((((vw_element_installation
     LEFT JOIN qwat_vl.status status ON ((vw_element_installation.fk_status = status.id)))
     LEFT JOIN qwat_vl.watertype watertype ON ((vw_element_installation.fk_watertype = watertype.id)))
     LEFT JOIN qwat_vl.pump_type pump_type ON ((vw_element_installation.fk_pump_type = pump_type.id)))
     LEFT JOIN qwat_vl.object_reference object_reference ON ((vw_element_installation.fk_object_reference = object_reference.id)))
     LEFT JOIN qwat_vl.cistern cistern2 ON ((vw_element_installation.cistern2_fk_type = cistern2.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((vw_element_installation.fk_precision = "precision".id)))
     LEFT JOIN qwat_vl.tank_firestorage tank_firestorage ON ((vw_element_installation.fk_tank_firestorage = tank_firestorage.id)))
     LEFT JOIN qwat_vl.cistern cistern1 ON ((vw_element_installation.cistern1_fk_type = cistern1.id)))
     LEFT JOIN qwat_vl.source_type source_type ON ((vw_element_installation.fk_source_type = source_type.id)))
     LEFT JOIN qwat_vl.source_quality source_quality ON ((vw_element_installation.fk_source_quality = source_quality.id)))
     LEFT JOIN distributor distributor ON ((vw_element_installation.fk_distributor = distributor.id)))
     LEFT JOIN qwat_vl.overflow overflow ON ((vw_element_installation.fk_overflow = overflow.id)))
     LEFT JOIN qwat_vl.pressurecontrol_type pressurecontrol_type ON ((vw_element_installation.fk_pressurecontrol_type = pressurecontrol_type.id)))
     LEFT JOIN qwat_vl.remote_type remote ON ((vw_element_installation.fk_remote = remote.id)))
     LEFT JOIN district district ON ((vw_element_installation.fk_district = district.id)))
     LEFT JOIN pressurezone pressurezone ON ((vw_element_installation.fk_pressurezone = pressurezone.id)))
     LEFT JOIN folder folder ON ((vw_element_installation.fk_folder = folder.id)))
     LEFT JOIN qwat_vl.precisionalti precisionalti ON ((vw_element_installation.fk_precisionalti = precisionalti.id)))
     LEFT JOIN qwat_vl.pump_operating pump_operating ON ((vw_element_installation.fk_pump_operating = pump_operating.id)));


ALTER TABLE vw_export_installation OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: pipe_function; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pipe_function (
    schema_visible boolean DEFAULT true NOT NULL,
    major boolean DEFAULT true NOT NULL,
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE pipe_function OWNER TO postgres;

--
-- Name: TABLE pipe_function; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE pipe_function IS 'Function for pipe. Here is determined if pipe should be visible or not in the schematic view, but this can be overidden by the pipe attribute schema_force_visible.';


--
-- Name: pipe_installmethod; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pipe_installmethod (
)
INHERITS (value_list_base);


ALTER TABLE pipe_installmethod OWNER TO postgres;

--
-- Name: TABLE pipe_installmethod; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE pipe_installmethod IS 'Installation methods.';


--
-- Name: pipe_material; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pipe_material (
    _displayname_fr character varying(30),
    _displayname_en character varying(30),
    _displayname_ro character varying(30),
    diameter character varying(10),
    diameter_nominal smallint,
    diameter_internal numeric(7,3),
    diameter_external numeric(7,3),
    code_sire smallint,
    pressure_nominal double precision,
    sdr double precision,
    wall_thickness numeric(4,1),
    sn integer
)
INHERITS (value_list_base);


ALTER TABLE pipe_material OWNER TO postgres;

--
-- Name: TABLE pipe_material; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE pipe_material IS 'List of materials for pipe. All the possible combinations material/diameter are listed in this table. _displayname_fr, _displayname_ro and _displayname_en are automatically generated by rules on insert and update. They are meant to be used in QGIS for the combo box of pipe.fk_material.

Remark: The pipe industry maintains two different ways to refer to the dimension of a pipe:
- Nominal Diameter (DN) which is commonly used for steel/iron pipes but also for GRP.
- Exterior Diameter or Outer Diameter(OD) is taken into consideration when referring to the plastic pipes (PE, PVC).

The DN is a number that represents the approximate interior diameter, in mm. The value represents only an approximation of the pipe diameter so that engineers use a nice round number; the actual value is usually off by a few mm.
So, when referring simply to the diameter, it is assumed that for plastic pipes you''re referring to the outer one, and for iron/steel and GRP ones to the approximate interior one - Nominal Diameter (DN).

PE80 and PE100 are both types of polyethylene that are used for water pipes (PE32, PE40 and PE63 also exist).

Pipes made from PE100 are mechanically stronger (and gives a greater pressure rating than PE80 for the same SDR).  Materials that are used in the production of polyethylene pipes are classified by MRS. Minimum Required Strenght (MRS) is the value of durability that the material has against internal pressure under 20 degrees C for 50 years in MPa.

Material  | MRS (MPa)
--------------------------
PE 100    |   10
--------------------------
PE 80      |   8
--------------------------

Standard dimension ratio (SDR) is a method of rating a pipe''s durability against pressure.
The standard dimension ratio describes the correlation between the pipe dimension and the thickness of the pipe wall.
SDR = external diameter (mm) / wall thickness (mm).
Pipes with a lower SDR can withstand higher pressure.
Common nominations are SDR11 and SDR17.

The GRP pipes materials values were taken from producer HOBAS standards.

Added only GRP values for SN 10000. TODO rest if relevant';


--
-- Name: COLUMN pipe_material.diameter; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON COLUMN pipe_material.diameter IS 'Represents the usual name of the pipe diameter (how you call it).
Commonly, it should be equivalent to:
- the external diameter for plastic pipe
- the nominal diameter for iron/steel and GRP';


--
-- Name: COLUMN pipe_material.diameter_nominal; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON COLUMN pipe_material.diameter_nominal IS 'The nominal diameter (DN) is a number that represents the approximate interior diameter, in mm.
It''s commonly used when referring steel/iron pipes but also for GRP.';


--
-- Name: COLUMN pipe_material.diameter_external; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON COLUMN pipe_material.diameter_external IS 'Commonly used when referring to plastic pipes.';


--
-- Name: COLUMN pipe_material.pressure_nominal; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON COLUMN pipe_material.pressure_nominal IS 'nominal pressure in bars';


--
-- Name: COLUMN pipe_material.sn; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON COLUMN pipe_material.sn IS 'Refers to the SN Nominal Stiffness in N/m² and it''s specific to GRP pipes.

The greater a pipe’s wall thickness, the greater is its stiffness and therefore its ability to resist external bending loads or low internal pressure.
From a mechanical point of view, it has proved useful to classify GRP pipes according to their stiffness – as opposed to wall thickness.

SN 2500 - These pipes are suitable for buried installation, but are mainly used for relining.

SN 5000 - Pipes of this stiffness are selected for minor loads, for example when installed in mixed soil at a depth of 3 m and a live load corresponding to a 60 t truck.

SN 10000 - These pipes are designed for high loads, for example for installation in mixed soil at a depth of 4 m or a live load corresponding to a 60 t truck with little soil cover.';


--
-- Name: pipe_protection; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE pipe_protection (
)
INHERITS (value_list_base);


ALTER TABLE pipe_protection OWNER TO postgres;

--
-- Name: TABLE pipe_protection; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE pipe_protection IS 'Pipe protection details.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_pipe; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_pipe AS
 SELECT pipe.id,
    pipe.fk_parent,
    pipe.fk_function,
    pipe.fk_installmethod,
    pipe.fk_material,
    pipe.fk_distributor,
    pipe.fk_precision,
    pipe.fk_bedding,
    pipe.fk_protection,
    pipe.fk_status,
    pipe.fk_watertype,
    pipe.fk_locationtype,
    pipe.fk_folder,
    pipe.year,
    pipe.year_rehabilitation,
    pipe.year_end,
    pipe.tunnel_or_bridge,
    pipe.pressure_nominal,
    pipe.remark,
    pipe._valve_count,
    pipe._valve_closed,
    pipe.schema_force_visible,
    pipe.label_1_visible,
    pipe.label_1_text,
    pipe.label_2_visible,
    pipe.label_2_text,
    pipe.fk_node_a,
    pipe.fk_node_b,
    pipe.fk_district,
    pipe.fk_pressurezone,
    pipe.fk_printmap,
    pipe._length2d,
    pipe._length3d,
    pipe._diff_elevation,
    pipe._printmaps,
    pipe._geometry_alt1_used,
    pipe._geometry_alt2_used,
    pipe.update_geometry_alt1,
    pipe.update_geometry_alt2,
    pipe.geometry,
    pipe.geometry_alt1,
    pipe.geometry_alt2,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    function.vl_active AS function_vl_active,
    function.short_fr AS function_short_fr,
    function.short_en AS function_short_en,
    function.short_ro AS function_short_ro,
    function.value_fr AS function_value_fr,
    function.value_en AS function_value_en,
    function.value_ro AS function_value_ro,
    function.description_fr AS function_description_fr,
    function.description_en AS function_description_en,
    function.description_ro AS function_description_ro,
    function.schema_visible AS function_schema_visible,
    function.major AS function_major,
    function.code_sire AS function_code_sire,
    installmethod.vl_active AS installmethod_vl_active,
    installmethod.short_fr AS installmethod_short_fr,
    installmethod.short_en AS installmethod_short_en,
    installmethod.short_ro AS installmethod_short_ro,
    installmethod.value_fr AS installmethod_value_fr,
    installmethod.value_en AS installmethod_value_en,
    installmethod.value_ro AS installmethod_value_ro,
    installmethod.description_fr AS installmethod_description_fr,
    installmethod.description_en AS installmethod_description_en,
    installmethod.description_ro AS installmethod_description_ro,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    material.vl_active AS material_vl_active,
    material.short_fr AS material_short_fr,
    material.short_en AS material_short_en,
    material.short_ro AS material_short_ro,
    material.value_fr AS material_value_fr,
    material.value_en AS material_value_en,
    material.value_ro AS material_value_ro,
    material.description_fr AS material_description_fr,
    material.description_en AS material_description_en,
    material.description_ro AS material_description_ro,
    material._displayname_fr AS material__displayname_fr,
    material._displayname_en AS material__displayname_en,
    material._displayname_ro AS material__displayname_ro,
    material.diameter AS material_diameter,
    material.diameter_nominal AS material_diameter_nominal,
    material.diameter_internal AS material_diameter_internal,
    material.diameter_external AS material_diameter_external,
    material.code_sire AS material_code_sire,
    material.pressure_nominal AS material_pressure_nominal,
    material.sdr AS material_sdr,
    material.wall_thickness AS material_wall_thickness,
    material.sn AS material_sn,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    protection.vl_active AS protection_vl_active,
    protection.short_fr AS protection_short_fr,
    protection.short_en AS protection_short_en,
    protection.short_ro AS protection_short_ro,
    protection.value_fr AS protection_value_fr,
    protection.value_en AS protection_value_en,
    protection.value_ro AS protection_value_ro,
    protection.description_fr AS protection_description_fr,
    protection.description_en AS protection_description_en,
    protection.description_ro AS protection_description_ro,
    distributor.name AS distributor_name,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    node_b.fk_district AS node_b_fk_district,
    node_b.fk_pressurezone AS node_b_fk_pressurezone,
    node_b.fk_printmap AS node_b_fk_printmap,
    node_b._printmaps AS node_b__printmaps,
    node_b._geometry_alt1_used AS node_b__geometry_alt1_used,
    node_b._geometry_alt2_used AS node_b__geometry_alt2_used,
    node_b._pipe_node_type AS node_b__pipe_node_type,
    node_b._pipe_orientation AS node_b__pipe_orientation,
    node_b._pipe_schema_visible AS node_b__pipe_schema_visible,
    node_b.geometry AS node_b_geometry,
    node_b.geometry_alt1 AS node_b_geometry_alt1,
    node_b.geometry_alt2 AS node_b_geometry_alt2,
    node_b.update_geometry_alt1 AS node_b_update_geometry_alt1,
    node_b.update_geometry_alt2 AS node_b_update_geometry_alt2,
    node_a.fk_district AS node_a_fk_district,
    node_a.fk_pressurezone AS node_a_fk_pressurezone,
    node_a.fk_printmap AS node_a_fk_printmap,
    node_a._printmaps AS node_a__printmaps,
    node_a._geometry_alt1_used AS node_a__geometry_alt1_used,
    node_a._geometry_alt2_used AS node_a__geometry_alt2_used,
    node_a._pipe_node_type AS node_a__pipe_node_type,
    node_a._pipe_orientation AS node_a__pipe_orientation,
    node_a._pipe_schema_visible AS node_a__pipe_schema_visible,
    node_a.geometry AS node_a_geometry,
    node_a.geometry_alt1 AS node_a_geometry_alt1,
    node_a.geometry_alt2 AS node_a_geometry_alt2,
    node_a.update_geometry_alt1 AS node_a_update_geometry_alt1,
    node_a.update_geometry_alt2 AS node_a_update_geometry_alt2
   FROM ((((((((((((pipe
     LEFT JOIN qwat_vl.status status ON ((pipe.fk_status = status.id)))
     LEFT JOIN qwat_vl.pipe_function function ON ((pipe.fk_function = function.id)))
     LEFT JOIN qwat_vl.pipe_installmethod installmethod ON ((pipe.fk_installmethod = installmethod.id)))
     LEFT JOIN district district ON ((pipe.fk_district = district.id)))
     LEFT JOIN pressurezone pressurezone ON ((pipe.fk_pressurezone = pressurezone.id)))
     LEFT JOIN qwat_vl.pipe_material material ON ((pipe.fk_material = material.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((pipe.fk_precision = "precision".id)))
     LEFT JOIN qwat_vl.pipe_protection protection ON ((pipe.fk_protection = protection.id)))
     LEFT JOIN distributor distributor ON ((pipe.fk_distributor = distributor.id)))
     LEFT JOIN folder folder ON ((pipe.fk_folder = folder.id)))
     LEFT JOIN node node_b ON ((pipe.fk_node_b = node_b.id)))
     LEFT JOIN node node_a ON ((pipe.fk_node_a = node_a.id)));


ALTER TABLE vw_export_pipe OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: leak_cause; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE leak_cause (
)
INHERITS (value_list_base);


ALTER TABLE leak_cause OWNER TO postgres;

--
-- Name: TABLE leak_cause; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE leak_cause IS 'Causes of leak';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_leak; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_leak AS
 SELECT leak.id,
    leak.fk_cause,
    leak.fk_pipe,
    leak.widespread_damage,
    leak.detection_date,
    leak.repair_date,
    leak._repaired,
    leak.address,
    leak.pipe_replaced,
    leak.description,
    leak.repair,
    leak.geometry,
    leak.label_1_visible,
    leak.label_1_x,
    leak.label_1_y,
    leak.label_1_rotation,
    leak.label_1_text,
    leak.label_2_visible,
    leak.label_2_x,
    leak.label_2_y,
    leak.label_2_rotation,
    leak.label_2_text,
    pipe.fk_parent AS pipe_fk_parent,
    pipe.fk_function AS pipe_fk_function,
    pipe.fk_installmethod AS pipe_fk_installmethod,
    pipe.fk_material AS pipe_fk_material,
    pipe.fk_distributor AS pipe_fk_distributor,
    pipe.fk_precision AS pipe_fk_precision,
    pipe.fk_bedding AS pipe_fk_bedding,
    pipe.fk_protection AS pipe_fk_protection,
    pipe.fk_status AS pipe_fk_status,
    pipe.fk_watertype AS pipe_fk_watertype,
    pipe.fk_locationtype AS pipe_fk_locationtype,
    pipe.fk_folder AS pipe_fk_folder,
    pipe.year AS pipe_year,
    pipe.year_rehabilitation AS pipe_year_rehabilitation,
    pipe.year_end AS pipe_year_end,
    pipe.tunnel_or_bridge AS pipe_tunnel_or_bridge,
    pipe.pressure_nominal AS pipe_pressure_nominal,
    pipe.remark AS pipe_remark,
    pipe._valve_count AS pipe__valve_count,
    pipe._valve_closed AS pipe__valve_closed,
    pipe.schema_force_visible AS pipe_schema_force_visible,
    pipe.label_1_visible AS pipe_label_1_visible,
    pipe.label_1_text AS pipe_label_1_text,
    pipe.label_2_visible AS pipe_label_2_visible,
    pipe.label_2_text AS pipe_label_2_text,
    pipe.fk_node_a AS pipe_fk_node_a,
    pipe.fk_node_b AS pipe_fk_node_b,
    pipe.fk_district AS pipe_fk_district,
    pipe.fk_pressurezone AS pipe_fk_pressurezone,
    pipe.fk_printmap AS pipe_fk_printmap,
    pipe._length2d AS pipe__length2d,
    pipe._length3d AS pipe__length3d,
    pipe._diff_elevation AS pipe__diff_elevation,
    pipe._printmaps AS pipe__printmaps,
    pipe._geometry_alt1_used AS pipe__geometry_alt1_used,
    pipe._geometry_alt2_used AS pipe__geometry_alt2_used,
    pipe.update_geometry_alt1 AS pipe_update_geometry_alt1,
    pipe.update_geometry_alt2 AS pipe_update_geometry_alt2,
    pipe.geometry AS pipe_geometry,
    pipe.geometry_alt1 AS pipe_geometry_alt1,
    pipe.geometry_alt2 AS pipe_geometry_alt2,
    pipe.status_vl_active AS pipe_status_vl_active,
    pipe.status_short_fr AS pipe_status_short_fr,
    pipe.status_short_en AS pipe_status_short_en,
    pipe.status_short_ro AS pipe_status_short_ro,
    pipe.status_value_fr AS pipe_status_value_fr,
    pipe.status_value_en AS pipe_status_value_en,
    pipe.status_value_ro AS pipe_status_value_ro,
    pipe.status_description_fr AS pipe_status_description_fr,
    pipe.status_description_en AS pipe_status_description_en,
    pipe.status_description_ro AS pipe_status_description_ro,
    pipe.status_active AS pipe_status_active,
    pipe.status_code_sire AS pipe_status_code_sire,
    pipe.function_vl_active AS pipe_function_vl_active,
    pipe.function_short_fr AS pipe_function_short_fr,
    pipe.function_short_en AS pipe_function_short_en,
    pipe.function_short_ro AS pipe_function_short_ro,
    pipe.function_value_fr AS pipe_function_value_fr,
    pipe.function_value_en AS pipe_function_value_en,
    pipe.function_value_ro AS pipe_function_value_ro,
    pipe.function_description_fr AS pipe_function_description_fr,
    pipe.function_description_en AS pipe_function_description_en,
    pipe.function_description_ro AS pipe_function_description_ro,
    pipe.function_schema_visible AS pipe_function_schema_visible,
    pipe.function_major AS pipe_function_major,
    pipe.function_code_sire AS pipe_function_code_sire,
    pipe.installmethod_vl_active AS pipe_installmethod_vl_active,
    pipe.installmethod_short_fr AS pipe_installmethod_short_fr,
    pipe.installmethod_short_en AS pipe_installmethod_short_en,
    pipe.installmethod_short_ro AS pipe_installmethod_short_ro,
    pipe.installmethod_value_fr AS pipe_installmethod_value_fr,
    pipe.installmethod_value_en AS pipe_installmethod_value_en,
    pipe.installmethod_value_ro AS pipe_installmethod_value_ro,
    pipe.installmethod_description_fr AS pipe_installmethod_description_fr,
    pipe.installmethod_description_en AS pipe_installmethod_description_en,
    pipe.installmethod_description_ro AS pipe_installmethod_description_ro,
    pipe.district_name AS pipe_district_name,
    pipe.district_shortname AS pipe_district_shortname,
    pipe.district_zip AS pipe_district_zip,
    pipe.district_land_registry AS pipe_district_land_registry,
    pipe.district_prefix AS pipe_district_prefix,
    pipe.district_colorcode AS pipe_district_colorcode,
    pipe.district_geometry AS pipe_district_geometry,
    pipe.district_label_1_visible AS pipe_district_label_1_visible,
    pipe.district_label_1_x AS pipe_district_label_1_x,
    pipe.district_label_1_y AS pipe_district_label_1_y,
    pipe.district_label_1_rotation AS pipe_district_label_1_rotation,
    pipe.district_label_1_text AS pipe_district_label_1_text,
    pipe.district_label_2_visible AS pipe_district_label_2_visible,
    pipe.district_label_2_x AS pipe_district_label_2_x,
    pipe.district_label_2_y AS pipe_district_label_2_y,
    pipe.district_label_2_rotation AS pipe_district_label_2_rotation,
    pipe.district_label_2_text AS pipe_district_label_2_text,
    pipe.pressurezone_fk_distributor AS pipe_pressurezone_fk_distributor,
    pipe.pressurezone_fk_consumptionzone AS pipe_pressurezone_fk_consumptionzone,
    pipe.pressurezone_name AS pipe_pressurezone_name,
    pipe.pressurezone_population AS pipe_pressurezone_population,
    pipe.pressurezone_subscriber AS pipe_pressurezone_subscriber,
    pipe.pressurezone_colorcode AS pipe_pressurezone_colorcode,
    pipe.pressurezone_geometry AS pipe_pressurezone_geometry,
    pipe.pressurezone_geometry_alt1 AS pipe_pressurezone_geometry_alt1,
    pipe.pressurezone_geometry_alt2 AS pipe_pressurezone_geometry_alt2,
    pipe.pressurezone__geometry_alt1_used AS pipe_pressurezone__geometry_alt1_used,
    pipe.pressurezone__geometry_alt2_used AS pipe_pressurezone__geometry_alt2_used,
    pipe.pressurezone_update_geometry_alt1 AS pipe_pressurezone_update_geometry_alt1,
    pipe.pressurezone_update_geometry_alt2 AS pipe_pressurezone_update_geometry_alt2,
    pipe.pressurezone_label_1_visible AS pipe_pressurezone_label_1_visible,
    pipe.pressurezone_label_1_x AS pipe_pressurezone_label_1_x,
    pipe.pressurezone_label_1_y AS pipe_pressurezone_label_1_y,
    pipe.pressurezone_label_1_rotation AS pipe_pressurezone_label_1_rotation,
    pipe.pressurezone_label_1_text AS pipe_pressurezone_label_1_text,
    pipe.pressurezone_label_2_visible AS pipe_pressurezone_label_2_visible,
    pipe.pressurezone_label_2_x AS pipe_pressurezone_label_2_x,
    pipe.pressurezone_label_2_y AS pipe_pressurezone_label_2_y,
    pipe.pressurezone_label_2_rotation AS pipe_pressurezone_label_2_rotation,
    pipe.pressurezone_label_2_text AS pipe_pressurezone_label_2_text,
    pipe.material_vl_active AS pipe_material_vl_active,
    pipe.material_short_fr AS pipe_material_short_fr,
    pipe.material_short_en AS pipe_material_short_en,
    pipe.material_short_ro AS pipe_material_short_ro,
    pipe.material_value_fr AS pipe_material_value_fr,
    pipe.material_value_en AS pipe_material_value_en,
    pipe.material_value_ro AS pipe_material_value_ro,
    pipe.material_description_fr AS pipe_material_description_fr,
    pipe.material_description_en AS pipe_material_description_en,
    pipe.material_description_ro AS pipe_material_description_ro,
    pipe.material__displayname_fr AS pipe_material__displayname_fr,
    pipe.material__displayname_en AS pipe_material__displayname_en,
    pipe.material__displayname_ro AS pipe_material__displayname_ro,
    pipe.material_diameter AS pipe_material_diameter,
    pipe.material_diameter_nominal AS pipe_material_diameter_nominal,
    pipe.material_diameter_internal AS pipe_material_diameter_internal,
    pipe.material_diameter_external AS pipe_material_diameter_external,
    pipe.material_code_sire AS pipe_material_code_sire,
    pipe.material_pressure_nominal AS pipe_material_pressure_nominal,
    pipe.material_sdr AS pipe_material_sdr,
    pipe.material_wall_thickness AS pipe_material_wall_thickness,
    pipe.material_sn AS pipe_material_sn,
    pipe.precision_vl_active AS pipe_precision_vl_active,
    pipe.precision_short_fr AS pipe_precision_short_fr,
    pipe.precision_short_en AS pipe_precision_short_en,
    pipe.precision_short_ro AS pipe_precision_short_ro,
    pipe.precision_value_fr AS pipe_precision_value_fr,
    pipe.precision_value_en AS pipe_precision_value_en,
    pipe.precision_value_ro AS pipe_precision_value_ro,
    pipe.precision_description_fr AS pipe_precision_description_fr,
    pipe.precision_description_en AS pipe_precision_description_en,
    pipe.precision_description_ro AS pipe_precision_description_ro,
    pipe.precision_code_sire AS pipe_precision_code_sire,
    pipe.protection_vl_active AS pipe_protection_vl_active,
    pipe.protection_short_fr AS pipe_protection_short_fr,
    pipe.protection_short_en AS pipe_protection_short_en,
    pipe.protection_short_ro AS pipe_protection_short_ro,
    pipe.protection_value_fr AS pipe_protection_value_fr,
    pipe.protection_value_en AS pipe_protection_value_en,
    pipe.protection_value_ro AS pipe_protection_value_ro,
    pipe.protection_description_fr AS pipe_protection_description_fr,
    pipe.protection_description_en AS pipe_protection_description_en,
    pipe.protection_description_ro AS pipe_protection_description_ro,
    pipe.distributor_name AS pipe_distributor_name,
    pipe.folder_identification AS pipe_folder_identification,
    pipe.folder_description AS pipe_folder_description,
    pipe.folder_date_start AS pipe_folder_date_start,
    pipe.folder_date_end AS pipe_folder_date_end,
    pipe.folder_geometry_polygon AS pipe_folder_geometry_polygon,
    pipe.folder_geometry_line AS pipe_folder_geometry_line,
    pipe.node_b_fk_district AS pipe_node_b_fk_district,
    pipe.node_b_fk_pressurezone AS pipe_node_b_fk_pressurezone,
    pipe.node_b_fk_printmap AS pipe_node_b_fk_printmap,
    pipe.node_b__printmaps AS pipe_node_b__printmaps,
    pipe.node_b__geometry_alt1_used AS pipe_node_b__geometry_alt1_used,
    pipe.node_b__geometry_alt2_used AS pipe_node_b__geometry_alt2_used,
    pipe.node_b__pipe_node_type AS pipe_node_b__pipe_node_type,
    pipe.node_b__pipe_orientation AS pipe_node_b__pipe_orientation,
    pipe.node_b__pipe_schema_visible AS pipe_node_b__pipe_schema_visible,
    pipe.node_b_geometry AS pipe_node_b_geometry,
    pipe.node_b_geometry_alt1 AS pipe_node_b_geometry_alt1,
    pipe.node_b_geometry_alt2 AS pipe_node_b_geometry_alt2,
    pipe.node_b_update_geometry_alt1 AS pipe_node_b_update_geometry_alt1,
    pipe.node_b_update_geometry_alt2 AS pipe_node_b_update_geometry_alt2,
    pipe.node_a_fk_district AS pipe_node_a_fk_district,
    pipe.node_a_fk_pressurezone AS pipe_node_a_fk_pressurezone,
    pipe.node_a_fk_printmap AS pipe_node_a_fk_printmap,
    pipe.node_a__printmaps AS pipe_node_a__printmaps,
    pipe.node_a__geometry_alt1_used AS pipe_node_a__geometry_alt1_used,
    pipe.node_a__geometry_alt2_used AS pipe_node_a__geometry_alt2_used,
    pipe.node_a__pipe_node_type AS pipe_node_a__pipe_node_type,
    pipe.node_a__pipe_orientation AS pipe_node_a__pipe_orientation,
    pipe.node_a__pipe_schema_visible AS pipe_node_a__pipe_schema_visible,
    pipe.node_a_geometry AS pipe_node_a_geometry,
    pipe.node_a_geometry_alt1 AS pipe_node_a_geometry_alt1,
    pipe.node_a_geometry_alt2 AS pipe_node_a_geometry_alt2,
    pipe.node_a_update_geometry_alt1 AS pipe_node_a_update_geometry_alt1,
    pipe.node_a_update_geometry_alt2 AS pipe_node_a_update_geometry_alt2,
    cause.vl_active AS cause_vl_active,
    cause.short_fr AS cause_short_fr,
    cause.short_en AS cause_short_en,
    cause.short_ro AS cause_short_ro,
    cause.value_fr AS cause_value_fr,
    cause.value_en AS cause_value_en,
    cause.value_ro AS cause_value_ro,
    cause.description_fr AS cause_description_fr,
    cause.description_en AS cause_description_en,
    cause.description_ro AS cause_description_ro
   FROM ((leak
     LEFT JOIN vw_export_pipe pipe ON ((leak.fk_pipe = pipe.id)))
     LEFT JOIN qwat_vl.leak_cause cause ON ((leak.fk_cause = cause.id)));


ALTER TABLE vw_export_leak OWNER TO postgres;

--
-- Name: vw_export_meter; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_meter AS
 SELECT vw_element_meter.id,
    vw_element_meter.fk_district,
    vw_element_meter.fk_pressurezone,
    vw_element_meter.fk_printmap,
    vw_element_meter._printmaps,
    vw_element_meter._geometry_alt1_used,
    vw_element_meter._geometry_alt2_used,
    vw_element_meter._pipe_node_type,
    vw_element_meter._pipe_orientation,
    vw_element_meter._pipe_schema_visible,
    vw_element_meter.geometry,
    vw_element_meter.geometry_alt1,
    vw_element_meter.geometry_alt2,
    vw_element_meter.update_geometry_alt1,
    vw_element_meter.update_geometry_alt2,
    vw_element_meter.identification,
    vw_element_meter.fk_distributor,
    vw_element_meter.fk_status,
    vw_element_meter.fk_folder,
    vw_element_meter.fk_locationtype,
    vw_element_meter.fk_precision,
    vw_element_meter.fk_precisionalti,
    vw_element_meter.fk_object_reference,
    vw_element_meter.altitude,
    vw_element_meter.year,
    vw_element_meter.year_end,
    vw_element_meter.orientation,
    vw_element_meter.remark,
    vw_element_meter.schema_force_visible,
    vw_element_meter.label_1_visible,
    vw_element_meter.label_1_x,
    vw_element_meter.label_1_y,
    vw_element_meter.label_1_rotation,
    vw_element_meter.label_1_text,
    vw_element_meter.label_2_visible,
    vw_element_meter.label_2_x,
    vw_element_meter.label_2_y,
    vw_element_meter.label_2_rotation,
    vw_element_meter.label_2_text,
    vw_element_meter.fk_pipe,
    vw_element_meter.parcel,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    object_reference.vl_active AS object_reference_vl_active,
    object_reference.short_fr AS object_reference_short_fr,
    object_reference.short_en AS object_reference_short_en,
    object_reference.short_ro AS object_reference_short_ro,
    object_reference.value_fr AS object_reference_value_fr,
    object_reference.value_en AS object_reference_value_en,
    object_reference.value_ro AS object_reference_value_ro,
    object_reference.description_fr AS object_reference_description_fr,
    object_reference.description_en AS object_reference_description_en,
    object_reference.description_ro AS object_reference_description_ro,
    distributor.name AS distributor_name,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    precisionalti.vl_active AS precisionalti_vl_active,
    precisionalti.short_fr AS precisionalti_short_fr,
    precisionalti.short_en AS precisionalti_short_en,
    precisionalti.short_ro AS precisionalti_short_ro,
    precisionalti.value_fr AS precisionalti_value_fr,
    precisionalti.value_en AS precisionalti_value_en,
    precisionalti.value_ro AS precisionalti_value_ro,
    precisionalti.description_fr AS precisionalti_description_fr,
    precisionalti.description_en AS precisionalti_description_en,
    precisionalti.description_ro AS precisionalti_description_ro,
    precisionalti.code_sire AS precisionalti_code_sire
   FROM ((((((((vw_element_meter
     LEFT JOIN qwat_vl.status status ON ((vw_element_meter.fk_status = status.id)))
     LEFT JOIN district district ON ((vw_element_meter.fk_pressurezone = district.id)))
     LEFT JOIN pressurezone pressurezone ON ((vw_element_meter.fk_pressurezone = pressurezone.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((vw_element_meter.fk_precision = "precision".id)))
     LEFT JOIN qwat_vl.object_reference object_reference ON ((vw_element_meter.fk_object_reference = object_reference.id)))
     LEFT JOIN distributor distributor ON ((vw_element_meter.fk_distributor = distributor.id)))
     LEFT JOIN folder folder ON ((vw_element_meter.fk_folder = folder.id)))
     LEFT JOIN qwat_vl.precisionalti precisionalti ON ((vw_element_meter.fk_precisionalti = precisionalti.id)));


ALTER TABLE vw_export_meter OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: part_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE part_type (
)
INHERITS (value_list_base);


ALTER TABLE part_type OWNER TO postgres;

--
-- Name: TABLE part_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE part_type IS 'table for installation parts. They are supposed to be on top of nodes and might be used to display a specific symbol.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_part; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_part AS
 SELECT vw_element_part.id,
    vw_element_part.fk_district,
    vw_element_part.fk_pressurezone,
    vw_element_part.fk_printmap,
    vw_element_part._printmaps,
    vw_element_part._geometry_alt1_used,
    vw_element_part._geometry_alt2_used,
    vw_element_part._pipe_node_type,
    vw_element_part._pipe_orientation,
    vw_element_part._pipe_schema_visible,
    vw_element_part.geometry,
    vw_element_part.geometry_alt1,
    vw_element_part.geometry_alt2,
    vw_element_part.update_geometry_alt1,
    vw_element_part.update_geometry_alt2,
    vw_element_part.identification,
    vw_element_part.fk_distributor,
    vw_element_part.fk_status,
    vw_element_part.fk_folder,
    vw_element_part.fk_locationtype,
    vw_element_part.fk_precision,
    vw_element_part.fk_precisionalti,
    vw_element_part.fk_object_reference,
    vw_element_part.altitude,
    vw_element_part.year,
    vw_element_part.year_end,
    vw_element_part.orientation,
    vw_element_part.remark,
    vw_element_part.schema_force_visible,
    vw_element_part.label_1_visible,
    vw_element_part.label_1_x,
    vw_element_part.label_1_y,
    vw_element_part.label_1_rotation,
    vw_element_part.label_1_text,
    vw_element_part.label_2_visible,
    vw_element_part.label_2_x,
    vw_element_part.label_2_y,
    vw_element_part.label_2_rotation,
    vw_element_part.label_2_text,
    vw_element_part.fk_part_type,
    vw_element_part.fk_pipe,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    part_type.vl_active AS part_type_vl_active,
    part_type.short_fr AS part_type_short_fr,
    part_type.short_en AS part_type_short_en,
    part_type.short_ro AS part_type_short_ro,
    part_type.value_fr AS part_type_value_fr,
    part_type.value_en AS part_type_value_en,
    part_type.value_ro AS part_type_value_ro,
    part_type.description_fr AS part_type_description_fr,
    part_type.description_en AS part_type_description_en,
    part_type.description_ro AS part_type_description_ro,
    object_reference.vl_active AS object_reference_vl_active,
    object_reference.short_fr AS object_reference_short_fr,
    object_reference.short_en AS object_reference_short_en,
    object_reference.short_ro AS object_reference_short_ro,
    object_reference.value_fr AS object_reference_value_fr,
    object_reference.value_en AS object_reference_value_en,
    object_reference.value_ro AS object_reference_value_ro,
    object_reference.description_fr AS object_reference_description_fr,
    object_reference.description_en AS object_reference_description_en,
    object_reference.description_ro AS object_reference_description_ro,
    distributor.name AS distributor_name,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    precisionalti.vl_active AS precisionalti_vl_active,
    precisionalti.short_fr AS precisionalti_short_fr,
    precisionalti.short_en AS precisionalti_short_en,
    precisionalti.short_ro AS precisionalti_short_ro,
    precisionalti.value_fr AS precisionalti_value_fr,
    precisionalti.value_en AS precisionalti_value_en,
    precisionalti.value_ro AS precisionalti_value_ro,
    precisionalti.description_fr AS precisionalti_description_fr,
    precisionalti.description_en AS precisionalti_description_en,
    precisionalti.description_ro AS precisionalti_description_ro,
    precisionalti.code_sire AS precisionalti_code_sire
   FROM (((((((((vw_element_part
     LEFT JOIN qwat_vl.status status ON ((vw_element_part.fk_status = status.id)))
     LEFT JOIN district district ON ((vw_element_part.fk_pressurezone = district.id)))
     LEFT JOIN pressurezone pressurezone ON ((vw_element_part.fk_pressurezone = pressurezone.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((vw_element_part.fk_precision = "precision".id)))
     LEFT JOIN qwat_vl.part_type part_type ON ((vw_element_part.fk_part_type = part_type.id)))
     LEFT JOIN qwat_vl.object_reference object_reference ON ((vw_element_part.fk_object_reference = object_reference.id)))
     LEFT JOIN distributor distributor ON ((vw_element_part.fk_distributor = distributor.id)))
     LEFT JOIN folder folder ON ((vw_element_part.fk_folder = folder.id)))
     LEFT JOIN qwat_vl.precisionalti precisionalti ON ((vw_element_part.fk_precisionalti = precisionalti.id)));


ALTER TABLE vw_export_part OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: subscriber_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE subscriber_type (
)
INHERITS (value_list_base);


ALTER TABLE subscriber_type OWNER TO postgres;

--
-- Name: TABLE subscriber_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE subscriber_type IS 'type for subscriber.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_subscriber; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_subscriber AS
 SELECT vw_element_subscriber.id,
    vw_element_subscriber.fk_district,
    vw_element_subscriber.fk_pressurezone,
    vw_element_subscriber.fk_printmap,
    vw_element_subscriber._printmaps,
    vw_element_subscriber._geometry_alt1_used,
    vw_element_subscriber._geometry_alt2_used,
    vw_element_subscriber._pipe_node_type,
    vw_element_subscriber._pipe_orientation,
    vw_element_subscriber._pipe_schema_visible,
    vw_element_subscriber.geometry,
    vw_element_subscriber.geometry_alt1,
    vw_element_subscriber.geometry_alt2,
    vw_element_subscriber.update_geometry_alt1,
    vw_element_subscriber.update_geometry_alt2,
    vw_element_subscriber.identification,
    vw_element_subscriber.fk_distributor,
    vw_element_subscriber.fk_status,
    vw_element_subscriber.fk_folder,
    vw_element_subscriber.fk_locationtype,
    vw_element_subscriber.fk_precision,
    vw_element_subscriber.fk_precisionalti,
    vw_element_subscriber.fk_object_reference,
    vw_element_subscriber.altitude,
    vw_element_subscriber.year,
    vw_element_subscriber.year_end,
    vw_element_subscriber.orientation,
    vw_element_subscriber.remark,
    vw_element_subscriber.schema_force_visible,
    vw_element_subscriber.label_1_visible,
    vw_element_subscriber.label_1_x,
    vw_element_subscriber.label_1_y,
    vw_element_subscriber.label_1_rotation,
    vw_element_subscriber.label_1_text,
    vw_element_subscriber.label_2_visible,
    vw_element_subscriber.label_2_x,
    vw_element_subscriber.label_2_y,
    vw_element_subscriber.label_2_rotation,
    vw_element_subscriber.label_2_text,
    vw_element_subscriber.fk_subscriber_type,
    vw_element_subscriber.fk_pipe,
    vw_element_subscriber.parcel,
    vw_element_subscriber.flow_current,
    vw_element_subscriber.flow_planned,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    subscriber_type.vl_active AS subscriber_type_vl_active,
    subscriber_type.short_fr AS subscriber_type_short_fr,
    subscriber_type.short_en AS subscriber_type_short_en,
    subscriber_type.short_ro AS subscriber_type_short_ro,
    subscriber_type.value_fr AS subscriber_type_value_fr,
    subscriber_type.value_en AS subscriber_type_value_en,
    subscriber_type.value_ro AS subscriber_type_value_ro,
    subscriber_type.description_fr AS subscriber_type_description_fr,
    subscriber_type.description_en AS subscriber_type_description_en,
    subscriber_type.description_ro AS subscriber_type_description_ro,
    object_reference.vl_active AS object_reference_vl_active,
    object_reference.short_fr AS object_reference_short_fr,
    object_reference.short_en AS object_reference_short_en,
    object_reference.short_ro AS object_reference_short_ro,
    object_reference.value_fr AS object_reference_value_fr,
    object_reference.value_en AS object_reference_value_en,
    object_reference.value_ro AS object_reference_value_ro,
    object_reference.description_fr AS object_reference_description_fr,
    object_reference.description_en AS object_reference_description_en,
    object_reference.description_ro AS object_reference_description_ro,
    distributor.name AS distributor_name,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    precisionalti.vl_active AS precisionalti_vl_active,
    precisionalti.short_fr AS precisionalti_short_fr,
    precisionalti.short_en AS precisionalti_short_en,
    precisionalti.short_ro AS precisionalti_short_ro,
    precisionalti.value_fr AS precisionalti_value_fr,
    precisionalti.value_en AS precisionalti_value_en,
    precisionalti.value_ro AS precisionalti_value_ro,
    precisionalti.description_fr AS precisionalti_description_fr,
    precisionalti.description_en AS precisionalti_description_en,
    precisionalti.description_ro AS precisionalti_description_ro,
    precisionalti.code_sire AS precisionalti_code_sire
   FROM (((((((((vw_element_subscriber
     LEFT JOIN qwat_vl.status status ON ((vw_element_subscriber.fk_status = status.id)))
     LEFT JOIN district district ON ((vw_element_subscriber.fk_district = district.id)))
     LEFT JOIN pressurezone pressurezone ON ((vw_element_subscriber.fk_pressurezone = pressurezone.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((vw_element_subscriber.fk_precision = "precision".id)))
     LEFT JOIN qwat_vl.subscriber_type subscriber_type ON ((vw_element_subscriber.fk_subscriber_type = subscriber_type.id)))
     LEFT JOIN qwat_vl.object_reference object_reference ON ((vw_element_subscriber.fk_object_reference = object_reference.id)))
     LEFT JOIN distributor distributor ON ((vw_element_subscriber.fk_distributor = distributor.id)))
     LEFT JOIN folder folder ON ((vw_element_subscriber.fk_folder = folder.id)))
     LEFT JOIN qwat_vl.precisionalti precisionalti ON ((vw_element_subscriber.fk_precisionalti = precisionalti.id)));


ALTER TABLE vw_export_subscriber OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: valve_actuation; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE valve_actuation (
    schema_visible boolean DEFAULT true NOT NULL
)
INHERITS (value_list_base);


ALTER TABLE valve_actuation OWNER TO postgres;

--
-- Name: TABLE valve_actuation; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE valve_actuation IS 'valve actuation/actionnement/acţionare';


--
-- Name: valve_function; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE valve_function (
    schema_visible boolean DEFAULT true NOT NULL
)
INHERITS (value_list_base);


ALTER TABLE valve_function OWNER TO postgres;

--
-- Name: TABLE valve_function; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE valve_function IS 'Functions for valves';


--
-- Name: valve_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE valve_type (
)
INHERITS (value_list_base);


ALTER TABLE valve_type OWNER TO postgres;

--
-- Name: TABLE valve_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE valve_type IS 'Types of valve';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_valve; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_export_valve AS
 SELECT vw_element_valve.id,
    vw_element_valve.fk_district,
    vw_element_valve.fk_pressurezone,
    vw_element_valve.fk_printmap,
    vw_element_valve._printmaps,
    vw_element_valve._geometry_alt1_used,
    vw_element_valve._geometry_alt2_used,
    vw_element_valve._pipe_node_type,
    vw_element_valve._pipe_orientation,
    vw_element_valve._pipe_schema_visible,
    vw_element_valve.geometry,
    vw_element_valve.geometry_alt1,
    vw_element_valve.geometry_alt2,
    vw_element_valve.update_geometry_alt1,
    vw_element_valve.update_geometry_alt2,
    vw_element_valve.identification,
    vw_element_valve.fk_distributor,
    vw_element_valve.fk_status,
    vw_element_valve.fk_folder,
    vw_element_valve.fk_locationtype,
    vw_element_valve.fk_precision,
    vw_element_valve.fk_precisionalti,
    vw_element_valve.fk_object_reference,
    vw_element_valve.altitude,
    vw_element_valve.year,
    vw_element_valve.year_end,
    vw_element_valve.orientation,
    vw_element_valve.remark,
    vw_element_valve.schema_force_visible,
    vw_element_valve.label_1_visible,
    vw_element_valve.label_1_x,
    vw_element_valve.label_1_y,
    vw_element_valve.label_1_rotation,
    vw_element_valve.label_1_text,
    vw_element_valve.label_2_visible,
    vw_element_valve.label_2_x,
    vw_element_valve.label_2_y,
    vw_element_valve.label_2_rotation,
    vw_element_valve.label_2_text,
    vw_element_valve.fk_valve_type,
    vw_element_valve.fk_valve_function,
    vw_element_valve.fk_valve_actuation,
    vw_element_valve.fk_pipe,
    vw_element_valve.fk_handle_precision,
    vw_element_valve.fk_handle_precisionalti,
    vw_element_valve.fk_maintenance,
    vw_element_valve.diameter_nominal,
    vw_element_valve.closed,
    vw_element_valve.networkseparation,
    vw_element_valve.handle_altitude,
    vw_element_valve.handle_geometry,
    status.vl_active AS status_vl_active,
    status.short_fr AS status_short_fr,
    status.short_en AS status_short_en,
    status.short_ro AS status_short_ro,
    status.value_fr AS status_value_fr,
    status.value_en AS status_value_en,
    status.value_ro AS status_value_ro,
    status.description_fr AS status_description_fr,
    status.description_en AS status_description_en,
    status.description_ro AS status_description_ro,
    status.active AS status_active,
    status.code_sire AS status_code_sire,
    district.name AS district_name,
    district.shortname AS district_shortname,
    district.zip AS district_zip,
    district.land_registry AS district_land_registry,
    district.prefix AS district_prefix,
    district.colorcode AS district_colorcode,
    district.geometry AS district_geometry,
    district.label_1_visible AS district_label_1_visible,
    district.label_1_x AS district_label_1_x,
    district.label_1_y AS district_label_1_y,
    district.label_1_rotation AS district_label_1_rotation,
    district.label_1_text AS district_label_1_text,
    district.label_2_visible AS district_label_2_visible,
    district.label_2_x AS district_label_2_x,
    district.label_2_y AS district_label_2_y,
    district.label_2_rotation AS district_label_2_rotation,
    district.label_2_text AS district_label_2_text,
    pressurezone.fk_distributor AS pressurezone_fk_distributor,
    pressurezone.fk_consumptionzone AS pressurezone_fk_consumptionzone,
    pressurezone.name AS pressurezone_name,
    pressurezone.population AS pressurezone_population,
    pressurezone.subscriber AS pressurezone_subscriber,
    pressurezone.colorcode AS pressurezone_colorcode,
    pressurezone.geometry AS pressurezone_geometry,
    pressurezone.geometry_alt1 AS pressurezone_geometry_alt1,
    pressurezone.geometry_alt2 AS pressurezone_geometry_alt2,
    pressurezone._geometry_alt1_used AS pressurezone__geometry_alt1_used,
    pressurezone._geometry_alt2_used AS pressurezone__geometry_alt2_used,
    pressurezone.update_geometry_alt1 AS pressurezone_update_geometry_alt1,
    pressurezone.update_geometry_alt2 AS pressurezone_update_geometry_alt2,
    pressurezone.label_1_visible AS pressurezone_label_1_visible,
    pressurezone.label_1_x AS pressurezone_label_1_x,
    pressurezone.label_1_y AS pressurezone_label_1_y,
    pressurezone.label_1_rotation AS pressurezone_label_1_rotation,
    pressurezone.label_1_text AS pressurezone_label_1_text,
    pressurezone.label_2_visible AS pressurezone_label_2_visible,
    pressurezone.label_2_x AS pressurezone_label_2_x,
    pressurezone.label_2_y AS pressurezone_label_2_y,
    pressurezone.label_2_rotation AS pressurezone_label_2_rotation,
    pressurezone.label_2_text AS pressurezone_label_2_text,
    valve_function.vl_active AS valve_function_vl_active,
    valve_function.short_fr AS valve_function_short_fr,
    valve_function.short_en AS valve_function_short_en,
    valve_function.short_ro AS valve_function_short_ro,
    valve_function.value_fr AS valve_function_value_fr,
    valve_function.value_en AS valve_function_value_en,
    valve_function.value_ro AS valve_function_value_ro,
    valve_function.description_fr AS valve_function_description_fr,
    valve_function.description_en AS valve_function_description_en,
    valve_function.description_ro AS valve_function_description_ro,
    valve_function.schema_visible AS valve_function_schema_visible,
    "precision".vl_active AS precision_vl_active,
    "precision".short_fr AS precision_short_fr,
    "precision".short_en AS precision_short_en,
    "precision".short_ro AS precision_short_ro,
    "precision".value_fr AS precision_value_fr,
    "precision".value_en AS precision_value_en,
    "precision".value_ro AS precision_value_ro,
    "precision".description_fr AS precision_description_fr,
    "precision".description_en AS precision_description_en,
    "precision".description_ro AS precision_description_ro,
    "precision".code_sire AS precision_code_sire,
    distributor.name AS distributor_name,
    valve_type.vl_active AS valve_type_vl_active,
    valve_type.short_fr AS valve_type_short_fr,
    valve_type.short_en AS valve_type_short_en,
    valve_type.short_ro AS valve_type_short_ro,
    valve_type.value_fr AS valve_type_value_fr,
    valve_type.value_en AS valve_type_value_en,
    valve_type.value_ro AS valve_type_value_ro,
    valve_type.description_fr AS valve_type_description_fr,
    valve_type.description_en AS valve_type_description_en,
    valve_type.description_ro AS valve_type_description_ro,
    object_reference.vl_active AS object_reference_vl_active,
    object_reference.short_fr AS object_reference_short_fr,
    object_reference.short_en AS object_reference_short_en,
    object_reference.short_ro AS object_reference_short_ro,
    object_reference.value_fr AS object_reference_value_fr,
    object_reference.value_en AS object_reference_value_en,
    object_reference.value_ro AS object_reference_value_ro,
    object_reference.description_fr AS object_reference_description_fr,
    object_reference.description_en AS object_reference_description_en,
    object_reference.description_ro AS object_reference_description_ro,
    valve_actuation.vl_active AS valve_actuation_vl_active,
    valve_actuation.short_fr AS valve_actuation_short_fr,
    valve_actuation.short_en AS valve_actuation_short_en,
    valve_actuation.short_ro AS valve_actuation_short_ro,
    valve_actuation.value_fr AS valve_actuation_value_fr,
    valve_actuation.value_en AS valve_actuation_value_en,
    valve_actuation.value_ro AS valve_actuation_value_ro,
    valve_actuation.description_fr AS valve_actuation_description_fr,
    valve_actuation.description_en AS valve_actuation_description_en,
    valve_actuation.description_ro AS valve_actuation_description_ro,
    valve_actuation.schema_visible AS valve_actuation_schema_visible,
    folder.identification AS folder_identification,
    folder.description AS folder_description,
    folder.date_start AS folder_date_start,
    folder.date_end AS folder_date_end,
    folder.geometry_polygon AS folder_geometry_polygon,
    folder.geometry_line AS folder_geometry_line,
    precisionalti.vl_active AS precisionalti_vl_active,
    precisionalti.short_fr AS precisionalti_short_fr,
    precisionalti.short_en AS precisionalti_short_en,
    precisionalti.short_ro AS precisionalti_short_ro,
    precisionalti.value_fr AS precisionalti_value_fr,
    precisionalti.value_en AS precisionalti_value_en,
    precisionalti.value_ro AS precisionalti_value_ro,
    precisionalti.description_fr AS precisionalti_description_fr,
    precisionalti.description_en AS precisionalti_description_en,
    precisionalti.description_ro AS precisionalti_description_ro,
    precisionalti.code_sire AS precisionalti_code_sire
   FROM (((((((((((vw_element_valve
     LEFT JOIN qwat_vl.status status ON ((vw_element_valve.fk_status = status.id)))
     LEFT JOIN district district ON ((vw_element_valve.fk_district = district.id)))
     LEFT JOIN pressurezone pressurezone ON ((vw_element_valve.fk_pressurezone = pressurezone.id)))
     LEFT JOIN qwat_vl.valve_function valve_function ON ((vw_element_valve.fk_valve_function = valve_function.id)))
     LEFT JOIN qwat_vl."precision" "precision" ON ((vw_element_valve.fk_precision = "precision".id)))
     LEFT JOIN distributor distributor ON ((vw_element_valve.fk_distributor = distributor.id)))
     LEFT JOIN qwat_vl.valve_type valve_type ON ((vw_element_valve.fk_valve_type = valve_type.id)))
     LEFT JOIN qwat_vl.object_reference object_reference ON ((vw_element_valve.fk_object_reference = object_reference.id)))
     LEFT JOIN qwat_vl.valve_actuation valve_actuation ON ((vw_element_valve.fk_valve_actuation = valve_actuation.id)))
     LEFT JOIN folder folder ON ((vw_element_valve.fk_folder = folder.id)))
     LEFT JOIN qwat_vl.precisionalti precisionalti ON ((vw_element_valve.fk_precisionalti = precisionalti.id)));


ALTER TABLE vw_export_valve OWNER TO postgres;

--
-- Name: vw_installation_chamber; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_installation_chamber AS
 SELECT installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    chamber.networkseparation,
    chamber.flow_meter,
    chamber.water_meter,
    chamber.manometer,
    chamber.depth,
    chamber.no_valves
   FROM (chamber chamber
     JOIN installation installation ON ((chamber.id = installation.id)));


ALTER TABLE vw_installation_chamber OWNER TO postgres;

--
-- Name: vw_installation_pressurecontrol; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_installation_pressurecontrol AS
 SELECT installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    pressurecontrol.fk_pressurecontrol_type
   FROM (pressurecontrol pressurecontrol
     JOIN installation installation ON ((pressurecontrol.id = installation.id)));


ALTER TABLE vw_installation_pressurecontrol OWNER TO postgres;

--
-- Name: vw_installation_pump; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_installation_pump AS
 SELECT installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    pump.fk_pump_type,
    pump.fk_pipe_in,
    pump.fk_pipe_out,
    pump.fk_pump_operating,
    pump.no_pumps,
    pump.rejected_flow,
    pump.manometric_height
   FROM (pump pump
     JOIN installation installation ON ((pump.id = installation.id)));


ALTER TABLE vw_installation_pump OWNER TO postgres;

--
-- Name: vw_installation_source; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_installation_source AS
 SELECT installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    source.fk_source_type,
    source.fk_source_quality,
    source.flow_lowest,
    source.flow_average,
    source.flow_concession,
    source.contract_end,
    source.gathering_chamber
   FROM (source source
     JOIN installation installation ON ((source.id = installation.id)));


ALTER TABLE vw_installation_source OWNER TO postgres;

--
-- Name: vw_installation_tank; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_installation_tank AS
 SELECT installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    tank.fk_overflow,
    tank.fk_tank_firestorage,
    tank.storage_total,
    tank.storage_supply,
    tank.storage_fire,
    tank.altitude_overflow,
    tank.altitude_apron,
    tank.height_max,
    tank.fire_valve,
    tank.fire_remote,
    tank._litrepercm,
    tank.cistern1_fk_type,
    tank.cistern1_dimension_1,
    tank.cistern1_dimension_2,
    tank.cistern1_storage,
    tank._cistern1_litrepercm,
    tank.cistern2_fk_type,
    tank.cistern2_dimension_1,
    tank.cistern2_dimension_2,
    tank.cistern2_storage,
    tank._cistern2_litrepercm
   FROM (tank tank
     JOIN installation installation ON ((tank.id = installation.id)));


ALTER TABLE vw_installation_tank OWNER TO postgres;

--
-- Name: vw_installation_treatment; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_installation_treatment AS
 SELECT installation.id,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.parcel,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    treatment.sanitization_uv,
    treatment.sanitization_chlorine_liquid,
    treatment.sanitization_chlorine_gazeous,
    treatment.sanitization_ozone,
    treatment.filtration_membrane,
    treatment.filtration_sandorgravel,
    treatment.flocculation,
    treatment.activatedcharcoal,
    treatment.settling,
    treatment.treatment_capacity
   FROM (treatment treatment
     JOIN installation installation ON ((treatment.id = installation.id)));


ALTER TABLE vw_installation_treatment OWNER TO postgres;

--
-- Name: vw_pipe_child_parent; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_pipe_child_parent AS
 SELECT foo2.child,
    foo2.parent,
    (public.st_curvetoline(public.st_geomfromewkt((((((((((((((('SRID='::text || qwat_sys.fn_setting_srid()) || ';CIRCULARSTRING('::text) || public.st_x(foo2.start_point)) || ' '::text) || public.st_y(foo2.start_point)) || ','::text) || (public.st_x(foo2.middle_point) + (foo2.distance * cos(foo2.azimuth)))) || ' '::text) || (public.st_y(foo2.middle_point) + (foo2.distance * sin(foo2.azimuth)))) || ','::text) || public.st_x(foo2.end_point)) || ' '::text) || public.st_y(foo2.end_point)) || ')'::text)), 15))::public.geometry(LineString,21781) AS geometry
   FROM ( SELECT foo.child,
            foo.parent,
            foo.start_point,
            foo.end_point,
            ((pi() / (2)::double precision) + public.st_azimuth(foo.start_point, foo.end_point)) AS azimuth,
            ((0.5)::double precision * public.st_distance(foo.start_point, foo.end_point)) AS distance,
            (public.st_lineinterpolatepoint(public.st_makeline(foo.start_point, foo.end_point), (0.5)::double precision))::public.geometry(Point,21781) AS middle_point
           FROM ( SELECT a.id AS child,
                    b.id AS parent,
                    (public.st_force2d(public.st_lineinterpolatepoint(a.geometry, (0.5)::double precision)))::public.geometry(Point,21781) AS start_point,
                    public.st_closestpoint(public.st_makeline((public.st_lineinterpolatepoint(public.st_force2d(b.geometry), (LEAST((1)::numeric, (((4)::numeric / b._length2d) / (2)::numeric)))::double precision))::public.geometry(Point,21781), (public.st_lineinterpolatepoint(public.st_force2d(b.geometry), (GREATEST((0)::numeric, ((1)::numeric - (((4)::numeric / b._length2d) / (2)::numeric))))::double precision))::public.geometry(Point,21781)), a.geometry) AS end_point
                   FROM (pipe a
                     JOIN pipe b ON ((a.fk_parent = b.id)))
                  WHERE (a.fk_parent IS NOT NULL)) foo) foo2;


ALTER TABLE vw_pipe_child_parent OWNER TO postgres;

--
-- Name: vw_pipe_schema_visibleitems; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_pipe_schema_visibleitems AS
 SELECT pipe.id,
    pipe.fk_parent,
    pipe.fk_material,
    pipe._length2d,
    pipe._length3d,
    pipe.tunnel_or_bridge,
    pipe.schema_force_visible,
    pipe.geometry_alt2 AS geometry,
    pipe._valve_count,
    pipe._valve_closed
   FROM ((pipe
     JOIN qwat_vl.status ON ((pipe.fk_status = status.id)))
     JOIN qwat_vl.pipe_function ON ((pipe.fk_function = pipe_function.id)))
  WHERE ((COALESCE(pipe.schema_force_visible, pipe_function.schema_visible) IS TRUE) AND (status.active IS TRUE));


ALTER TABLE vw_pipe_schema_visibleitems OWNER TO postgres;

--
-- Name: VIEW vw_pipe_schema_visibleitems; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON VIEW vw_pipe_schema_visibleitems IS 'visible pipe in the schematic view (before merge)';


--
-- Name: vw_pipe_schema_merged; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_pipe_schema_merged AS
 WITH RECURSIVE pipe_find_parent(depth_level, id, groupid, geometry, _length2d, _length3d, tunnel_or_bridge, _valve_count, _valve_closed) AS (
         SELECT 1 AS depth_level,
            pipe.id,
            pipe.id,
            pipe.geometry,
            pipe._length2d,
            pipe._length3d,
            pipe.tunnel_or_bridge,
            pipe._valve_count,
            pipe._valve_closed
           FROM vw_pipe_schema_visibleitems pipe
          WHERE (pipe.fk_parent IS NULL)
        UNION ALL
         SELECT (fp.depth_level + 1) AS depth_level,
            pipe.id,
            fp.groupid,
            pipe.geometry,
            pipe._length2d,
            pipe._length3d,
            pipe.tunnel_or_bridge,
            pipe._valve_count,
            pipe._valve_closed
           FROM (pipe_find_parent fp
             JOIN vw_pipe_schema_visibleitems pipe ON (((fp.id = pipe.fk_parent) AND (fp.depth_level < 20))))
        )
 SELECT pipe_find_parent.groupid AS id,
    (public.st_linemerge(public.st_union(pipe_find_parent.geometry)))::public.geometry(LineStringZ,21781) AS geometry,
    count(pipe_find_parent.groupid) AS number_of_pipe,
    sum(pipe_find_parent._length2d) AS _length2d,
    sum(pipe_find_parent._length3d) AS _length3d,
    bool_or(pipe_find_parent.tunnel_or_bridge) AS tunnel_or_bridge,
    sum(pipe_find_parent._valve_count) AS _valve_count,
    bool_or(pipe_find_parent._valve_closed) AS _valve_closed
   FROM pipe_find_parent
  GROUP BY pipe_find_parent.groupid;


ALTER TABLE vw_pipe_schema_merged OWNER TO postgres;

--
-- Name: vw_pipe_schema; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_pipe_schema AS
 SELECT pipe.id,
    pipe.fk_function,
    pipe.fk_installmethod,
    pipe.fk_material,
    pipe.fk_distributor,
    pipe.fk_precision,
    pipe.fk_protection,
    pipe.fk_status,
    pipe.fk_folder,
    pipe.year,
    pipe.year_end,
    pipe.pressure_nominal,
    pipe.remark,
    pipe.fk_district,
    pipe.fk_pressurezone,
    pipe.fk_printmap,
    pipe._printmaps,
    pipe.label_2_visible,
    pipe.label_2_text,
    vw_pipe_schema_merged._length2d,
    vw_pipe_schema_merged._length3d,
    vw_pipe_schema_merged.number_of_pipe,
    vw_pipe_schema_merged.tunnel_or_bridge,
    vw_pipe_schema_merged._valve_count,
    vw_pipe_schema_merged._valve_closed,
    pressurezone.name AS _pressurezone,
    pressurezone.colorcode AS _pressurezone_colorcode,
    vw_pipe_schema_merged.geometry
   FROM ((vw_pipe_schema_merged
     JOIN pipe ON ((pipe.id = vw_pipe_schema_merged.id)))
     LEFT JOIN pressurezone ON ((pipe.fk_pressurezone = pressurezone.id)));


ALTER TABLE vw_pipe_schema OWNER TO postgres;

--
-- Name: VIEW vw_pipe_schema; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON VIEW vw_pipe_schema IS 'Final view for schema';


--
-- Name: vw_pipe_schema_error; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_pipe_schema_error AS
 WITH RECURSIVE pipe_find_parent_error(path, depth_level, id, groupid, geometry) AS (
         SELECT (pipe.id)::character varying AS path,
            1 AS depth_level,
            pipe.id,
            pipe.id,
            pipe.geometry
           FROM vw_pipe_schema_visibleitems pipe
          WHERE (pipe.fk_parent IS NULL)
        UNION ALL
         SELECT (((fp.path)::text || '<-'::text) || pipe.id),
            (fp.depth_level + 1) AS depth_level,
            pipe.id,
            fp.groupid,
            pipe.geometry
           FROM (pipe_find_parent_error fp
             JOIN vw_pipe_schema_visibleitems pipe ON (((fp.id = pipe.fk_parent) AND (fp.depth_level < 20))))
        )
 SELECT foo.groupid,
    foo.geometry,
    foo.error_desc
   FROM ( SELECT pipe_find_parent_error.groupid,
            public.st_multi(public.st_linemerge(public.st_union(pipe_find_parent_error.geometry))) AS geometry,
            'lines cannot be joined'::character varying AS error_desc
           FROM pipe_find_parent_error
          GROUP BY pipe_find_parent_error.groupid) foo
  WHERE (public.geometrytype(public.st_collectionhomogenize(foo.geometry)) <> 'LINESTRING'::text)
UNION
 SELECT pipe_find_parent_error.groupid,
    pipe_find_parent_error.geometry,
    'circular referencing loop'::character varying AS error_desc
   FROM pipe_find_parent_error
  WHERE (pipe_find_parent_error.depth_level > 19);


ALTER TABLE vw_pipe_schema_error OWNER TO postgres;

--
-- Name: VIEW vw_pipe_schema_error; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON VIEW vw_pipe_schema_error IS 'Report IDs of parent pipe where pipe concatenation leads to a MultiLineString and not to a LineString or if an infinite referencing loop has been detected.';


--
-- Name: vw_printmap; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_printmap AS
 SELECT printmap.id,
    printmap.name,
    printmap.fk_district,
    printmap.remark,
    printmap.version_date,
    printmap.x_min,
    printmap.y_min,
    printmap.x_max,
    printmap.y_max,
    printmap.geometry,
    printmap.label_1_visible,
    printmap.label_1_x,
    printmap.label_1_y,
    printmap.label_1_rotation,
    printmap.label_1_text,
    printmap.label_2_visible,
    printmap.label_2_x,
    printmap.label_2_y,
    printmap.label_2_rotation,
    printmap.label_2_text,
    (((district.name)::text || ' '::text) || (printmap.name)::text) AS _longname,
    district.name AS _district,
    district.shortname AS _district_short
   FROM (printmap
     JOIN district ON ((printmap.fk_district = district.id)));


ALTER TABLE vw_printmap OWNER TO postgres;

SET search_path = qwat_vl, pg_catalog;

--
-- Name: protectionzone_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE protectionzone_type (
)
INHERITS (value_list_base);


ALTER TABLE protectionzone_type OWNER TO postgres;

--
-- Name: TABLE protectionzone_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE protectionzone_type IS 'type of protection zone.

Specifc to Switzerland:

Groundwater protection zones are the most incisive tool available for planning purposes. Zones of this kind are to be designated around all groundwater wells serving the public interest.

In the groundwater protection zones surrounding drinking water installations (groundwater wells, artificial recharge facilities), significant restrictions are imposed on human activities. The regulations become less stringent as one moves from the centre to the periphery:

1. Wellhead protection zone S1
The zone S1 comprises the area immediately surrounding a groundwater well or artificial recharge facility (at least 10 m around the well and around the collection system). In this zone, only construction work and activities connected with drinking water supply are permitted. The aim is to prevent damage to the facilities or direct contamination of the water abstracted. The zone S1 should therefore be purchased and fenced in by the drinking water supplier.

2. Inner protection zone S2
The inner protection zone S2 is primarily designed to prevent contamination of drinking water with pathogenic microorganisms and to ensure that groundwater flows are not adversely affected or obstructed as they approach the well.

In this zone, the spreading of liquid manure is therefore prohibited, as are the infiltration of wastewater and the construction of buildings and installations.

3. Outer protection zone S3
The outer protection zone is designed to ensure that, in the event of an accident, sufficient time and space are available to ward off any hazards to drinking water. Thus, facilities that pose a hazard to groundwater (e.g. petrol stations) are not allowed to be located in zone S3. Wastewater seepage and gravel extraction are likewise prohibited in this area.

Source: http://www.bafu.admin.ch/grundwasser/07483/07485/10037/index.html?lang=en';


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_protectionzone; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_protectionzone AS
 SELECT protectionzone.id,
    protectionzone.fk_type,
    protectionzone.name,
    protectionzone.validated,
    protectionzone.date,
    protectionzone.agent,
    protectionzone.geometry,
    protectionzone_type.value_fr AS _type_long,
    protectionzone_type.short_fr AS _type
   FROM (protectionzone
     JOIN qwat_vl.protectionzone_type ON ((protectionzone.fk_type = protectionzone_type.id)));


ALTER TABLE vw_protectionzone OWNER TO postgres;

--
-- Name: vw_qwat_network_element; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_qwat_network_element AS
 SELECT
        CASE
            WHEN (subscriber.id IS NOT NULL) THEN 'subscriber'::element_type
            WHEN (part.id IS NOT NULL) THEN 'part'::element_type
            WHEN (installation.id IS NOT NULL) THEN 'installation'::element_type
            WHEN (hydrant.id IS NOT NULL) THEN 'hydrant'::element_type
            WHEN (samplingpoint.id IS NOT NULL) THEN 'samplingpoint'::element_type
            WHEN (valve.id IS NOT NULL) THEN 'valve'::element_type
            WHEN (meter.id IS NOT NULL) THEN 'meter'::element_type
            ELSE 'element'::element_type
        END AS element_type,
    element.id,
    element.fk_district,
    element.fk_pressurezone,
    element.fk_printmap,
    element._printmaps,
    element._geometry_alt1_used,
    element._geometry_alt2_used,
    element._pipe_node_type,
    element._pipe_orientation,
    element._pipe_schema_visible,
    element.geometry,
    element.geometry_alt1,
    element.geometry_alt2,
    element.update_geometry_alt1,
    element.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    element.orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text,
        CASE
            WHEN (valve.id IS NOT NULL) THEN valve.networkseparation
            WHEN (installation.id IS NOT NULL) THEN installation.networkseparation
            ELSE NULL::boolean
        END AS networkseparation,
        CASE
            WHEN (subscriber.id IS NOT NULL) THEN subscriber.parcel
            WHEN (installation.id IS NOT NULL) THEN installation.parcel
            WHEN (meter.id IS NOT NULL) THEN meter.parcel
            ELSE NULL::character varying
        END AS parcel,
        CASE
            WHEN (subscriber.id IS NOT NULL) THEN subscriber.fk_pipe
            WHEN (part.id IS NOT NULL) THEN part.fk_pipe
            WHEN (valve.id IS NOT NULL) THEN valve.fk_pipe
            WHEN (meter.id IS NOT NULL) THEN meter.fk_pipe
            ELSE NULL::integer
        END AS fk_pipe,
    subscriber.fk_subscriber_type,
    subscriber.flow_current,
    subscriber.flow_planned,
    part.fk_part_type,
    installation.installation_type,
    installation.name,
    installation.fk_parent,
    installation.fk_remote,
    installation.fk_watertype,
    installation.eca,
    installation.open_water_surface,
    installation.geometry_polygon,
    installation.fk_source_type,
    installation.fk_source_quality,
    installation.flow_lowest,
    installation.flow_average,
    installation.flow_concession,
    installation.contract_end,
    installation.gathering_chamber,
    installation.fk_pump_type,
    installation.fk_pipe_in,
    installation.fk_pipe_out,
    installation.fk_pump_operating,
    installation.no_pumps,
    installation.rejected_flow,
    installation.manometric_height,
    installation.fk_overflow,
    installation.fk_tank_firestorage,
    installation.storage_total,
    installation.storage_supply,
    installation.storage_fire,
    installation.altitude_overflow,
    installation.altitude_apron,
    installation.height_max,
    installation.fire_valve,
    installation.fire_remote,
    installation._litrepercm,
    installation.cistern1_fk_type,
    installation.cistern1_dimension_1,
    installation.cistern1_dimension_2,
    installation.cistern1_storage,
    installation._cistern1_litrepercm,
    installation.cistern2_fk_type,
    installation.cistern2_dimension_1,
    installation.cistern2_dimension_2,
    installation.cistern2_storage,
    installation._cistern2_litrepercm,
    installation.sanitization_uv,
    installation.sanitization_chlorine_liquid,
    installation.sanitization_chlorine_gazeous,
    installation.sanitization_ozone,
    installation.filtration_membrane,
    installation.filtration_sandorgravel,
    installation.flocculation,
    installation.activatedcharcoal,
    installation.settling,
    installation.treatment_capacity,
    installation.flow_meter,
    installation.water_meter,
    installation.manometer,
    installation.depth,
    installation.no_valves,
    installation.fk_pressurecontrol_type,
    hydrant.fk_provider,
    hydrant.fk_model_sup,
    hydrant.fk_model_inf,
    hydrant.fk_material,
    hydrant.fk_output,
    hydrant.underground,
    hydrant.marked,
    hydrant.pressure_static,
    hydrant.pressure_dynamic,
    hydrant.flow,
    hydrant.observation_date,
    hydrant.observation_source,
    valve.fk_valve_type,
    valve.fk_valve_function,
    valve.fk_valve_actuation,
    valve.fk_handle_precision,
    valve.fk_handle_precisionalti,
    valve.fk_maintenance,
    valve.diameter_nominal,
    valve.closed,
    valve.handle_altitude,
    valve.handle_geometry
   FROM (((((((vw_node_element element
     LEFT JOIN subscriber subscriber ON ((element.id = subscriber.id)))
     LEFT JOIN part part ON ((element.id = part.id)))
     LEFT JOIN vw_qwat_installation installation ON ((element.id = installation.id)))
     LEFT JOIN hydrant hydrant ON ((element.id = hydrant.id)))
     LEFT JOIN samplingpoint samplingpoint ON ((element.id = samplingpoint.id)))
     LEFT JOIN valve valve ON ((element.id = valve.id)))
     LEFT JOIN meter meter ON ((element.id = meter.id)));


ALTER TABLE vw_qwat_network_element OWNER TO postgres;

--
-- Name: vw_qwat_node; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_qwat_node AS
 SELECT
        CASE
            WHEN (element.id IS NOT NULL) THEN 'element'::node_type
            ELSE 'node'::node_type
        END AS node_type,
    node.id,
    node.fk_district,
    node.fk_pressurezone,
    node.fk_printmap,
    node._printmaps,
    node._geometry_alt1_used,
    node._geometry_alt2_used,
    node._pipe_node_type,
    node._pipe_orientation,
    node._pipe_schema_visible,
    node.geometry,
    node.geometry_alt1,
    node.geometry_alt2,
    node.update_geometry_alt1,
    node.update_geometry_alt2,
    element.identification,
    element.fk_distributor,
    element.fk_status,
    element.fk_folder,
    element.fk_locationtype,
    element.fk_precision,
    element.fk_precisionalti,
    element.fk_object_reference,
    element.altitude,
    element.year,
    element.year_end,
    COALESCE(element.orientation, (- node._pipe_orientation)) AS orientation,
    element.remark,
    element.schema_force_visible,
    element.label_1_visible,
    element.label_1_x,
    element.label_1_y,
    element.label_1_rotation,
    element.label_1_text,
    element.label_2_visible,
    element.label_2_x,
    element.label_2_y,
    element.label_2_rotation,
    element.label_2_text
   FROM (node node
     LEFT JOIN network_element element ON ((node.id = element.id)));


ALTER TABLE vw_qwat_node OWNER TO postgres;

--
-- Name: vw_remote; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_remote AS
 SELECT distributor.name AS distributor,
    status.value_fr AS status,
    "precision".value_fr AS "precision",
    pipe_material._displayname_fr AS material,
    remote.identification,
    remote.year,
    remote.origin,
    remote.destination,
    remote.folder,
    remote.plan,
    remote.remark,
    remote.label_1_visible,
    remote.label_1_x,
    remote.label_1_y,
    remote.label_1_rotation,
    remote.label_1_text,
    remote.label_2_visible,
    remote.label_2_x,
    remote.label_2_y,
    remote.label_2_rotation,
    remote.label_2_text,
    remote.geometry
   FROM ((((remote
     JOIN distributor ON ((remote.fk_distributor = distributor.id)))
     JOIN qwat_vl.status ON ((remote.fk_status = status.id)))
     JOIN qwat_vl."precision" ON ((remote.fk_precision = "precision".id)))
     JOIN qwat_vl.pipe_material ON ((remote.fk_material = pipe_material.id)));


ALTER TABLE vw_remote OWNER TO postgres;

--
-- Name: vw_search_view; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_search_view AS
 SELECT 'Ouvrages'::text AS layer_name,
        CASE
            WHEN (vw_export_installation.installation_type = 'source'::installation_type) THEN ((('Source '::text || (vw_export_installation.identification)::text) || ' '::text) || (vw_export_installation.name)::text)
            WHEN (vw_export_installation.installation_type = 'treatment'::installation_type) THEN ((('Traitement '::text || (vw_export_installation.identification)::text) || ' '::text) || (vw_export_installation.name)::text)
            WHEN (vw_export_installation.installation_type = 'tank'::installation_type) THEN ((('Réservoir '::text || (vw_export_installation.identification)::text) || ' '::text) || (vw_export_installation.name)::text)
            WHEN (vw_export_installation.installation_type = 'pressurecontrol'::installation_type) THEN ((('Régulation de pression '::text || (vw_export_installation.identification)::text) || ' '::text) || (vw_export_installation.name)::text)
            WHEN (vw_export_installation.installation_type = 'pump'::installation_type) THEN ((('Pompage '::text || (vw_export_installation.identification)::text) || ' '::text) || (vw_export_installation.name)::text)
            WHEN (vw_export_installation.installation_type = 'chamber'::installation_type) THEN ((('Chambre '::text || (vw_export_installation.identification)::text) || ' '::text) || (vw_export_installation.name)::text)
            ELSE NULL::text
        END AS search_text,
    public.st_force2d(vw_export_installation.geometry) AS geometry
   FROM vw_export_installation
  WHERE (vw_export_installation.status_active IS TRUE)
UNION
 SELECT 'Hydrantes'::text AS layer_name,
    (((vw_export_hydrant.district_name)::text || ' '::text) || (vw_export_hydrant.identification)::text) AS search_text,
    public.st_force2d(vw_export_hydrant.geometry) AS geometry
   FROM vw_export_hydrant
  WHERE (vw_export_hydrant.status_active IS TRUE)
UNION
 SELECT 'Abonnés'::text AS layer_name,
    ((((((vw_export_subscriber.subscriber_type_value_fr)::text || ' '::text) || COALESCE(((vw_export_subscriber.district_prefix)::text || '_'::text), ''::text)) || (vw_export_subscriber.identification)::text) || ' '::text) || (vw_export_subscriber.district_name)::text) AS search_text,
    public.st_force2d(vw_export_subscriber.geometry) AS geometry
   FROM vw_export_subscriber
UNION
 SELECT 'Compteur'::text AS layer_name,
    (COALESCE(((meter.district_prefix)::text || '_'::text)) || (meter.identification)::text) AS search_text,
    public.st_force2d(meter.geometry) AS geometry
   FROM vw_export_meter meter
UNION
 SELECT 'Vannes'::text AS layer_name,
    (((((vw_export_valve.valve_function_value_fr)::text || ' '::text) || (vw_export_valve.identification)::text) || ' '::text) || (vw_export_valve.district_name)::text) AS search_text,
    public.st_force2d(vw_export_valve.geometry) AS geometry
   FROM vw_export_valve
  WHERE (vw_export_valve.identification IS NOT NULL);


ALTER TABLE vw_search_view OWNER TO postgres;

--
-- Name: vw_subscriber_pipe_relation; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_subscriber_pipe_relation AS
 SELECT a.id,
    a.identification,
    (public.st_makeline(public.st_force2d(a.geometry), public.st_lineinterpolatepoint(public.st_force2d(b.geometry), (0.5)::double precision)))::public.geometry(LineString,21781) AS geometry
   FROM (vw_element_subscriber a
     JOIN pipe b ON ((a.fk_pipe = b.id)))
  WHERE (a.fk_pipe IS NOT NULL);


ALTER TABLE vw_subscriber_pipe_relation OWNER TO postgres;

--
-- Name: vw_valve_lines; Type: VIEW; Schema: qwat_od; Owner: postgres
--

CREATE VIEW vw_valve_lines AS
 SELECT valve.id,
    (public.st_makeline(public.st_force2d(valve.handle_geometry), valve.geometry))::public.geometry(LineString,21781) AS geometry
   FROM vw_element_valve valve
  WHERE ((valve.handle_geometry IS NOT NULL) AND (valve.geometry IS NOT NULL));


ALTER TABLE vw_valve_lines OWNER TO postgres;

--
-- Name: VIEW vw_valve_lines; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON VIEW vw_valve_lines IS 'Valves represented as lines. Each line is made from two points, the handle as starting point and the location on the pipe as ending point.';


--
-- Name: worker; Type: TABLE; Schema: qwat_od; Owner: postgres
--

CREATE TABLE worker (
    id integer NOT NULL,
    last_name text,
    first_name text,
    date_entry date,
    date_end date,
    fk_type integer[]
);


ALTER TABLE worker OWNER TO postgres;

--
-- Name: TABLE worker; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TABLE worker IS 'Table for worker.';


--
-- Name: worker_id_seq; Type: SEQUENCE; Schema: qwat_od; Owner: postgres
--

CREATE SEQUENCE worker_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE worker_id_seq OWNER TO postgres;

--
-- Name: worker_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_od; Owner: postgres
--

ALTER SEQUENCE worker_id_seq OWNED BY worker.id;


SET search_path = qwat_sys, pg_catalog;

--
-- Name: logged_actions; Type: TABLE; Schema: qwat_sys; Owner: postgres
--

CREATE TABLE logged_actions (
    event_id bigint NOT NULL,
    schema_name text NOT NULL,
    table_name text NOT NULL,
    relid oid NOT NULL,
    session_user_name text,
    action_tstamp_tx timestamp with time zone NOT NULL,
    action_tstamp_stm timestamp with time zone NOT NULL,
    action_tstamp_clk timestamp with time zone NOT NULL,
    transaction_id bigint,
    application_name text,
    client_addr inet,
    client_port integer,
    client_query text NOT NULL,
    action text NOT NULL,
    row_data public.hstore,
    changed_fields public.hstore,
    statement_only boolean NOT NULL,
    CONSTRAINT logged_actions_action_check CHECK ((action = ANY (ARRAY['I'::text, 'D'::text, 'U'::text, 'T'::text])))
);


ALTER TABLE logged_actions OWNER TO postgres;

--
-- Name: TABLE logged_actions; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON TABLE logged_actions IS 'History of auditable actions on audited tables, from qwat_sys.if_modified_func()';


--
-- Name: COLUMN logged_actions.event_id; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.event_id IS 'Unique identifier for each auditable event';


--
-- Name: COLUMN logged_actions.schema_name; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.schema_name IS 'Database schema audited table for this event is in';


--
-- Name: COLUMN logged_actions.table_name; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.table_name IS 'Non-schema-qualified table name of table event occured in';


--
-- Name: COLUMN logged_actions.relid; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.relid IS 'Table OID. Changes with drop/create. Get with ''tablename''::regclass';


--
-- Name: COLUMN logged_actions.session_user_name; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.session_user_name IS 'Login / session user whose statement caused the audited event';


--
-- Name: COLUMN logged_actions.action_tstamp_tx; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.action_tstamp_tx IS 'Transaction start timestamp for tx in which audited event occurred';


--
-- Name: COLUMN logged_actions.action_tstamp_stm; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.action_tstamp_stm IS 'Statement start timestamp for tx in which audited event occurred';


--
-- Name: COLUMN logged_actions.action_tstamp_clk; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.action_tstamp_clk IS 'Wall clock time at which audited event''s trigger call occurred';


--
-- Name: COLUMN logged_actions.transaction_id; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.transaction_id IS 'Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.';


--
-- Name: COLUMN logged_actions.application_name; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.application_name IS 'Application name set when this audit event occurred. Can be changed in-session by client.';


--
-- Name: COLUMN logged_actions.client_addr; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.client_addr IS 'IP address of client that issued query. Null for unix domain socket.';


--
-- Name: COLUMN logged_actions.client_port; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.client_port IS 'Remote peer IP port address of client that issued query. Undefined for unix socket.';


--
-- Name: COLUMN logged_actions.client_query; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.client_query IS 'Top-level query that caused this auditable event. May be more than one statement.';


--
-- Name: COLUMN logged_actions.action; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.action IS 'Action type; I = insert, D = delete, U = update, T = truncate';


--
-- Name: COLUMN logged_actions.row_data; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.row_data IS 'Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.';


--
-- Name: COLUMN logged_actions.changed_fields; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.changed_fields IS 'New values of fields changed by UPDATE. Null except for row-level UPDATE events.';


--
-- Name: COLUMN logged_actions.statement_only; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON COLUMN logged_actions.statement_only IS '''t'' if audit event is from an FOR EACH STATEMENT trigger, ''f'' for FOR EACH ROW';


--
-- Name: logged_actions_event_id_seq; Type: SEQUENCE; Schema: qwat_sys; Owner: postgres
--

CREATE SEQUENCE logged_actions_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE logged_actions_event_id_seq OWNER TO postgres;

--
-- Name: logged_actions_event_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_sys; Owner: postgres
--

ALTER SEQUENCE logged_actions_event_id_seq OWNED BY logged_actions.event_id;


--
-- Name: settings; Type: TABLE; Schema: qwat_sys; Owner: postgres
--

CREATE TABLE settings (
    id integer NOT NULL,
    name character varying(30),
    type regtype,
    value text,
    v_min double precision,
    v_max double precision,
    v_not_null boolean DEFAULT true,
    description text,
    CONSTRAINT check_value CHECK ((
CASE
    WHEN ((type)::oid = ANY ((ARRAY['integer'::regtype, 'double precision'::regtype])::oid[])) THEN
    CASE
        WHEN ((v_max IS NOT NULL) AND (v_min IS NOT NULL)) THEN (((value)::double precision <= v_max) AND ((value)::double precision >= v_min))
        WHEN (v_max IS NOT NULL) THEN ((value)::double precision <= v_max)
        WHEN (v_min IS NOT NULL) THEN ((value)::double precision >= v_min)
        ELSE true
    END
    ELSE true
END AND
CASE
    WHEN v_not_null THEN (value IS NOT NULL)
    ELSE true
END)),
    CONSTRAINT setting_type CHECK (((type)::oid = ANY ((ARRAY['boolean'::regtype, 'integer'::regtype, 'double precision'::regtype, 'text'::regtype])::oid[])))
);


ALTER TABLE settings OWNER TO postgres;

--
-- Name: settings_id_seq; Type: SEQUENCE; Schema: qwat_sys; Owner: postgres
--

CREATE SEQUENCE settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE settings_id_seq OWNER TO postgres;

--
-- Name: settings_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_sys; Owner: postgres
--

ALTER SEQUENCE settings_id_seq OWNED BY settings.id;


--
-- Name: versions; Type: TABLE; Schema: qwat_sys; Owner: postgres
--

CREATE TABLE versions (
    id integer NOT NULL,
    module character varying,
    version character varying
);


ALTER TABLE versions OWNER TO postgres;

--
-- Name: versions_id_seq; Type: SEQUENCE; Schema: qwat_sys; Owner: postgres
--

CREATE SEQUENCE versions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE versions_id_seq OWNER TO postgres;

--
-- Name: versions_id_seq; Type: SEQUENCE OWNED BY; Schema: qwat_sys; Owner: postgres
--

ALTER SEQUENCE versions_id_seq OWNED BY versions.id;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: bedding; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE bedding (
)
INHERITS (value_list_base);


ALTER TABLE bedding OWNER TO postgres;

--
-- Name: TABLE bedding; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE bedding IS 'Bedding';


--
-- Name: cover_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE cover_type (
)
INHERITS (value_list_base);


ALTER TABLE cover_type OWNER TO postgres;

--
-- Name: TABLE cover_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE cover_type IS 'Type of covers';


--
-- Name: locationtype; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE locationtype (
)
INHERITS (value_list_base);


ALTER TABLE locationtype OWNER TO postgres;

--
-- Name: TABLE locationtype; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE locationtype IS 'Location type for water specific elements';


--
-- Name: survey_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE survey_type (
    code_sire smallint
)
INHERITS (value_list_base);


ALTER TABLE survey_type OWNER TO postgres;

--
-- Name: TABLE survey_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE survey_type IS 'Water type table, with SIRE code.';


--
-- Name: valve_maintenance; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE valve_maintenance (
    priority smallint,
    CONSTRAINT valve_maintenance_priority_check CHECK (((priority > 0) AND (priority < 4)))
)
INHERITS (value_list_base);


ALTER TABLE valve_maintenance OWNER TO postgres;

--
-- Name: TABLE valve_maintenance; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE valve_maintenance IS 'valve maintenance table.';


--
-- Name: visible; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE visible (
    vl_code boolean,
    vl_code_int smallint
)
INHERITS (value_list_base);


ALTER TABLE visible OWNER TO postgres;

--
-- Name: TABLE visible; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE visible IS 'Table for editing in qgis tri state boolean (NULL/True/False) by using value relation.';


--
-- Name: worker_type; Type: TABLE; Schema: qwat_vl; Owner: postgres
--

CREATE TABLE worker_type (
)
INHERITS (value_list_base);


ALTER TABLE worker_type OWNER TO postgres;

--
-- Name: TABLE worker_type; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TABLE worker_type IS 'type for worker.';


SET search_path = qwat_dr, pg_catalog;

--
-- Name: annotationline id; Type: DEFAULT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY annotationline ALTER COLUMN id SET DEFAULT nextval('annotationline_id_seq'::regclass);


--
-- Name: annotationpoint id; Type: DEFAULT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY annotationpoint ALTER COLUMN id SET DEFAULT nextval('annotationpoint_id_seq'::regclass);


--
-- Name: constructionpoint id; Type: DEFAULT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY constructionpoint ALTER COLUMN id SET DEFAULT nextval('constructionpoint_id_seq'::regclass);


--
-- Name: dimension_distance id; Type: DEFAULT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY dimension_distance ALTER COLUMN id SET DEFAULT nextval('dimension_distance_id_seq'::regclass);


--
-- Name: dimension_orientation id; Type: DEFAULT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY dimension_orientation ALTER COLUMN id SET DEFAULT nextval('dimension_orientation_id_seq'::regclass);


SET search_path = qwat_od, pg_catalog;

--
-- Name: consumptionzone id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY consumptionzone ALTER COLUMN id SET DEFAULT nextval('consumptionzone_id_seq'::regclass);


--
-- Name: cover id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY cover ALTER COLUMN id SET DEFAULT nextval('cover_id_seq'::regclass);


--
-- Name: crossing id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY crossing ALTER COLUMN id SET DEFAULT nextval('crossing_id_seq'::regclass);


--
-- Name: distributor id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY distributor ALTER COLUMN id SET DEFAULT nextval('distributor_id_seq'::regclass);


--
-- Name: district id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY district ALTER COLUMN id SET DEFAULT nextval('district_id_seq'::regclass);


--
-- Name: folder id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY folder ALTER COLUMN id SET DEFAULT nextval('folder_id_seq'::regclass);


--
-- Name: leak id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY leak ALTER COLUMN id SET DEFAULT nextval('leak_id_seq'::regclass);


--
-- Name: meter_reference id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY meter_reference ALTER COLUMN id SET DEFAULT nextval('meter_reference_id_seq'::regclass);


--
-- Name: node id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY node ALTER COLUMN id SET DEFAULT nextval('node_id_seq'::regclass);


--
-- Name: pipe id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe ALTER COLUMN id SET DEFAULT nextval('pipe_id_seq'::regclass);


--
-- Name: pressurezone id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone ALTER COLUMN id SET DEFAULT nextval('pressurezone_id_seq'::regclass);


--
-- Name: printmap id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY printmap ALTER COLUMN id SET DEFAULT nextval('printmap_id_seq'::regclass);


--
-- Name: protectionzone id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY protectionzone ALTER COLUMN id SET DEFAULT nextval('protectionzone_id_seq'::regclass);


--
-- Name: remote id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote ALTER COLUMN id SET DEFAULT nextval('remote_id_seq'::regclass);


--
-- Name: subscriber_reference id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber_reference ALTER COLUMN id SET DEFAULT nextval('subscriber_reference_id_seq'::regclass);


--
-- Name: worker id; Type: DEFAULT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY worker ALTER COLUMN id SET DEFAULT nextval('worker_id_seq'::regclass);


SET search_path = qwat_sys, pg_catalog;

--
-- Name: logged_actions event_id; Type: DEFAULT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY logged_actions ALTER COLUMN event_id SET DEFAULT nextval('logged_actions_event_id_seq'::regclass);


--
-- Name: settings id; Type: DEFAULT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY settings ALTER COLUMN id SET DEFAULT nextval('settings_id_seq'::regclass);


--
-- Name: versions id; Type: DEFAULT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY versions ALTER COLUMN id SET DEFAULT nextval('versions_id_seq'::regclass);


SET search_path = qwat_vl, pg_catalog;

--
-- Name: bedding vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY bedding ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: cistern vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY cistern ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: cover_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY cover_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: hydrant_material vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_material ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: hydrant_model_inf vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_model_inf ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: hydrant_model_sup vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_model_sup ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: hydrant_output vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_output ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: hydrant_provider vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_provider ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: leak_cause vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY leak_cause ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: locationtype vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY locationtype ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: object_reference vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY object_reference ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: overflow vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY overflow ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: part_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY part_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pipe_function vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_function ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pipe_installmethod vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_installmethod ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pipe_material vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_material ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pipe_protection vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_protection ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: precision vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY "precision" ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: precisionalti vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY precisionalti ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pressurecontrol_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pressurecontrol_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: protectionzone_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY protectionzone_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pump_operating vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pump_operating ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: pump_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pump_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: remote_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY remote_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: source_quality vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY source_quality ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: source_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY source_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: status vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY status ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: subscriber_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY subscriber_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: survey_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY survey_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: tank_firestorage vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY tank_firestorage ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: valve_actuation vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_actuation ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: valve_function vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_function ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: valve_maintenance vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_maintenance ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: valve_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_type ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: visible vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY visible ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: watertype vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY watertype ALTER COLUMN vl_active SET DEFAULT true;


--
-- Name: worker_type vl_active; Type: DEFAULT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY worker_type ALTER COLUMN vl_active SET DEFAULT true;


SET search_path = public, pg_catalog;

--
-- Data for Name: spatial_ref_sys; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY spatial_ref_sys (srid, auth_name, auth_srid, srtext, proj4text) FROM stdin;
\.


SET search_path = qwat_dr, pg_catalog;

--
-- Data for Name: annotationline; Type: TABLE DATA; Schema: qwat_dr; Owner: postgres
--

COPY annotationline (id, labelvisible, text_size, text_orientation, annotation, scale_1, scale_2, geometry) FROM stdin;
\.


--
-- Name: annotationline_id_seq; Type: SEQUENCE SET; Schema: qwat_dr; Owner: postgres
--

SELECT pg_catalog.setval('annotationline_id_seq', 1, false);


--
-- Data for Name: annotationpoint; Type: TABLE DATA; Schema: qwat_dr; Owner: postgres
--

COPY annotationpoint (id, text_size, text_orientation, annotation, scale_1, scale_2, geometry) FROM stdin;
\.


--
-- Name: annotationpoint_id_seq; Type: SEQUENCE SET; Schema: qwat_dr; Owner: postgres
--

SELECT pg_catalog.setval('annotationpoint_id_seq', 1, false);


--
-- Data for Name: constructionpoint; Type: TABLE DATA; Schema: qwat_dr; Owner: postgres
--

COPY constructionpoint (id, altitude, fk_object_reference, code, measurement_campaign, remark, geometry) FROM stdin;
\.


--
-- Name: constructionpoint_id_seq; Type: SEQUENCE SET; Schema: qwat_dr; Owner: postgres
--

SELECT pg_catalog.setval('constructionpoint_id_seq', 1, false);


--
-- Data for Name: dimension_distance; Type: TABLE DATA; Schema: qwat_dr; Owner: postgres
--

COPY dimension_distance (id, observation, _calculation, remark, geometry) FROM stdin;
\.


--
-- Name: dimension_distance_id_seq; Type: SEQUENCE SET; Schema: qwat_dr; Owner: postgres
--

SELECT pg_catalog.setval('dimension_distance_id_seq', 1, false);


--
-- Data for Name: dimension_orientation; Type: TABLE DATA; Schema: qwat_dr; Owner: postgres
--

COPY dimension_orientation (id, observation, remark, geometry) FROM stdin;
\.


--
-- Name: dimension_orientation_id_seq; Type: SEQUENCE SET; Schema: qwat_dr; Owner: postgres
--

SELECT pg_catalog.setval('dimension_orientation_id_seq', 1, false);


SET search_path = qwat_od, pg_catalog;

--
-- Data for Name: chamber; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY chamber (id, networkseparation, flow_meter, water_meter, manometer, depth, no_valves) FROM stdin;
\.


--
-- Data for Name: consumptionzone; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY consumptionzone (id, name, population, colorcode) FROM stdin;
\.


--
-- Name: consumptionzone_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('consumptionzone_id_seq', 1, false);


--
-- Data for Name: cover; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY cover (id, identification, fk_distributor, fk_status, fk_cover_type, fk_installation, year, altitude, circular, form_dimension, remark, geometry, geometry_polygon, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Name: cover_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('cover_id_seq', 1, false);


--
-- Data for Name: crossing; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY crossing (id, disabled, controled, hide_pipe, _pipe1_id, _pipe2_id, _pipe1_angle, _pipe2_angle, geometry) FROM stdin;
\.


--
-- Name: crossing_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('crossing_id_seq', 1, false);


--
-- Data for Name: distributor; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY distributor (id, name) FROM stdin;
\.


--
-- Name: distributor_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('distributor_id_seq', 1, false);


--
-- Data for Name: district; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY district (id, name, shortname, zip, land_registry, prefix, colorcode, geometry, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Name: district_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('district_id_seq', 1, false);


--
-- Data for Name: folder; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY folder (id, identification, description, date_start, date_end, geometry_polygon, geometry_line) FROM stdin;
\.


--
-- Name: folder_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('folder_id_seq', 1, false);


--
-- Data for Name: hydrant; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY hydrant (id, fk_provider, fk_model_sup, fk_model_inf, fk_material, fk_output, underground, marked, pressure_static, pressure_dynamic, flow, observation_date, observation_source) FROM stdin;
\.


--
-- Data for Name: installation; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY installation (id, name, fk_parent, fk_remote, fk_watertype, parcel, eca, open_water_surface, geometry_polygon) FROM stdin;
\.


--
-- Data for Name: leak; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY leak (id, fk_cause, fk_pipe, widespread_damage, detection_date, repair_date, _repaired, address, pipe_replaced, description, repair, geometry, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Name: leak_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('leak_id_seq', 1, false);


--
-- Data for Name: meter; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY meter (id, fk_pipe, parcel) FROM stdin;
\.


--
-- Data for Name: meter_reference; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY meter_reference (id, fk_meter, geometry) FROM stdin;
\.


--
-- Name: meter_reference_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('meter_reference_id_seq', 1, false);


--
-- Data for Name: network_element; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY network_element (id, identification, fk_distributor, fk_status, fk_folder, fk_locationtype, fk_precision, fk_precisionalti, fk_object_reference, altitude, year, year_end, orientation, remark, schema_force_visible, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Data for Name: node; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY node (id, fk_district, fk_pressurezone, fk_printmap, _printmaps, _geometry_alt1_used, _geometry_alt2_used, _pipe_node_type, _pipe_orientation, _pipe_schema_visible, geometry, geometry_alt1, geometry_alt2, update_geometry_alt1, update_geometry_alt2) FROM stdin;
\.


--
-- Name: node_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('node_id_seq', 1, false);


--
-- Data for Name: part; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY part (id, fk_part_type, fk_pipe) FROM stdin;
\.


--
-- Data for Name: pipe; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY pipe (id, fk_parent, fk_function, fk_installmethod, fk_material, fk_distributor, fk_precision, fk_bedding, fk_protection, fk_status, fk_watertype, fk_locationtype, fk_folder, year, year_rehabilitation, year_end, tunnel_or_bridge, pressure_nominal, remark, _valve_count, _valve_closed, schema_force_visible, label_1_visible, label_1_text, label_2_visible, label_2_text, fk_node_a, fk_node_b, fk_district, fk_pressurezone, fk_printmap, _length2d, _length3d, _diff_elevation, _printmaps, _geometry_alt1_used, _geometry_alt2_used, update_geometry_alt1, update_geometry_alt2, geometry, geometry_alt1, geometry_alt2) FROM stdin;
\.


--
-- Name: pipe_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('pipe_id_seq', 1, false);


--
-- Data for Name: pressurecontrol; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY pressurecontrol (id, fk_pressurecontrol_type) FROM stdin;
\.


--
-- Data for Name: pressurezone; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY pressurezone (id, fk_distributor, fk_consumptionzone, name, population, subscriber, colorcode, geometry, geometry_alt1, geometry_alt2, _geometry_alt1_used, _geometry_alt2_used, update_geometry_alt1, update_geometry_alt2, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Name: pressurezone_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('pressurezone_id_seq', 1, false);


--
-- Data for Name: printmap; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY printmap (id, name, fk_district, remark, version_date, x_min, y_min, x_max, y_max, geometry, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Name: printmap_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('printmap_id_seq', 1, false);


--
-- Data for Name: protectionzone; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY protectionzone (id, fk_type, name, validated, date, agent, geometry) FROM stdin;
\.


--
-- Name: protectionzone_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('protectionzone_id_seq', 1, false);


--
-- Data for Name: pump; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY pump (id, fk_pump_type, fk_pipe_in, fk_pipe_out, fk_pump_operating, no_pumps, rejected_flow, manometric_height) FROM stdin;
\.


--
-- Data for Name: remote; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY remote (id, fk_distributor, fk_status, fk_precision, fk_material, identification, year, origin, destination, folder, plan, remark, _geometry_alt1_used, _geometry_alt2_used, update_geometry_alt1, update_geometry_alt2, geometry, geometry_alt1, geometry_alt2, label_1_visible, label_1_x, label_1_y, label_1_rotation, label_1_text, label_2_visible, label_2_x, label_2_y, label_2_rotation, label_2_text) FROM stdin;
\.


--
-- Name: remote_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('remote_id_seq', 1, false);


--
-- Data for Name: samplingpoint; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY samplingpoint (id) FROM stdin;
\.


--
-- Data for Name: source; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY source (id, fk_source_type, fk_source_quality, flow_lowest, flow_average, flow_concession, contract_end, gathering_chamber) FROM stdin;
\.


--
-- Data for Name: subscriber; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY subscriber (id, fk_subscriber_type, fk_pipe, parcel, flow_current, flow_planned) FROM stdin;
\.


--
-- Data for Name: subscriber_reference; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY subscriber_reference (id, fk_subscriber, geometry) FROM stdin;
\.


--
-- Name: subscriber_reference_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('subscriber_reference_id_seq', 1, false);


--
-- Data for Name: surveypoint; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY surveypoint (id, fk_survey_type, fk_worker, code, description, date, fk_folder, altitude, geometry) FROM stdin;
\.


--
-- Data for Name: tank; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY tank (id, fk_overflow, fk_tank_firestorage, storage_total, storage_supply, storage_fire, altitude_overflow, altitude_apron, height_max, fire_valve, fire_remote, _litrepercm, cistern1_fk_type, cistern1_dimension_1, cistern1_dimension_2, cistern1_storage, _cistern1_litrepercm, cistern2_fk_type, cistern2_dimension_1, cistern2_dimension_2, cistern2_storage, _cistern2_litrepercm) FROM stdin;
\.


--
-- Data for Name: treatment; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY treatment (id, sanitization_uv, sanitization_chlorine_liquid, sanitization_chlorine_gazeous, sanitization_ozone, filtration_membrane, filtration_sandorgravel, flocculation, activatedcharcoal, settling, treatment_capacity) FROM stdin;
\.


--
-- Data for Name: valve; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY valve (id, fk_valve_type, fk_valve_function, fk_valve_actuation, fk_pipe, fk_handle_precision, fk_handle_precisionalti, fk_maintenance, diameter_nominal, closed, networkseparation, handle_altitude, handle_geometry) FROM stdin;
\.


--
-- Data for Name: worker; Type: TABLE DATA; Schema: qwat_od; Owner: postgres
--

COPY worker (id, last_name, first_name, date_entry, date_end, fk_type) FROM stdin;
\.


--
-- Name: worker_id_seq; Type: SEQUENCE SET; Schema: qwat_od; Owner: postgres
--

SELECT pg_catalog.setval('worker_id_seq', 1, false);


SET search_path = qwat_sys, pg_catalog;

--
-- Data for Name: logged_actions; Type: TABLE DATA; Schema: qwat_sys; Owner: postgres
--

COPY logged_actions (event_id, schema_name, table_name, relid, session_user_name, action_tstamp_tx, action_tstamp_stm, action_tstamp_clk, transaction_id, application_name, client_addr, client_port, client_query, action, row_data, changed_fields, statement_only) FROM stdin;
\.


--
-- Name: logged_actions_event_id_seq; Type: SEQUENCE SET; Schema: qwat_sys; Owner: postgres
--

SELECT pg_catalog.setval('logged_actions_event_id_seq', 1, false);


--
-- Data for Name: settings; Type: TABLE DATA; Schema: qwat_sys; Owner: postgres
--

COPY settings (id, name, type, value, v_min, v_max, v_not_null, description) FROM stdin;
1	srid	integer	21781	\N	\N	t	\N
\.


--
-- Name: settings_id_seq; Type: SEQUENCE SET; Schema: qwat_sys; Owner: postgres
--

SELECT pg_catalog.setval('settings_id_seq', 1, true);


--
-- Data for Name: versions; Type: TABLE DATA; Schema: qwat_sys; Owner: postgres
--

COPY versions (id, module, version) FROM stdin;
1	model.core	0.1.0
\.


--
-- Name: versions_id_seq; Type: SEQUENCE SET; Schema: qwat_sys; Owner: postgres
--

SELECT pg_catalog.setval('versions_id_seq', 1, true);


SET search_path = qwat_vl, pg_catalog;

--
-- Data for Name: bedding; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY bedding (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
9701	t	\N	\N	\N	aucun	none	lipsă	\N	\N	\N
9702	t	\N	\N	\N	béton	concrete	beton	\N	\N	\N
9703	t	\N	\N	\N	géotextile	geotextile	geotextil	\N	\N	\N
9704	t	\N	\N	\N	gravier	gravle	pietriş	\N	\N	\N
9706	t	\N	\N	\N	sable	sand	nisip	\N	\N	\N
9707	t	\N	\N	\N	terre	soil	pământ	\N	\N	\N
\.


--
-- Data for Name: cistern; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY cistern (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
2101	t	\N	\N	\N	circulaire	circular	circulară	\N	\N	\N
2102	t	\N	\N	\N	rectangulaire	rectangular	dreptunghiulară	\N	\N	\N
\.


--
-- Data for Name: cover_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY cover_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
9801	t	\N	\N	\N	couvercle acier	steel cover	capac oţel	\N	\N	\N
9802	t	\N	\N	\N	couvercle béton	concrete cover	capac beton	\N	\N	\N
9803	t	\N	\N	\N	couvercle plastique	plastic cover	capac plastic	\N	\N	\N
9804	t	\N	\N	\N	couvercle fonte	cast-iron cover	capac fontă	\N	\N	\N
\.


--
-- Data for Name: hydrant_material; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY hydrant_material (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, pressure_nominal) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
7002	t	F 65	CI 65	F 65	Fonte 65	Cast iron 65	Fontă 65	\N	\N	\N	16
7003	t	F 80	CI 80	F 80	Fonte 80	Cast iron 80	Fontă 80	\N	\N	\N	16
7004	t	F 100	CI 100	F 100	Fonte 100	Cast iron 100	Fontă 100	\N	\N	\N	16
\.


--
-- Data for Name: hydrant_model_inf; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY hydrant_model_inf (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
7301	t	\N	\N	\N	Hawle	\N	\N	\N	\N	\N
7302	t	\N	\N	\N	Hawle_H4	\N	\N	\N	\N	\N
7303	t	\N	\N	\N	Hinni	\N	\N	\N	\N	\N
7304	t	\N	\N	\N	Hinni_Standard	\N	\N	\N	\N	\N
7305	t	\N	\N	\N	Hinri_Double_fermeture	\N	\N	\N	\N	\N
7306	t	\N	\N	\N	VonRoll	\N	\N	\N	\N	\N
7307	t	\N	\N	\N	VonRoll_4105_Mod_1896	\N	\N	\N	\N	\N
7308	t	\N	\N	\N	VonRoll_4107_Mod_1935	\N	\N	\N	\N	\N
7309	t	\N	\N	\N	VonRolI_7500	\N	\N	\N	\N	\N
7310	t	\N	\N	\N	VonRoll_5500	\N	\N	\N	\N	\N
7311	t	\N	\N	\N	VonRoll_fix	\N	\N	\N	\N	\N
7312	t	\N	\N	\N	VonFloll_reglable	\N	\N	\N	\N	\N
7313	t	\N	\N	\N	VonRoll_vario	\N	\N	\N	\N	\N
7314	t	\N	\N	\N	VonRoll_ufFix	\N	\N	\N	\N	\N
7315	t	\N	\N	\N	VonRoll_varial	\N	\N	\N	\N	\N
7316	t	\N	\N	\N	VonRoll_1955	\N	\N	\N	\N	\N
7317	t	\N	\N	\N	VonRoll_1989_5000	\N	\N	\N	\N	\N
7318	t	\N	\N	\N	VonRoll_2007_5000	\N	\N	\N	\N	\N
\.


--
-- Data for Name: hydrant_model_sup; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY hydrant_model_sup (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
7201	t	\N	\N	\N	Hawle	\N	\N	\N	\N	\N
7202	t	\N	\N	\N	Hawle_H4	\N	\N	\N	\N	\N
7203	t	\N	\N	\N	Hinni	\N	\N	\N	\N	\N
7204	t	\N	\N	\N	Hinni_6000	\N	\N	\N	\N	\N
7205	t	\N	\N	\N	Hinni_6006	\N	\N	\N	\N	\N
7206	t	\N	\N	\N	VonRoll	\N	\N	\N	\N	\N
7207	t	\N	\N	\N	VonRoll_4105_Mod_1896	\N	\N	\N	\N	\N
7208	t	\N	\N	\N	VonRoll_4107_Mod_1935	\N	\N	\N	\N	\N
7209	t	\N	\N	\N	VonRoll_7500_Mod_1955	\N	\N	\N	\N	\N
7210	t	\N	\N	\N	VonRoll_7502_Mod_1970	\N	\N	\N	\N	\N
7211	t	\N	\N	\N	VonRoll_Hy_classic_Serie_5500	\N	\N	\N	\N	\N
7212	t	\N	\N	\N	VonRoll_Hy_plus_Serie_5700	\N	\N	\N	\N	\N
7213	t	\N	\N	\N	VonRoll_Hy_5000s_Serie_5400_Cobra	\N	\N	\N	\N	\N
7214	t	\N	\N	\N	VonRoll_Hy_deco_Mod_1896_Nostalgie	\N	\N	\N	\N	\N
7215	t	\N	\N	\N	VonRoll_Hytec_5601	\N	\N	\N	\N	\N
7216	t	\N	\N	\N	VonRoll_Hytec_5602	\N	\N	\N	\N	\N
7217	t	\N	\N	\N	VonRoll_Hytec_5603	\N	\N	\N	\N	\N
7218	t	\N	\N	\N	VonRoll_Hytec_5607	\N	\N	\N	\N	\N
7219	t	\N	\N	\N	VonRoll_5000_Mod_1989	\N	\N	\N	\N	\N
\.


--
-- Data for Name: hydrant_output; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY hydrant_output (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
7401	t	\N	\N	\N	1x75	\N	\N	\N	\N	\N
7402	t	\N	\N	\N	2x75	\N	\N	\N	\N	\N
7403	t	\N	\N	\N	3x75	\N	\N	\N	\N	\N
7404	t	\N	\N	\N	2x55	\N	\N	\N	\N	\N
7405	t	\N	\N	\N	1x55_1x75	\N	\N	\N	\N	\N
7406	t	\N	\N	\N	2x55_1x75	\N	\N	\N	\N	\N
7407	t	\N	\N	\N	2x55_1x100	\N	\N	\N	\N	\N
\.


--
-- Data for Name: hydrant_provider; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY hydrant_provider (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
7101	t	\N	\N	\N	+GF+	+GF+	+GF+	\N	\N	\N
7102	t	\N	\N	\N	Wild	Wild	Wild	\N	\N	\N
7103	t	\N	\N	\N	Hawie	Hawie	Hawie	\N	\N	\N
7104	t	\N	\N	\N	Erhard	Erhard	Erhard	\N	\N	\N
7105	t	\N	\N	\N	SISTAG	SISTAG	SISTAG	\N	\N	\N
7106	t	\N	\N	\N	Von Roll	Von Roll	Von Roll	\N	\N	\N
7107	t	\N	\N	\N	Straub	Straub	Straub	\N	\N	\N
7108	t	\N	\N	\N	Hinni	Hinni	Hinni	\N	\N	\N
7109	t	\N	\N	\N	AVK	AVK	AVK	\N	\N	\N
\.


--
-- Data for Name: leak_cause; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY leak_cause (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
9101	t	\N	\N	\N	cassure franche	\N	spărtură normală	\N	\N	\N
9102	t	\N	\N	\N	cassure longitudinale	\N	spărtură longitudinală	\N	\N	\N
9103	t	\N	\N	\N	conduite arrachée	\N	conductă smulsă	\N	\N	\N
9104	t	\N	\N	\N	corrosion	\N	coroziune	\N	\N	\N
9105	t	\N	\N	\N	raccordement non étanche	\N	racordare neetanșă	\N	\N	\N
9106	t	\N	\N	\N	pièce non étanche	\N	piesă neetanșă	\N	\N	\N
\.


--
-- Data for Name: locationtype; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY locationtype (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
9601	t	\N	\N	\N	aucun	none	niciunul	\N	\N	\N
9604	t	\N	\N	\N	trottoir	sidewalk	trotuar	\N	\N	\N
9605	t	\N	\N	\N	carrossable	carriageable	carosabil	\N	\N	\N
9606	t	\N	\N	\N	pavés	cubic street stones	piatră cubică	\N	\N	\N
9607	t	\N	\N	\N	gravier	gravle	pietriş	\N	\N	\N
9608	t	\N	\N	\N	sable	sand	nisip	\N	\N	\N
9609	t	\N	\N	\N	terre	soil	pământ	\N	\N	\N
9610	t	\N	\N	\N	béton	concrete	beton	\N	\N	\N
9611	t	\N	\N	\N	espace vert	open space	spaţiu verde	\N	\N	\N
9612	t	\N	\N	\N	asphalte	asphalt	asfalt	\N	\N	\N
\.


--
-- Data for Name: object_reference; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY object_reference (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
9001	t	\N	\N	\N	radier	apron	radier	\N	\N	\N
9002	t	\N	\N	\N	sol	ground	sol	\N	\N	\N
9003	t	\N	\N	\N	conduite	pipe	conductă	\N	\N	\N
9004	t	\N	\N	\N	dessus	on top	deasupra	\N	\N	\N
\.


--
-- Data for Name: overflow; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY overflow (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
2201	t	\N	\N	\N	en décharge	dumped	aruncată	\N	\N	\N
2202	t	\N	\N	\N	récupéré	collected	recuperată	\N	\N	\N
\.


--
-- Data for Name: part_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY part_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
9200	t	\N	\N	\N	compteur abonné		apometru abonat	\N	\N	\N
9201	t	\N	\N	\N	bouchon		dop	\N	\N	\N
9202	t	\N	\N	\N	bouche d'arrosage		gură de stropire/pulverizare	\N	\N	\N
9203	t	\N	\N	\N		tee fitting	fiting tip T	\N	\N	\N
9204	t	\N	\N	\N		elbow fitting	cot	\N	\N	\N
9205	t	\N	\N	\N		end fitting	capăt reţea	\N	\N	\N
9206	t	\N	\N	\N		reduction fitting	fiting reductor	\N	\N	\N
9207	t	\N	\N	\N		cross fitting	fiting tip cruce	\N	\N	\N
9208	t	\N	\N	\N		unknown fitting	fiting nedeterminat	\N	\N	\N
9209	t	\N	\N	\N	manomètre	manometer	manometru	\N	\N	\N
9210	t	\N	\N	\N	débitmètre	flow meter	debitmetru	\N	\N	\N
\.


--
-- Data for Name: pipe_function; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pipe_function (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, schema_visible, major, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	t	t	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	t	t	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	t	t	\N
4101	t	\N	\N	\N	Conduite de transport	\N	Conductă de transport	\N	\N	\N	t	t	2
4102	t	\N	\N	\N	Conduite d'hydrant	\N	Conductă de hidrant	\N	\N	\N	f	t	0
4103	t	\N	\N	\N	Conduite de vidange	\N	Conductă de golire	\N	\N	\N	f	f	4
4105	t	\N	\N	\N	Conduite de distribution	\N	Conductă de distribuţie	\N	\N	\N	t	t	2
4106	t	\N	\N	\N	Branchement commun	\N	Branşament comun	\N	\N	\N	f	f	3
4107	t	\N	\N	\N	By-pass	\N	By-pass	\N	\N	\N	f	f	2
4108	t	\N	\N	\N	Branchement privé	\N	Branşament privat	\N	\N	\N	f	f	3
4109	t	\N	\N	\N	Conduite de haute pression	\N	Conductă de înaltă presiune	\N	\N	\N	t	t	2
4110	t	\N	\N	\N	Drain captant	\N	Captare dren	\N	\N	\N	f	f	1
4111	t	\N	\N	\N	Trop plein	\N	Prea plin	\N	\N	\N	t	t	4
4112	t	\N	\N	\N	Ventilation	\N	Aerisire	\N	\N	\N	f	f	4
\.


--
-- Data for Name: pipe_installmethod; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pipe_installmethod (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
4201	t	\N	\N	\N	En fouille	\N	Excavare	\N	\N	\N
4202	t	\N	\N	\N	Chemisé	\N	Cămăşuire	\N	\N	\N
4203	t	\N	\N	\N	Air libre	\N	Aer liber	\N	\N	\N
4204	t	\N	\N	\N	Sous pont	\N	Sub pod	\N	\N	\N
4205	t	\N	\N	\N	Protégé	\N	Protejată	\N	\N	\N
4206	t	\N	\N	\N	Bétoné	\N	Betonată	\N	\N	\N
4207	t	\N	\N	\N	Galerie	\N	Galerie	\N	\N	\N
\.


--
-- Data for Name: pipe_material; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pipe_material (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, _displayname_fr, _displayname_en, _displayname_ro, diameter, diameter_nominal, diameter_internal, diameter_external, code_sire, pressure_nominal, sdr, wall_thickness, sn) FROM stdin;
101	t	Autre	Other	Altul	Autre	Other	Altul	\N	\N	\N	Autre	Other	Altul	\N	\N	\N	\N	1	\N	\N	\N	\N
102	t	Inc.	Unknown	Nec.	Inconnu	Unknown	Necunoscut	\N	\N	\N	Inc.	Unknown	Nec.	\N	\N	\N	\N	1	\N	\N	\N	\N
103	t	à dét.	To determ.	De det.	à déterminer	To be determined	De determinat	\N	\N	\N	à dét.	To determ.	De det.	\N	\N	\N	\N	1	\N	\N	\N	\N
5508	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 25 PN16	 25 PN16	PE 25 PN16	25	20	20.400	25.000	10	16	11	2.3	\N
5509	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN16	 250 PN16	PE 250 PN16	250	200	204.600	250.000	10	16	11	22.7	\N
5510	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 32 PN16	 32 PN16	PE 32 PN16	32	25	26.200	32.000	10	16	11	2.9	\N
5511	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN16	 355 PN16	PE 355 PN16	355	300	290.600	355.000	10	16	11	32.2	\N
5512	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN16	 40 PN16	PE 40 PN16	40	32	32.600	40.000	10	16	11	3.7	\N
5513	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN16	 400 PN16	PE 400 PN16	400	325	327.200	400.000	10	16	11	36.4	\N
5514	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN16	 50 PN16	PE 50 PN16	50	40	40.800	50.000	10	16	11	4.6	\N
5515	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN16	 63 PN16	PE 63 PN16	63	50	51.400	63.000	10	16	11	5.8	\N
5516	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN16	 75 PN16	PE 75 PN16	75	60	61.400	75.000	10	16	11	6.8	\N
5517	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN16	 90 PN16	PE 90 PN16	90	75	73.600	90.000	10	16	11	8.2	\N
5518	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN16	 140 PN16	PE 140 PN16	140	\N	114.600	140.000	10	16	11	12.7	\N
5519	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN16	 180 PN16	PE 180 PN16	180	\N	147.200	180.000	10	16	11	16.4	\N
5520	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN16	 225 PN16	PE 225 PN16	225	\N	184.000	225.000	10	16	11	20.5	\N
5521	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN16	 315 PN16	PE 315 PN16	315	\N	257.800	315.000	10	16	11	28.6	\N
5522	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 500 PN16	 500 PN16	PE 500 PN16	500	\N	409.200	500.000	10	16	11	45.4	\N
5523	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 630 PN16	 630 PN16	PE 630 PN16	630	\N	515.600	600.000	10	16	11	57.2	\N
5524	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN16	 450 PN16	PE 450 PN16	450	\N	368.200	450.000	10	16	11	40.9	\N
5525	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 560 PN16	 560 PN16	PE 560 PN16	560	\N	458.400	560.000	10	16	11	50.8	\N
7013	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN20	 200 PN20	PE 200 PN20	200	\N	155.200	200.000	10	20	9	22.4	\N
7014	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN20	 225 PN20	PE 225 PN20	225	\N	174.600	225.000	10	20	9	25.2	\N
7015	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN20	 250 PN20	PE 250 PN20	250	\N	194.200	250.000	10	20	9	27.9	\N
7016	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN20	 280 PN20	PE 280 PN20	280	\N	217.400	280.000	10	20	9	31.3	\N
7017	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN20	 315 PN20	PE 315 PN20	315	\N	244.600	315.000	10	20	9	35.2	\N
7018	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN20	 355 PN20	PE 355 PN20	355	\N	275.600	355.000	10	20	9	39.7	\N
7019	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN20	 400 PN20	PE 400 PN20	400	\N	310.600	400.000	10	20	9	44.7	\N
7020	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN20	 450 PN20	PE 450 PN20	450	\N	349.400	450.000	10	20	9	50.3	\N
7021	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 500 PN20	 500 PN20	PE 500 PN20	500	\N	388.400	500.000	10	20	9	55.8	\N
7022	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 560 PN20	 560 PN20	PE 560 PN20	560	\N	435.600	560.000	10	20	9	62.2	\N
7023	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 25 PN25	 25 PN25	PE 25 PN25	25	\N	18.000	25.000	10	25	7.40000000000000036	3.5	\N
7024	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 32 PN25	 32 PN25	PE 32 PN25	32	\N	23.200	32.000	10	25	7.40000000000000036	4.4	\N
7025	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN25	 40 PN25	PE 40 PN25	40	\N	29.000	40.000	10	25	7.40000000000000036	5.5	\N
7026	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN25	 50 PN25	PE 50 PN25	50	\N	36.200	50.000	10	25	7.40000000000000036	6.9	\N
7027	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN25	 63 PN25	PE 63 PN25	63	\N	45.800	63.000	10	25	7.40000000000000036	8.6	\N
7028	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN25	 75 PN25	PE 75 PN25	75	\N	54.400	75.000	10	25	7.40000000000000036	10.3	\N
7029	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN25	 90 PN25	PE 90 PN25	90	\N	65.400	90.000	10	25	7.40000000000000036	12.3	\N
7033	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 25 PN8	 25 PN8	PE 25 PN8	25	\N	21.000	25.000	10	8	21	2.0	\N
7034	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 32 PN8	 32 PN8	PE 32 PN8	32	\N	28.000	32.000	10	8	21	2.0	\N
7035	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN8	 40 PN8	PE 40 PN8	40	\N	36.000	40.000	10	8	21	2.0	\N
7045	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 710 PN12.5	 710 PN12.5	PE 710 PN12.5	710	\N	605.600	710.000	10	12.5	13.5999999999999996	52.2	\N
7046	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 25 PN10	 25 PN10	PE 25 PN10	25	\N	21.000	25.000	10	10	17	2.0	\N
7047	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 32 PN10	 32 PN10	PE 32 PN10	32	\N	28.000	32.000	10	10	17	2.0	\N
5504	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN16	 125 PN16	PE 125 PN16	125	100	102.200	125.000	10	16	11	11.4	\N
5506	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN16	 160 PN16	PE 160 PN16	160	125	130.800	160.000	10	16	11	14.6	\N
5507	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN16	 200 PN16	PE 200 PN16	200	160	163.600	200.000	10	16	11	18.2	\N
5526	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 710 PN16	 710 PN16	PE 710 PN16	710	\N	581.000	710.000	10	16	11	64.5	\N
5527	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN16	 280 PN16	PE 280 PN16	280	\N	229.200	280.000	10	16	11	25.4	\N
5501	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE		PE	\N	\N	\N	\N	10	\N	\N	\N	\N
7001	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 25 PN20	 25 PN20	PE 25 PN20	25	\N	19.400	25.000	10	20	9	2.8	\N
7002	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 32 PN20	 32 PN20	PE 32 PN20	32	\N	24.800	32.000	10	20	9	3.6	\N
7003	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN20	 40 PN20	PE 40 PN20	40	\N	31.000	40.000	10	20	9	4.5	\N
7004	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN20	 50 PN20	PE 50 PN20	50	\N	38.800	50.000	10	20	9	5.6	\N
7005	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN20	 63 PN20	PE 63 PN20	63	\N	48.800	63.000	10	20	9	7.1	\N
7006	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN20	 75 PN20	PE 75 PN20	75	\N	58.200	75.000	10	20	9	8.4	\N
5503	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN16	 110 PN16	PE 110 PN16	110	90	90.000	110.000	10	16	11	10.0	\N
7007	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN20	 90 PN20	PE 90 PN20	90	\N	69.800	90.000	10	20	9	10.1	\N
7008	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN20	 110 PN20	PE 110 PN20	110	\N	85.400	110.000	10	20	9	12.3	\N
7009	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN20	 125 PN20	PE 125 PN20	125	\N	97.000	125.000	10	20	9	14.0	\N
7010	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN20	 140 PN20	PE 140 PN20	140	\N	108.600	140.000	10	20	9	15.7	\N
7011	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN20	 160 PN20	PE 160 PN20	160	\N	124.200	160.000	10	20	9	17.9	\N
7012	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN20	 180 PN20	PE 180 PN20	180	\N	139.800	180.000	10	20	9	20.1	\N
7040	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 25 PN12.5	 25 PN12.5	PE 25 PN12.5	25	\N	21.000	25.000	10	12.5	13.5999999999999996	2.0	\N
7041	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN12.5	 450 PN12.5	PE 450 PN12.5	450	\N	383.800	450.000	10	12.5	13.5999999999999996	33.1	\N
5550	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80		PE80	\N	\N	\N	\N	8	\N	\N	\N	\N
5551	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 50 PN16	 50 PN16	PE80 50 PN16	50	\N	38.800	50.000	8	16	9	5.6	\N
5552	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 63 PN16	 63 PN16	PE80 63 PN16	63	\N	48.800	63.000	8	16	9	7.1	\N
7042	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 500 PN12.5	 500 PN12.5	PE 500 PN12.5	500	\N	426.400	500.000	10	12.5	13.5999999999999996	36.8	\N
7043	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 560 PN12.5	 560 PN12.5	PE 560 PN12.5	560	\N	477.600	560.000	10	12.5	13.5999999999999996	41.2	\N
7044	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 630 PN12.5	 630 PN12.5	PE 630 PN12.5	630	\N	537.400	630.000	10	12.5	13.5999999999999996	46.3	\N
5372	t	F		F	Fonte		Fontă	\N	\N	\N	F 800	 800	F 800	800	800	800.000	\N	4	\N	\N	\N	\N
5373	t	F		F	Fonte		Fontă	\N	\N	\N	F 90	 90	F 90	90	90	90.000	\N	4	\N	\N	\N	\N
5400	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE			\N	\N	\N	\N	4	\N	\N	\N	\N
5401	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 100	 100	 100	100	100	100.000	\N	4	\N	\N	\N	\N
5402	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 125	 125	 125	125	125	125.000	\N	4	\N	\N	\N	\N
5403	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 150	 150	 150	150	150	150.000	\N	4	\N	\N	\N	\N
5404	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 200	 200	 200	200	200	200.000	\N	4	\N	\N	\N	\N
5405	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 250	 250	 250	250	250	250.000	\N	4	\N	\N	\N	\N
5406	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 300	 300	 300	300	300	300.000	\N	4	\N	\N	\N	\N
5407	t	FAE			Fonte auto-étanche			\N	\N	\N	FAE 400	 400	 400	400	400	400.000	\N	4	\N	\N	\N	\N
5600	t	PEX		PEX	Polyéthylène réticulé		Polietilenă reticulată	\N	\N	\N	PEX		PEX	\N	\N	\N	\N	10	\N	\N	\N	\N
5601	t	PEX		PEX	Polyéthylène réticulé		Polietilenă reticulată	\N	\N	\N	PEX 63	 63	PEX 63	63	50	50.000	63.000	10	\N	\N	\N	\N
5602	t	PEX		PEX	Polyéthylène réticulé		Polietilenă reticulată	\N	\N	\N	PEX 90	 90	PEX 90	90	75	75.000	90.000	10	\N	\N	\N	\N
5603	t	PEX		PEX	Polyéthylène réticulé		Polietilenă reticulată	\N	\N	\N	PEX 160	 160	PEX 160	160	\N	\N	160.000	10	\N	\N	\N	\N
5651	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL		PL	\N	\N	\N	\N	0	\N	\N	\N	\N
5652	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 0.2	 0.2	PL 0.2	0.2	\N	\N	20.000	0	\N	\N	\N	\N
5653	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 0.75"	 0.75"	PL 0.75"	0.75"	20	20.400	25.000	0	\N	\N	\N	\N
5101	t	AC		OL	Acier		Oţel	\N	\N	\N	AC		OL	\N	\N	\N	\N	11	\N	\N	\N	\N
5102	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 100	 100	OL 100	100	100	100.000	114.000	11	\N	\N	\N	\N
5104	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 125	 125	OL 125	125	125	125.000	140.000	11	\N	\N	\N	\N
5105	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 150	 150	OL 150	150	150	150.000	168.000	11	\N	\N	\N	\N
5106	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 175	 175	OL 175	175	175	175.000	194.000	11	\N	\N	\N	\N
5108	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 200	 200	OL 200	200	200	200.000	219.000	11	\N	\N	\N	\N
5109	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 250	 250	OL 250	250	250	250.000	273.000	11	\N	\N	\N	\N
5110	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 300	 300	OL 300	300	300	300.000	323.000	11	\N	\N	\N	\N
5111	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 400	 400	OL 400	400	400	400.000	406.400	11	\N	\N	\N	\N
5112	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 50	 50	OL 50	50	50	50.000	60.300	11	\N	\N	\N	\N
5113	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 500	 500	OL 500	500	500	500.000	508.000	11	\N	\N	\N	\N
5115	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 600	 600	OL 600	600	600	600.000	610.000	11	\N	\N	\N	\N
5116	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 65	 65	OL 65	65	65	65.000	76.000	11	\N	\N	\N	\N
5119	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 80	 80	OL 80	80	80	80.000	89.000	11	\N	\N	\N	\N
5120	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 800	 800	OL 800	800	800	800.000	\N	11	\N	\N	\N	\N
5121	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 1000	 1000	OL 1000	1000	1000	1000.000	\N	11	\N	\N	\N	\N
5122	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 1200	 1200	OL 1200	1200	1200	1200.000	\N	11	\N	\N	\N	\N
5123	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 350	 350	OL 350	350	350	350.000	355.000	11	\N	\N	\N	\N
5124	t	AC		OL	Acier		Oţel	\N	\N	\N	AC 1.5"	 1.5"	OL 1.5"	1.5"	40	40.000	48.000	11	\N	\N	\N	\N
5151	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG		OLG	\N	\N	\N	\N	11	\N	\N	\N	\N
5152	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 0.5"	 0.5"	OLG 0.5"	0.5"	15	16.000	\N	11	\N	\N	\N	\N
5153	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 0.75"	 0.75"	OLG 0.75"	0.75"	20	21.600	\N	11	\N	\N	\N	\N
5155	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 1"	 1"	OLG 1"	1"	25	27.200	\N	11	\N	\N	\N	\N
5156	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 100	 100	OLG 100	100	100	105.300	\N	11	\N	\N	\N	\N
5157	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 1.25"	 1.25"	OLG 1.25"	1.25"	32	35.900	\N	11	\N	\N	\N	\N
5158	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 1.5"	 1.5"	OLG 1.5"	1.5"	40	41.800	\N	11	\N	\N	\N	\N
5159	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 2"	 2"	OLG 2"	2"	50	53.000	\N	11	\N	\N	\N	\N
5160	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 2.5"	 2.5"	OLG 2.5"	2.5"	70	68.800	\N	11	\N	\N	\N	\N
5170	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 3"	 3"	OLG 3"	3"	80	80.800	\N	11	\N	\N	\N	\N
5171	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 4"	 4"	OLG 4"	4"	100	105.300	\N	11	\N	\N	\N	\N
5172	t	ACG		OLG	Acier galvanisé		Oţel Galvanizat	\N	\N	\N	ACG 80	 80	OLG 80	80	80	80.800	\N	11	\N	\N	\N	\N
5201	t	ACI		OLI	Acier inoxydable		Oţel Inoxidabil	\N	\N	\N	ACI 100	 100	OLI 100	100	100	100.000	\N	11	\N	\N	\N	\N
5202	t	ACI		OLI	Acier inoxydable		Oţel Inoxidabil	\N	\N	\N	ACI 125	 125	OLI 125	125	125	125.000	\N	11	\N	\N	\N	\N
5203	t	ACI		OLI	Acier inoxydable		Oţel Inoxidabil	\N	\N	\N	ACI 150	 150	OLI 150	150	150	150.000	\N	11	\N	\N	\N	\N
5204	t	ACI		OLI	Acier inoxydable		Oţel Inoxidabil	\N	\N	\N	ACI 200	 200	OLI 200	200	200	200.000	\N	11	\N	\N	\N	\N
5205	t	ACI		OLI	Acier inoxydable		Oţel Inoxidabil	\N	\N	\N	ACI 250	 250	OLI 250	250	250	250.000	\N	11	\N	\N	\N	\N
5251	t	ACPR			Acier prestolic			\N	\N	\N	ACPR			\N	\N	\N	\N	11	\N	\N	\N	\N
5252	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 100	 100	 100	100	100	100.000	\N	11	\N	\N	\N	\N
5253	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 125	 125	 125	125	125	125.000	\N	11	\N	\N	\N	\N
5254	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 150	 150	 150	150	150	150.000	\N	11	\N	\N	\N	\N
5255	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 200	 200	 200	200	200	200.000	\N	11	\N	\N	\N	\N
5256	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 300	 300	 300	300	300	300.000	\N	11	\N	\N	\N	\N
5257	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 50	 50	 50	50	50	50.000	\N	11	\N	\N	\N	\N
5258	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 60	 60	 60	60	60	60.000	\N	11	\N	\N	\N	\N
5259	t	ACPR			Acier prestolic			\N	\N	\N	ACPR 80	 80	 80	80	80	80.000	\N	11	\N	\N	\N	\N
5301	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU		CU	\N	\N	\N	\N	0	\N	\N	\N	\N
5302	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 1"	 1"	CU 1"	1"	25	25.000	28.000	0	\N	\N	\N	\N
5303	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 10	 10	CU 10	10	10	10.000	12.000	0	\N	\N	\N	\N
5304	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 12	 12	CU 12	12	10	10.000	12.000	0	\N	\N	\N	\N
5305	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 1.25"	 1.25"	CU 1.25"	1.25"	32	32.000	35.000	0	\N	\N	\N	\N
5306	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 15	 15	CU 15	15	13	13.000	15.000	0	\N	\N	\N	\N
5307	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 17	 17	CU 17	17	15	16.000	18.000	0	\N	\N	\N	\N
5308	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 22/19	 22/19	CU 22/19	22/19	20	20.000	22.000	0	\N	\N	\N	\N
5309	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 25	 25	CU 25	25	25	25.000	28.000	0	\N	\N	\N	\N
5310	t	CU		CU	Cuivre		Cupru	\N	\N	\N	CU 32	 32	CU 32	32	32	32.000	35.000	0	\N	\N	\N	\N
5351	t	F		F	Fonte		Fontă	\N	\N	\N	F		F	\N	\N	\N	\N	4	\N	\N	\N	\N
5352	t	F		F	Fonte		Fontă	\N	\N	\N	F 100	 100	F 100	100	100	100.000	\N	4	\N	\N	\N	\N
5353	t	F		F	Fonte		Fontă	\N	\N	\N	F 110	 110	F 110	110	110	110.000	\N	4	\N	\N	\N	\N
5354	t	F		F	Fonte		Fontă	\N	\N	\N	F 120	 120	F 120	120	120	120.000	\N	4	\N	\N	\N	\N
5355	t	F		F	Fonte		Fontă	\N	\N	\N	F 125	 125	F 125	125	125	125.000	\N	4	\N	\N	\N	\N
5356	t	F		F	Fonte		Fontă	\N	\N	\N	F 150	 150	F 150	150	150	150.000	\N	4	\N	\N	\N	\N
5357	t	F		F	Fonte		Fontă	\N	\N	\N	F 175	 175	F 175	175	175	175.000	\N	4	\N	\N	\N	\N
5358	t	F		F	Fonte		Fontă	\N	\N	\N	F 180	 180	F 180	180	180	180.000	\N	4	\N	\N	\N	\N
5359	t	F		F	Fonte		Fontă	\N	\N	\N	F 200	 200	F 200	200	200	200.000	\N	4	\N	\N	\N	\N
5360	t	F		F	Fonte		Fontă	\N	\N	\N	F 250	 250	F 250	250	250	250.000	\N	4	\N	\N	\N	\N
5361	t	F		F	Fonte		Fontă	\N	\N	\N	F 300	 300	F 300	300	300	300.000	\N	4	\N	\N	\N	\N
5362	t	F		F	Fonte		Fontă	\N	\N	\N	F 350	 350	F 350	350	350	350.000	\N	4	\N	\N	\N	\N
5363	t	F		F	Fonte		Fontă	\N	\N	\N	F 375	 375	F 375	375	375	375.000	\N	4	\N	\N	\N	\N
5364	t	F		F	Fonte		Fontă	\N	\N	\N	F 400	 400	F 400	400	400	400.000	\N	4	\N	\N	\N	\N
5365	t	F		F	Fonte		Fontă	\N	\N	\N	F 50	 50	F 50	50	50	50.000	\N	4	\N	\N	\N	\N
5366	t	F		F	Fonte		Fontă	\N	\N	\N	F 500	 500	F 500	500	500	500.000	\N	4	\N	\N	\N	\N
5367	t	F		F	Fonte		Fontă	\N	\N	\N	F 60	 60	F 60	60	60	60.000	\N	4	\N	\N	\N	\N
5368	t	F		F	Fonte		Fontă	\N	\N	\N	F 600	 600	F 600	600	600	600.000	\N	4	\N	\N	\N	\N
5369	t	F		F	Fonte		Fontă	\N	\N	\N	F 65	 65	F 65	65	65	65.000	\N	4	\N	\N	\N	\N
5370	t	F		F	Fonte		Fontă	\N	\N	\N	F 70	 70	F 70	70	70	70.000	\N	4	\N	\N	\N	\N
5371	t	F		F	Fonte		Fontă	\N	\N	\N	F 80	 80	F 80	80	80	80.000	\N	4	\N	\N	\N	\N
7048	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN10	 40 PN10	PE 40 PN10	40	\N	35.200	40.000	10	10	17	2.4	\N
7049	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN10	 50 PN10	PE 50 PN10	50	\N	44.000	50.000	10	10	17	3.0	\N
7050	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN10	 63 PN10	PE 63 PN10	63	\N	55.400	63.000	10	10	17	3.8	\N
7051	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN10	 75 PN10	PE 75 PN10	75	\N	66.000	75.000	10	10	17	4.5	\N
7052	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN10	 90 PN10	PE 90 PN10	90	\N	79.200	90.000	10	10	17	5.4	\N
7053	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN10	 110 PN10	PE 110 PN10	110	\N	96.800	110.000	10	10	17	6.6	\N
7054	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN10	 125 PN10	PE 125 PN10	125	\N	110.200	125.000	10	10	17	7.4	\N
7055	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN10	 140 PN10	PE 140 PN10	140	\N	123.400	140.000	10	10	17	8.3	\N
7056	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN10	 160 PN10	PE 160 PN10	160	\N	141.000	160.000	10	10	17	9.5	\N
7057	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN10	 180 PN10	PE 180 PN10	180	\N	158.600	180.000	10	10	17	10.7	\N
7058	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN10	 200 PN10	PE 200 PN10	200	\N	176.200	200.000	10	10	17	11.9	\N
7059	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN10	 225 PN10	PE 225 PN10	225	\N	198.200	225.000	10	10	17	13.4	\N
7060	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN10	 250 PN10	PE 250 PN10	250	\N	220.400	250.000	10	10	17	14.8	\N
7061	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN10	 280 PN10	PE 280 PN10	280	\N	246.800	280.000	10	10	17	16.6	\N
7062	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN10	 315 PN10	PE 315 PN10	315	\N	277.600	315.000	10	10	17	18.7	\N
7063	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN10	 355 PN10	PE 355 PN10	355	\N	312.800	355.000	10	10	17	21.1	\N
7064	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN10	 400 PN10	PE 400 PN10	400	\N	352.600	400.000	10	10	17	23.7	\N
7065	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN10	 450 PN10	PE 450 PN10	450	\N	396.600	450.000	10	10	17	26.7	\N
7066	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 500 PN10	 500 PN10	PE 500 PN10	500	\N	440.600	500.000	10	10	17	29.7	\N
7067	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 560 PN10	 560 PN10	PE 560 PN10	560	\N	493.600	560.000	10	10	17	33.2	\N
5654	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 1"	 1"	PL 1"	1"	32	32.600	40.000	0	\N	\N	\N	\N
5655	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 1.25"	 1.25"	PL 1.25"	1.25"	40	40.800	50.000	0	\N	\N	\N	\N
5656	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 1.5"	 1.5"	PL 1.5"	1.5"	50	51.400	63.000	0	\N	\N	\N	\N
5657	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 2"	 2"	PL 2"	2"	60	61.400	75.000	0	\N	\N	\N	\N
5658	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 20	 20	PL 20	20	15	16.000	20.000	0	\N	\N	\N	\N
5659	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 25	 25	PL 25	25	20	20.400	25.000	0	\N	\N	\N	\N
5660	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 2.5"	 2.5"	PL 2.5"	2.5"	75	73.600	90.000	0	\N	\N	\N	\N
5661	t	PL		PL	Plastique		Plastic	\N	\N	\N	PL 32	 32	PL 32	32	25	26.200	32.000	0	\N	\N	\N	\N
5700	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC		PVC	\N	\N	\N	\N	6	\N	\N	\N	\N
5701	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 100	 100	PVC 100	100	\N	\N	100.000	6	\N	\N	\N	\N
5702	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 120	 120	PVC 120	120	\N	\N	120.000	6	\N	\N	\N	\N
5703	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 125	 125	PVC 125	125	\N	\N	125.000	6	\N	\N	\N	\N
5704	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 140	 140	PVC 140	140	125	125.000	140.000	6	\N	\N	\N	\N
5705	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 150	 150	PVC 150	150	\N	\N	150.000	6	\N	\N	\N	\N
5706	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 160	 160	PVC 160	160	150	150.000	160.000	6	\N	\N	\N	\N
5707	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 20	 20	PVC 20	20	15	15.400	20.000	6	\N	\N	\N	\N
5708	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 250	 250	PVC 250	250	225	225.000	250.000	6	\N	\N	\N	\N
5709	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 600	 600	PVC 600	600	\N	\N	600.000	6	\N	\N	\N	\N
5710	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 75	 75	PVC 75	75	65	65.000	75.000	6	\N	\N	\N	\N
5711	t	PVC		PVC	Chlorure de polyvinyle		Policlorură de vinil	\N	\N	\N	PVC 63	 63	PVC 63	63	\N	\N	63.000	6	\N	\N	\N	\N
5751	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 100	 100	AZBO 100	100	100	100.000	125.000	2	\N	\N	\N	\N
5753	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 125	 125	AZBO 125	125	125	125.000	153.000	2	\N	\N	\N	\N
5754	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 150	 150	AZBO 150	150	150	150.000	182.000	2	\N	\N	\N	\N
5756	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 175	 175	AZBO 175	175	175	175.000	\N	2	\N	\N	\N	\N
5758	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 200	 200	AZBO 200	200	200	200.000	240.000	2	\N	\N	\N	\N
5759	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 250	 250	AZBO 250	250	250	250.000	300.000	2	\N	\N	\N	\N
5761	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 300	 300	AZBO 300	300	300	300.000	360.000	2	\N	\N	\N	\N
5762	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 50	 50	AZBO 50	50	50	50.000	\N	2	\N	\N	\N	\N
5763	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 80	 80	AZBO 80	80	80	80.000	100.000	2	\N	\N	\N	\N
5764	t	TAC		AZBO	Amiante Ciment		Azbociment	\N	\N	\N	TAC 600	 600	AZBO 600	600	600	600.000	720.000	2	\N	\N	\N	\N
5800	t	TC		Cim	Tuyau Ciment		Ciment	\N	\N	\N	TC		Cim	\N	\N	\N	\N	3	\N	\N	\N	\N
5801	t	TC		Cim	Tuyau Ciment		Ciment	\N	\N	\N	TC 20	 20	Cim 20	20	20	\N	\N	3	\N	\N	\N	\N
5899	t			PREMO	Béton précontraint		Beton precomprimat	\N	\N	\N			PREMO	\N	\N	\N	\N	\N	\N	\N	\N	\N
5900	t			PREMO	Béton précontraint		Beton precomprimat	\N	\N	\N	 500	 500	PREMO 500	500	500	\N	\N	\N	\N	\N	\N	\N
5901	t			PREMO	Béton précontraint		Beton precomprimat	\N	\N	\N	 600	 600	PREMO 600	600	600	\N	\N	\N	\N	\N	\N	\N
5902	t			PREMO	Béton précontraint		Beton precomprimat	\N	\N	\N	 800	 800	PREMO 800	800	800	\N	\N	\N	\N	\N	\N	\N
7030	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN8	 63 PN8	PE 63 PN8	63	\N	57.000	63.000	10	8	21	3.0	\N
7031	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN8	 75 PN8	PE 75 PN8	75	\N	67.800	75.000	10	8	21	3.6	\N
7032	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN8	 90 PN8	PE 90 PN8	90	\N	81.400	90.000	10	8	21	4.3	\N
7036	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN8	 50 PN8	PE 50 PN8	50	\N	45.200	50.000	10	8	21	2.4	\N
7037	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 500 PN6	 500 PN6	PE 500 PN6	500	\N	461.800	500.000	10	6	26	19.1	\N
7038	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 560 PN6	 560 PN6	PE 560 PN6	560	\N	517.200	560.000	10	6	26	21.4	\N
7039	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 630 PN6	 630 PN6	PE 630 PN6	630	\N	581.800	630.000	10	6	26	24.1	\N
7068	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 630 PN10	 630 PN10	PE 630 PN10	630	\N	555.200	630.000	10	10	17	37.4	\N
7069	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN8	 180 PN8	PE 180 PN8	180	\N	162.800	180.000	10	8	21	8.6	\N
7070	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN8	 200 PN8	PE 200 PN8	200	\N	180.800	200.000	10	8	21	9.6	\N
7071	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN8	 225 PN8	PE 225 PN8	225	\N	203.400	225.000	10	8	21	10.8	\N
7072	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN8	 250 PN8	PE 250 PN8	250	\N	226.200	250.000	10	8	21	11.9	\N
7073	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN6	 40 PN6	PE 40 PN6	40	\N	36.000	40.000	10	6	26	2.0	\N
7074	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN6	 315 PN6	PE 315 PN6	315	\N	290.800	315.000	10	6	26	12.1	\N
7075	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN6	 355 PN6	PE 355 PN6	355	\N	327.800	355.000	10	6	26	13.6	\N
7076	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN6	 400 PN6	PE 400 PN6	400	\N	369.400	400.000	10	6	26	15.3	\N
7077	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN6	 450 PN6	PE 450 PN6	450	\N	415.600	450.000	10	6	26	17.2	\N
7078	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN8	 110 PN8	PE 110 PN8	110	\N	99.400	110.000	10	8	21	5.3	\N
7079	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN8	 125 PN8	PE 125 PN8	125	\N	113.000	125.000	10	8	21	6.0	\N
7080	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN8	 140 PN8	PE 140 PN8	140	\N	126.600	140.000	10	8	21	6.7	\N
7081	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN8	 160 PN8	PE 160 PN8	160	\N	144.600	160.000	10	8	21	7.7	\N
7082	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN8	 280 PN8	PE 280 PN8	280	\N	253.200	280.000	10	8	21	13.4	\N
7083	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN8	 315 PN8	PE 315 PN8	315	\N	285.000	315.000	10	8	21	15.0	\N
7084	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN6	 140 PN6	PE 140 PN6	140	\N	129.200	140.000	10	6	26	5.4	\N
7085	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN6	 50 PN6	PE 50 PN6	50	\N	46.000	50.000	10	6	26	2.0	\N
7086	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN6	 63 PN6	PE 63 PN6	63	\N	58.000	63.000	10	6	26	2.5	\N
7087	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN6	 75 PN6	PE 75 PN6	75	\N	69.200	75.000	10	6	26	2.9	\N
7088	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN6	 90 PN6	PE 90 PN6	90	\N	83.000	90.000	10	6	26	3.5	\N
7089	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN6	 110 PN6	PE 110 PN6	110	\N	101.600	110.000	10	6	26	4.2	\N
7090	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN6	 125 PN6	PE 125 PN6	125	\N	115.400	125.000	10	6	26	4.8	\N
7091	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN6	 160 PN6	PE 160 PN6	160	\N	147.600	160.000	10	6	26	6.2	\N
7092	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN6	 180 PN6	PE 180 PN6	180	\N	166.200	180.000	10	6	26	6.9	\N
7093	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN6	 200 PN6	PE 200 PN6	200	\N	184.600	200.000	10	6	26	7.7	\N
7094	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN6	 225 PN6	PE 225 PN6	225	\N	207.800	225.000	10	6	26	8.6	\N
7095	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN6	 250 PN6	PE 250 PN6	250	\N	230.800	250.000	10	6	26	9.6	\N
7096	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN6	 280 PN6	PE 280 PN6	280	\N	258.600	280.000	10	6	26	10.7	\N
7097	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 710 PN6	 710 PN6	PE 710 PN6	710	\N	655.600	710.000	10	6	26	27.2	\N
7098	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN8	 355 PN8	PE 355 PN8	355	\N	321.200	355.000	10	8	21	16.9	\N
7099	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN8	 400 PN8	PE 400 PN8	400	\N	361.800	400.000	10	8	21	19.1	\N
7100	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN8	 450 PN8	PE 450 PN8	450	\N	407.000	450.000	10	8	21	21.5	\N
7101	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 500 PN8	 500 PN8	PE 500 PN8	500	\N	452.200	500.000	10	8	21	23.9	\N
7102	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 560 PN8	 560 PN8	PE 560 PN8	560	\N	506.600	560.000	10	8	21	26.7	\N
7103	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 630 PN8	 630 PN8	PE 630 PN8	630	\N	570.000	630.000	10	8	21	30.0	\N
7104	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 710 PN8	 710 PN8	PE 710 PN8	710	\N	642.200	710.000	10	8	21	33.9	\N
7105	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN25	 110 PN25	PE 110 PN25	110	\N	79.800	110.000	10	25	7.40000000000000036	15.1	\N
7106	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN25	 125 PN25	PE 125 PN25	125	\N	90.800	125.000	10	25	7.40000000000000036	17.1	\N
7107	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN25	 140 PN25	PE 140 PN25	140	\N	101.600	140.000	10	25	7.40000000000000036	19.2	\N
7108	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN25	 160 PN25	PE 160 PN25	160	\N	116.200	160.000	10	25	7.40000000000000036	21.9	\N
7109	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN25	 180 PN25	PE 180 PN25	180	\N	130.800	180.000	10	25	7.40000000000000036	24.6	\N
7110	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN25	 200 PN25	PE 200 PN25	200	\N	145.200	200.000	10	25	7.40000000000000036	27.4	\N
7111	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN25	 225 PN25	PE 225 PN25	225	\N	163.400	225.000	10	25	7.40000000000000036	30.8	\N
7112	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN25	 250 PN25	PE 250 PN25	250	\N	181.600	250.000	10	25	7.40000000000000036	34.2	\N
7113	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN25	 280 PN25	PE 280 PN25	280	\N	203.400	280.000	10	25	7.40000000000000036	38.3	\N
7114	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN25	 315 PN25	PE 315 PN25	315	\N	228.800	315.000	10	25	7.40000000000000036	43.1	\N
7115	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN25	 355 PN25	PE 355 PN25	355	\N	258.000	355.000	10	25	7.40000000000000036	48.5	\N
7116	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN25	 400 PN25	PE 400 PN25	400	\N	290.600	400.000	10	25	7.40000000000000036	54.7	\N
7117	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 450 PN25	 450 PN25	PE 450 PN25	450	\N	327.000	450.000	10	25	7.40000000000000036	61.5	\N
7118	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 710 PN10	 710 PN10	PE 710 PN10	710	\N	625.800	710.000	10	10	17	42.1	\N
7119	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 140 PN12.5	 140 PN12.5	PE 140 PN12.5	140	\N	119.400	140.000	10	12.5	13.5999999999999996	10.3	\N
7120	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 160 PN12.5	 160 PN12.5	PE 160 PN12.5	160	\N	136.600	160.000	10	12.5	13.5999999999999996	11.7	\N
7121	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 180 PN12.5	 180 PN12.5	PE 180 PN12.5	180	\N	153.400	180.000	10	12.5	13.5999999999999996	13.3	\N
7122	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 200 PN12.5	 200 PN12.5	PE 200 PN12.5	200	\N	170.600	200.000	10	12.5	13.5999999999999996	14.7	\N
7123	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 225 PN12.5	 225 PN12.5	PE 225 PN12.5	225	\N	191.800	225.000	10	12.5	13.5999999999999996	16.6	\N
7124	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 250 PN12.5	 250 PN12.5	PE 250 PN12.5	250	\N	213.200	250.000	10	12.5	13.5999999999999996	18.4	\N
7125	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 280 PN12.5	 280 PN12.5	PE 280 PN12.5	280	\N	238.800	280.000	10	12.5	13.5999999999999996	20.6	\N
7126	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 315 PN12.5	 315 PN12.5	PE 315 PN12.5	315	\N	268.600	315.000	10	12.5	13.5999999999999996	23.2	\N
7127	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 355 PN12.5	 355 PN12.5	PE 355 PN12.5	355	\N	302.800	355.000	10	12.5	13.5999999999999996	26.1	\N
7128	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 400 PN12.5	 400 PN12.5	PE 400 PN12.5	400	\N	341.200	400.000	10	12.5	13.5999999999999996	29.4	\N
7129	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 40 PN12.5	 40 PN12.5	PE 40 PN12.5	40	\N	34.000	40.000	10	12.5	13.5999999999999996	3.0	\N
7130	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 32 PN12.5	 32 PN12.5	PE 32 PN12.5	32	\N	27.200	32.000	10	12.5	13.5999999999999996	2.4	\N
7131	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 50 PN12.5	 50 PN12.5	PE 50 PN12.5	50	\N	42.600	50.000	10	12.5	13.5999999999999996	3.7	\N
7132	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 63 PN12.5	 63 PN12.5	PE 63 PN12.5	63	\N	53.600	63.000	10	12.5	13.5999999999999996	4.7	\N
7133	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 75 PN12.5	 75 PN12.5	PE 75 PN12.5	75	\N	63.800	75.000	10	12.5	13.5999999999999996	5.6	\N
7134	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 90 PN12.5	 90 PN12.5	PE 90 PN12.5	90	\N	76.600	90.000	10	12.5	13.5999999999999996	6.7	\N
7135	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 110 PN12.5	 110 PN12.5	PE 110 PN12.5	110	\N	93.800	110.000	10	12.5	13.5999999999999996	8.1	\N
7136	t	PE		PE	Polyéthylène 100		Polietilenă 100	\N	\N	\N	PE 125 PN12.5	 125 PN12.5	PE 125 PN12.5	125	\N	106.600	125.000	10	12.5	13.5999999999999996	9.2	\N
7501	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 32 PN8	 32 PN8	PE80 32 PN8	32	\N	28.000	32.000	8	8	17	2.0	\N
7502	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 500 PN10	 500 PN10	PE80 500 PN10	500	\N	426.400	500.000	8	10	13.5999999999999996	36.8	\N
7503	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 560 PN10	 560 PN10	PE80 560 PN10	560	\N	477.600	560.000	8	10	13.5999999999999996	41.2	\N
7504	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 630 PN10	 630 PN10	PE80 630 PN10	630	\N	537.400	630.000	8	10	13.5999999999999996	46.3	\N
7505	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 710 PN10	 710 PN10	PE80 710 PN10	710	\N	605.600	710.000	8	10	13.5999999999999996	52.2	\N
7506	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 500 PN12.5	 500 PN12.5	PE80 500 PN12.5	500	\N	409.200	500.000	8	12.5	11	45.4	\N
7507	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 560 PN12.5	 560 PN12.5	PE80 560 PN12.5	560	\N	458.400	560.000	8	12.5	11	50.8	\N
7508	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 630 PN12.5	 630 PN12.5	PE80 630 PN12.5	630	\N	515.600	630.000	8	12.5	11	57.2	\N
7509	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 40 PN12.5	 40 PN12.5	PE80 40 PN12.5	40	\N	32.600	40.000	8	12.5	11	3.7	\N
7510	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 50 PN12.5	 50 PN12.5	PE80 50 PN12.5	50	\N	40.800	50.000	8	12.5	11	4.6	\N
7511	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 63 PN12.5	 63 PN12.5	PE80 63 PN12.5	63	\N	51.400	63.000	8	12.5	11	5.8	\N
7512	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 75 PN12.5	 75 PN12.5	PE80 75 PN12.5	75	\N	61.400	75.000	8	12.5	11	6.8	\N
7513	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 90 PN12.5	 90 PN12.5	PE80 90 PN12.5	90	\N	73.600	90.000	8	12.5	11	8.2	\N
7514	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 110 PN12.5	 110 PN12.5	PE80 110 PN12.5	110	\N	90.000	110.000	8	12.5	11	10.0	\N
7515	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 125 PN12.5	 125 PN12.5	PE80 125 PN12.5	125	\N	102.200	125.000	8	12.5	11	11.4	\N
7516	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 140 PN12.5	 140 PN12.5	PE80 140 PN12.5	140	\N	114.600	140.000	8	12.5	11	12.7	\N
7517	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 160 PN12.5	 160 PN12.5	PE80 160 PN12.5	160	\N	130.800	160.000	8	12.5	11	14.6	\N
7518	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 180 PN12.5	 180 PN12.5	PE80 180 PN12.5	180	\N	147.200	180.000	8	12.5	11	16.4	\N
7519	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 200 PN12.5	 200 PN12.5	PE80 200 PN12.5	200	\N	163.600	200.000	8	12.5	11	18.2	\N
7520	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 225 PN12.5	 225 PN12.5	PE80 225 PN12.5	225	\N	184.000	225.000	8	12.5	11	20.5	\N
7521	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 250 PN12.5	 250 PN12.5	PE80 250 PN12.5	250	\N	204.600	250.000	8	12.5	11	22.7	\N
7522	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 280 PN12.5	 280 PN12.5	PE80 280 PN12.5	280	\N	229.200	280.000	8	12.5	11	25.4	\N
7523	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 315 PN12.5	 315 PN12.5	PE80 315 PN12.5	315	\N	257.800	315.000	8	12.5	11	28.6	\N
7524	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 355 PN12.5	 355 PN12.5	PE80 355 PN12.5	355	\N	290.600	355.000	8	12.5	11	32.2	\N
7525	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 400 PN12.5	 400 PN12.5	PE80 400 PN12.5	400	\N	327.400	400.000	8	12.5	11	36.3	\N
7526	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 450 PN12.5	 450 PN12.5	PE80 450 PN12.5	450	\N	368.200	450.000	8	12.5	11	40.9	\N
7527	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 25 PN12.5	 25 PN12.5	PE80 25 PN12.5	25	\N	20.400	25.000	8	12.5	11	2.3	\N
7528	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 450 PN16	 450 PN16	PE80 450 PN16	450	\N	349.400	450.000	8	16	9	50.3	\N
7529	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 500 PN16	 500 PN16	PE80 500 PN16	500	\N	388.400	500.000	8	16	9	55.8	\N
7530	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 315 PN20	 315 PN20	PE80 315 PN20	315	\N	228.800	315.000	8	20	7.40000000000000036	43.1	\N
7531	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 355 PN20	 355 PN20	PE80 355 PN20	355	\N	258.000	355.000	8	20	7.40000000000000036	48.5	\N
7532	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 400 PN20	 400 PN20	PE80 400 PN20	400	\N	290.600	400.000	8	20	7.40000000000000036	54.7	\N
7533	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 32 PN6	 32 PN6	PE80 32 PN6	32	\N	28.000	32.000	8	6	21	2.0	\N
7534	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 50 PN6	 50 PN6	PE80 50 PN6	50	\N	45.200	50.000	8	6	21	2.4	\N
7535	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 32 PN12.5	 32 PN12.5	PE80 32 PN12.5	32	\N	26.000	32.000	8	12.5	11	3.0	\N
7536	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 40 PN20	 40 PN20	PE80 40 PN20	40	\N	29.000	40.000	8	20	7.40000000000000036	5.5	\N
7537	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 50 PN20	 50 PN20	PE80 50 PN20	50	\N	36.200	50.000	8	20	7.40000000000000036	6.9	\N
7538	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 63 PN20	 63 PN20	PE80 63 PN20	63	\N	45.800	63.000	8	20	7.40000000000000036	8.6	\N
7539	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 75 PN20	 75 PN20	PE80 75 PN20	75	\N	54.400	75.000	8	20	7.40000000000000036	10.3	\N
7540	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 90 PN20	 90 PN20	PE80 90 PN20	90	\N	65.400	90.000	8	20	7.40000000000000036	12.3	\N
7541	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 110 PN20	 110 PN20	PE80 110 PN20	110	\N	79.800	110.000	8	20	7.40000000000000036	15.1	\N
7542	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 125 PN20	 125 PN20	PE80 125 PN20	125	\N	90.800	125.000	8	20	7.40000000000000036	17.1	\N
7543	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 140 PN20	 140 PN20	PE80 140 PN20	140	\N	101.600	140.000	8	20	7.40000000000000036	19.2	\N
7544	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 160 PN20	 160 PN20	PE80 160 PN20	160	\N	116.200	160.000	8	20	7.40000000000000036	21.9	\N
7545	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 180 PN20	 180 PN20	PE80 180 PN20	180	\N	130.800	180.000	8	20	7.40000000000000036	24.6	\N
7546	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 200 PN20	 200 PN20	PE80 200 PN20	200	\N	145.200	200.000	8	20	7.40000000000000036	27.4	\N
7547	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 225 PN20	 225 PN20	PE80 225 PN20	225	\N	163.400	225.000	8	20	7.40000000000000036	30.8	\N
7548	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 450 PN20	 450 PN20	PE80 450 PN20	450	\N	327.000	450.000	8	20	7.40000000000000036	61.5	\N
7549	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 40 PN10	 40 PN10	PE80 40 PN10	40	\N	34.000	40.000	8	10	13.5999999999999996	3.0	\N
7550	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 50 PN10	 50 PN10	PE80 50 PN10	50	\N	42.600	50.000	8	10	13.5999999999999996	3.7	\N
7551	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 63 PN10	 63 PN10	PE80 63 PN10	63	\N	53.600	63.000	8	10	13.5999999999999996	4.7	\N
7552	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 75 PN10	 75 PN10	PE80 75 PN10	75	\N	63.800	75.000	8	10	13.5999999999999996	5.6	\N
7553	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 25 PN8	 25 PN8	PE80 25 PN8	25	\N	21.000	25.000	8	8	17	2.0	\N
7554	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 32 PN10	 32 PN10	PE80 32 PN10	32	\N	27.200	32.000	8	10	13.5999999999999996	2.4	\N
7555	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 90 PN10	 90 PN10	PE80 90 PN10	90	\N	76.600	90.000	8	10	13.5999999999999996	6.7	\N
7556	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 110 PN10	 110 PN10	PE80 110 PN10	110	\N	93.800	110.000	8	10	13.5999999999999996	8.1	\N
7557	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 125 PN10	 125 PN10	PE80 125 PN10	125	\N	106.600	125.000	8	10	13.5999999999999996	9.2	\N
7558	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 140 PN10	 140 PN10	PE80 140 PN10	140	\N	119.400	140.000	8	10	13.5999999999999996	10.3	\N
7559	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 40 PN8	 40 PN8	PE80 40 PN8	40	\N	35.200	40.000	8	8	17	2.4	\N
7560	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 160 PN10	 160 PN10	PE80 160 PN10	160	\N	136.400	160.000	8	10	13.5999999999999996	11.8	\N
7561	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 180 PN10	 180 PN10	PE80 180 PN10	180	\N	153.400	180.000	8	10	13.5999999999999996	13.3	\N
7562	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 200 PN10	 200 PN10	PE80 200 PN10	200	\N	170.600	200.000	8	10	13.5999999999999996	14.7	\N
7563	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 225 PN10	 225 PN10	PE80 225 PN10	225	\N	191.800	225.000	8	10	13.5999999999999996	16.6	\N
7564	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 250 PN10	 250 PN10	PE80 250 PN10	250	\N	213.200	250.000	8	10	13.5999999999999996	18.4	\N
7565	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 280 PN10	 280 PN10	PE80 280 PN10	280	\N	238.800	280.000	8	10	13.5999999999999996	20.6	\N
7566	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 315 PN10	 315 PN10	PE80 315 PN10	315	\N	268.600	315.000	8	10	13.5999999999999996	23.2	\N
7567	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 355 PN10	 355 PN10	PE80 355 PN10	355	\N	302.800	355.000	8	10	13.5999999999999996	26.1	\N
7568	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 400 PN10	 400 PN10	PE80 400 PN10	400	\N	341.200	400.000	8	10	13.5999999999999996	29.4	\N
7569	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 450 PN10	 450 PN10	PE80 450 PN10	450	\N	383.800	450.000	8	10	13.5999999999999996	33.1	\N
7570	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 25 PN10	 25 PN10	PE80 25 PN10	25	\N	21.000	25.000	8	10	13.5999999999999996	2.0	\N
7571	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 40 PN16	 40 PN16	PE80 40 PN16	40	\N	31.000	40.000	8	16	9	4.5	\N
7572	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 75 PN16	 75 PN16	PE80 75 PN16	75	\N	58.200	75.000	8	16	9	8.4	\N
7573	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 90 PN16	 90 PN16	PE80 90 PN16	90	\N	69.800	90.000	8	16	9	10.1	\N
7574	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 110 PN16	 110 PN16	PE80 110 PN16	110	\N	85.400	110.000	8	16	9	12.3	\N
7575	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 125 PN16	 125 PN16	PE80 125 PN16	125	\N	97.000	125.000	8	16	9	14.0	\N
7576	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 140 PN16	 140 PN16	PE80 140 PN16	140	\N	108.600	140.000	8	16	9	15.7	\N
7577	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 160 PN16	 160 PN16	PE80 160 PN16	160	\N	124.200	160.000	8	16	9	17.9	\N
7578	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 180 PN16	 180 PN16	PE80 180 PN16	180	\N	139.800	180.000	8	16	9	20.1	\N
7579	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 200 PN16	 200 PN16	PE80 200 PN16	200	\N	155.200	200.000	8	16	9	22.4	\N
7580	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 225 PN16	 225 PN16	PE80 225 PN16	225	\N	174.600	225.000	8	16	9	25.2	\N
7581	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 250 PN16	 250 PN16	PE80 250 PN16	250	\N	194.200	250.000	8	16	9	27.9	\N
7582	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 280 PN16	 280 PN16	PE80 280 PN16	280	\N	217.400	280.000	8	16	9	31.3	\N
7583	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 315 PN16	 315 PN16	PE80 315 PN16	315	\N	244.600	315.000	8	16	9	35.2	\N
7584	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 355 PN16	 355 PN16	PE80 355 PN16	355	\N	275.600	355.000	8	16	9	39.7	\N
7585	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 400 PN16	 400 PN16	PE80 400 PN16	400	\N	310.600	400.000	8	16	9	44.7	\N
7586	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 250 PN20	 250 PN20	PE80 250 PN20	250	\N	181.600	250.000	8	20	7.40000000000000036	34.2	\N
7587	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 280 PN20	 280 PN20	PE80 280 PN20	280	\N	203.400	280.000	8	20	7.40000000000000036	38.3	\N
7588	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 25 PN6	 25 PN6	PE80 25 PN6	25	\N	21.000	25.000	8	6	21	2.0	\N
7589	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 40 PN6	 40 PN6	PE80 40 PN6	40	\N	36.000	40.000	8	6	21	2.0	\N
7590	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 63 PN6	 63 PN6	PE80 63 PN6	63	\N	57.000	63.000	8	6	21	3.0	\N
7591	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 75 PN6	 75 PN6	PE80 75 PN6	75	\N	67.800	75.000	8	6	21	3.6	\N
7592	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 125 PN6	 125 PN6	PE80 125 PN6	125	\N	113.000	125.000	8	6	21	6.0	\N
7593	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 140 PN6	 140 PN6	PE80 140 PN6	140	\N	126.600	140.000	8	6	21	6.7	\N
7594	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 160 PN6	 160 PN6	PE80 160 PN6	160	\N	144.600	160.000	8	6	21	7.7	\N
7595	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 180 PN6	 180 PN6	PE80 180 PN6	180	\N	162.800	180.000	8	6	21	8.6	\N
7596	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 200 PN6	 200 PN6	PE80 200 PN6	200	\N	180.800	200.000	8	6	21	9.6	\N
7597	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 225 PN6	 225 PN6	PE80 225 PN6	225	\N	203.400	225.000	8	6	21	10.8	\N
7598	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 250 PN6	 250 PN6	PE80 250 PN6	250	\N	226.200	250.000	8	6	21	11.9	\N
7599	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 280 PN6	 280 PN6	PE80 280 PN6	280	\N	253.200	280.000	8	6	21	13.4	\N
7600	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 315 PN6	 315 PN6	PE80 315 PN6	315	\N	285.000	315.000	8	6	21	15.0	\N
7601	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 355 PN6	 355 PN6	PE80 355 PN6	355	\N	321.200	355.000	8	6	21	16.9	\N
7602	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 400 PN6	 400 PN6	PE80 400 PN6	400	\N	361.800	400.000	8	6	21	19.1	\N
7603	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 450 PN6	 450 PN6	PE80 450 PN6	450	\N	407.000	450.000	8	6	21	21.5	\N
7604	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 500 PN6	 500 PN6	PE80 500 PN6	500	\N	452.200	500.000	8	6	21	23.9	\N
7605	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 560 PN6	 560 PN6	PE80 560 PN6	560	\N	506.600	560.000	8	6	21	26.7	\N
7606	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 630 PN6	 630 PN6	PE80 630 PN6	630	\N	570.000	630.000	8	6	21	30.0	\N
7607	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 710 PN6	 710 PN6	PE80 710 PN6	710	\N	642.200	710.000	8	6	21	33.9	\N
7608	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 50 PN8	 50 PN8	PE80 50 PN8	50	\N	44.000	50.000	8	8	17	3.0	\N
7609	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 63 PN8	 63 PN8	PE80 63 PN8	63	\N	55.400	63.000	8	8	17	3.8	\N
7610	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 75 PN8	 75 PN8	PE80 75 PN8	75	\N	66.000	75.000	8	8	17	4.5	\N
7611	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 90 PN8	 90 PN8	PE80 90 PN8	90	\N	79.200	90.000	8	8	17	5.4	\N
7612	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 110 PN8	 110 PN8	PE80 110 PN8	110	\N	96.800	110.000	8	8	17	6.6	\N
7613	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 125 PN8	 125 PN8	PE80 125 PN8	125	\N	110.200	125.000	8	8	17	7.4	\N
7614	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 140 PN8	 140 PN8	PE80 140 PN8	140	\N	123.400	140.000	8	8	17	8.3	\N
7615	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 160 PN8	 160 PN8	PE80 160 PN8	160	\N	141.000	160.000	8	8	17	9.5	\N
7616	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 180 PN8	 180 PN8	PE80 180 PN8	180	\N	158.600	180.000	8	8	17	10.7	\N
7617	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 200 PN8	 200 PN8	PE80 200 PN8	200	\N	176.200	200.000	8	8	17	11.9	\N
7618	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 225 PN8	 225 PN8	PE80 225 PN8	225	\N	198.200	225.000	8	8	17	13.4	\N
7619	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 250 PN8	 250 PN8	PE80 250 PN8	250	\N	220.400	250.000	8	8	17	14.8	\N
7620	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 280 PN8	 280 PN8	PE80 280 PN8	280	\N	246.800	280.000	8	8	17	16.6	\N
7621	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 315 PN8	 315 PN8	PE80 315 PN8	315	\N	277.600	315.000	8	8	17	18.7	\N
7622	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 355 PN8	 355 PN8	PE80 355 PN8	355	\N	312.800	355.000	8	8	17	21.1	\N
7623	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 400 PN8	 400 PN8	PE80 400 PN8	400	\N	352.600	400.000	8	8	17	23.7	\N
7624	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 450 PN8	 450 PN8	PE80 450 PN8	450	\N	396.600	450.000	8	8	17	26.7	\N
7625	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 500 PN8	 500 PN8	PE80 500 PN8	500	\N	440.600	500.000	8	8	17	29.7	\N
7626	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 560 PN8	 560 PN8	PE80 560 PN8	560	\N	493.600	560.000	8	8	17	33.2	\N
7627	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 630 PN8	 630 PN8	PE80 630 PN8	630	\N	555.200	630.000	8	8	17	37.4	\N
7628	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 710 PN8	 710 PN8	PE80 710 PN8	710	\N	625.800	710.000	8	8	17	42.1	\N
7629	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 90 PN6	 90 PN6	PE80 90 PN6	90	\N	81.400	90.000	8	6	21	4.3	\N
7630	t	PE80		PE80	Polyéthylène 80		Polietilenă 80	\N	\N	\N	PE80 110 PN6	 110 PN6	PE80 110 PN6	110	\N	99.400	110.000	8	6	21	5.3	\N
7700	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV	GRP	GRP	\N	\N	\N	\N	\N	\N	\N	\N	\N
7701	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 150 PN10	GRP 150 PN10	GRP 150 PN10	150	150	156.000	168.000	\N	10	\N	6.0	10000
7702	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 200 PN10	GRP 200 PN10	GRP 200 PN10	200	200	206.000	220.000	\N	10	\N	7.0	10000
7703	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 250 PN10	GRP 250 PN10	GRP 250 PN10	250	250	254.000	272.000	\N	10	\N	9.0	10000
7704	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 300 PN10	GRP 300 PN10	GRP 300 PN10	300	300	304.000	324.000	\N	10	\N	10.0	10000
7705	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 350 PN10	GRP 350 PN10	GRP 350 PN10	350	350	352.000	376.000	\N	10	\N	12.0	10000
7706	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 400 PN10	GRP 400 PN10	GRP 400 PN10	400	400	401.000	427.000	\N	10	\N	13.0	10000
7707	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 450 PN10	GRP 450 PN10	GRP 450 PN10	450	450	452.000	478.000	\N	10	\N	13.0	10000
7708	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 500 PN10	GRP 500 PN10	GRP 500 PN10	500	500	504.000	530.000	\N	10	\N	13.0	10000
7709	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 550 PN10	GRP 550 PN10	GRP 550 PN10	550	550	520.000	550.000	\N	10	\N	15.0	10000
7710	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 600 PN10	GRP 600 PN10	GRP 600 PN10	600	600	584.000	616.000	\N	10	\N	16.0	10000
7711	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 650 PN10	GRP 650 PN10	GRP 650 PN10	650	650	616.000	650.000	\N	10	\N	17.0	10000
7712	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 700 PN10	GRP 700 PN10	GRP 700 PN10	700	700	682.000	718.000	\N	10	\N	18.0	10000
7713	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 750 PN10	GRP 750 PN10	GRP 750 PN10	750	750	714.000	752.000	\N	10	\N	19.0	10000
7714	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 800 PN10	GRP 800 PN10	GRP 800 PN10	800	800	780.000	820.000	\N	10	\N	20.0	10000
7715	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 860 PN10	GRP 860 PN10	GRP 860 PN10	860	860	818.000	860.000	\N	10	\N	21.0	10000
7716	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 900 PN10	GRP 900 PN10	GRP 900 PN10	900	900	878.000	924.000	\N	10	\N	23.0	10000
7717	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 960 PN10	GRP 960 PN10	GRP 960 PN10	960	960	912.000	960.000	\N	10	\N	24.0	10000
7718	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1000 PN10	GRP 1000 PN10	GRP 1000 PN10	1000	1000	976.000	1026.000	\N	10	\N	25.0	10000
7719	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1100 PN10	GRP 1100 PN10	GRP 1100 PN10	1100	1100	1045.000	1099.000	\N	10	\N	27.0	10000
7720	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1200 PN10	GRP 1200 PN10	GRP 1200 PN10	1200	1200	1171.000	1229.000	\N	10	\N	29.0	10000
7721	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1280 PN16	GRP 1280 PN16	GRP 1280 PN16	1280	1280	1218.000	1280.000	\N	16	\N	31.0	10000
7722	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1348 PN16	GRP 1348 PN16	GRP 1348 PN16	1348	1348	1284.000	1348.000	\N	16	\N	32.0	10000
7723	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1400 PN16	GRP 1400 PN16	GRP 1400 PN16	1400	1400	1366.000	1434.000	\N	16	\N	34.0	10000
7724	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1500 PN16	GRP 1500 PN16	GRP 1500 PN16	1500	1500	1429.000	1499.000	\N	16	\N	35.0	10000
7725	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 150 PN16	GRP 150 PN16	GRP 150 PN16	150	150	156.000	168.000	\N	16	\N	6.0	10000
7726	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 200 PN16	GRP 200 PN16	GRP 200 PN16	200	200	206.000	220.000	\N	16	\N	7.0	10000
7727	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 250 PN16	GRP 250 PN16	GRP 250 PN16	250	250	254.000	272.000	\N	16	\N	9.0	10000
7728	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 300 PN16	GRP 300 PN16	GRP 300 PN16	300	300	304.000	324.000	\N	16	\N	10.0	10000
7729	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 350 PN16	GRP 350 PN16	GRP 350 PN16	350	350	354.000	376.000	\N	16	\N	11.0	10000
7730	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 400 PN16	GRP 400 PN16	GRP 400 PN16	400	400	403.000	427.000	\N	16	\N	12.0	10000
7731	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 450 PN16	GRP 450 PN16	GRP 450 PN16	450	450	452.000	478.000	\N	16	\N	13.0	10000
7733	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 500 PN16	GRP 500 PN16	GRP 500 PN16	500	500	502.000	530.000	\N	16	\N	14.0	10000
7734	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 550 PN16	GRP 550 PN16	GRP 550 PN16	550	550	522.000	550.000	\N	16	\N	14.0	10000
7735	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 600 PN16	GRP 600 PN16	GRP 600 PN16	600	600	584.000	616.000	\N	16	\N	16.0	10000
7736	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 650 PN16	GRP 650 PN16	GRP 650 PN16	650	650	618.000	650.000	\N	16	\N	16.0	10000
7737	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 700 PN16	GRP 700 PN16	GRP 700 PN16	700	700	684.000	718.000	\N	16	\N	17.0	10000
7738	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 750 PN16	GRP 750 PN16	GRP 750 PN16	750	750	716.000	752.000	\N	16	\N	18.0	10000
7739	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 800 PN16	GRP 800 PN16	GRP 800 PN16	800	800	782.000	820.000	\N	16	\N	19.0	10000
7740	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 860 PN16	GRP 860 PN16	GRP 860 PN16	860	860	820.000	860.000	\N	16	\N	20.0	10000
7741	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 900 PN16	GRP 900 PN16	GRP 900 PN16	900	900	880.000	924.000	\N	16	\N	22.0	10000
7742	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 960 PN16	GRP 960 PN16	GRP 960 PN16	960	960	914.000	960.000	\N	16	\N	23.0	10000
7743	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1000 PN16	GRP 1000 PN16	GRP 1000 PN16	1000	1000	978.000	1026.000	\N	16	\N	24.0	10000
7744	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1100 PN16	GRP 1100 PN16	GRP 1100 PN16	1100	1100	1047.000	1099.000	\N	16	\N	26.0	10000
7745	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1200 PN16	GRP 1200 PN16	GRP 1200 PN16	1200	1200	1171.000	1229.000	\N	16	\N	29.0	10000
7746	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1280 PN16	GRP 1280 PN16	GRP 1280 PN16	1280	1280	1220.000	1280.000	\N	16	\N	30.0	10000
7747	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1348 PN16	GRP 1348 PN16	GRP 1348 PN16	1348	1348	1286.000	1348.000	\N	16	\N	31.0	10000
7748	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1400 PN16	GRP 1400 PN16	GRP 1400 PN16	1400	1400	1368.000	1434.000	\N	16	\N	33.0	10000
7749	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1500 PN16	GRP 1500 PN16	GRP 1500 PN16	1500	1500	1429.000	1499.000	\N	16	\N	35.0	10000
7750	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1535 PN16	GRP 1535 PN16	GRP 1535 PN16	1535	1535	1463.000	1535.000	\N	16	\N	36.0	10000
7751	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1600 PN16	GRP 1600 PN16	GRP 1600 PN16	1600	1600	1562.000	1638.000	\N	16	\N	38.0	10000
7752	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 150 PN20	GRP 150 PN20	GRP 150 PN20	150	150	156.000	168.000	\N	20	\N	6.0	10000
7753	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 200 PN20	GRP 200 PN20	GRP 200 PN20	200	200	206.000	220.000	\N	20	\N	7.0	10000
7754	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 250 PN20	GRP 250 PN20	GRP 250 PN20	250	250	256.000	272.000	\N	20	\N	8.0	10000
7755	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 300 PN20	GRP 300 PN20	GRP 300 PN20	300	300	304.000	324.000	\N	20	\N	10.0	10000
7756	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 350 PN20	GRP 350 PN20	GRP 350 PN20	350	350	354.000	376.000	\N	20	\N	11.0	10000
7757	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 400 PN20	GRP 400 PN20	GRP 400 PN20	400	400	403.000	427.000	\N	20	\N	12.0	10000
7758	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 450 PN20	GRP 450 PN20	GRP 450 PN20	450	450	454.000	478.000	\N	20	\N	12.0	10000
7759	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 500 PN20	GRP 500 PN20	GRP 500 PN20	500	500	504.000	530.000	\N	20	\N	13.0	10000
7760	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 550 PN20	GRP 550 PN20	GRP 550 PN20	550	550	522.000	550.000	\N	20	\N	14.0	10000
7761	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 600 PN20	GRP 600 PN20	GRP 600 PN20	600	600	586.000	616.000	\N	20	\N	15.0	10000
7762	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 650 PN20	GRP 650 PN20	GRP 650 PN20	650	650	618.000	650.000	\N	20	\N	16.0	10000
7763	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 700 PN20	GRP 700 PN20	GRP 700 PN20	700	700	684.000	718.000	\N	20	\N	17.0	10000
7764	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 750 PN20	GRP 750 PN20	GRP 750 PN20	750	750	716.000	752.000	\N	20	\N	18.0	10000
7765	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 800 PN20	GRP 800 PN20	GRP 800 PN20	800	800	782.000	820.000	\N	20	\N	19.0	10000
7766	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 860 PN20	GRP 860 PN20	GRP 860 PN20	860	860	820.000	860.000	\N	20	\N	20.0	10000
7767	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 900 PN20	GRP 900 PN20	GRP 900 PN20	900	900	882.000	924.000	\N	20	\N	21.0	10000
7768	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 960 PN20	GRP 960 PN20	GRP 960 PN20	960	960	918.000	960.000	\N	20	\N	21.0	10000
7769	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1000 PN20	GRP 1000 PN20	GRP 1000 PN20	1000	1000	980.000	1026.000	\N	20	\N	23.0	10000
7770	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1100 PN20	GRP 1100 PN20	GRP 1100 PN20	1100	1100	1049.000	1099.000	\N	20	\N	25.0	10000
7772	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1200 PN20	GRP 1200 PN20	GRP 1200 PN20	1200	1200	1175.000	1229.000	\N	20	\N	27.0	10000
7773	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1280 PN20	GRP 1280 PN20	GRP 1280 PN20	1280	1280	1224.000	1280.000	\N	20	\N	28.0	10000
7774	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1348 PN20	GRP 1348 PN20	GRP 1348 PN20	1348	1348	1284.000	1348.000	\N	20	\N	32.0	10000
7775	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1400 PN20	GRP 1400 PN20	GRP 1400 PN20	1400	1400	1366.000	1434.000	\N	20	\N	34.0	10000
7776	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1500 PN20	GRP 1500 PN20	GRP 1500 PN20	1500	1500	1435.000	1499.000	\N	20	\N	32.0	10000
7777	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1535 PN20	GRP 1535 PN20	GRP 1535 PN20	1535	1535	1469.000	1535.000	\N	20	\N	33.0	10000
7778	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1600 PN20	GRP 1600 PN20	GRP 1600 PN20	1600	1600	1568.000	1638.000	\N	20	\N	35.0	10000
7779	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 150 PN25	GRP 150 PN25	GRP 150 PN25	150	150	156.000	168.000	\N	25	\N	6.0	10000
7780	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 200 PN25	GRP 200 PN25	GRP 200 PN25	200	200	206.000	220.000	\N	25	\N	7.0	10000
7781	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 250 PN25	GRP 250 PN25	GRP 250 PN25	250	250	256.000	272.000	\N	25	\N	8.0	10000
7782	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 300 PN25	GRP 300 PN25	GRP 300 PN25	300	300	304.000	324.000	\N	25	\N	10.0	10000
7783	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 350 PN25	GRP 350 PN25	GRP 350 PN25	350	350	354.000	376.000	\N	25	\N	11.0	10000
7784	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 400 PN25	GRP 400 PN25	GRP 400 PN25	400	400	403.000	427.000	\N	25	\N	12.0	10000
7785	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 450 PN25	GRP 450 PN25	GRP 450 PN25	450	450	454.000	478.000	\N	25	\N	12.0	10000
7786	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 500 PN25	GRP 500 PN25	GRP 500 PN25	500	500	504.000	530.000	\N	25	\N	13.0	10000
7787	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 550 PN25	GRP 550 PN25	GRP 550 PN25	550	550	522.000	550.000	\N	25	\N	14.0	10000
7788	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 600 PN25	GRP 600 PN25	GRP 600 PN25	600	600	586.000	616.000	\N	25	\N	15.0	10000
7789	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 650 PN25	GRP 650 PN25	GRP 650 PN25	650	650	618.000	650.000	\N	25	\N	16.0	10000
7790	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 700 PN25	GRP 700 PN25	GRP 700 PN25	700	700	684.000	718.000	\N	25	\N	17.0	10000
7791	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 750 PN25	GRP 750 PN25	GRP 750 PN25	750	750	716.000	752.000	\N	25	\N	18.0	10000
7792	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 800 PN25	GRP 800 PN25	GRP 800 PN25	800	800	782.000	820.000	\N	25	\N	19.0	10000
7793	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 860 PN25	GRP 860 PN25	GRP 860 PN25	860	860	822.000	860.000	\N	25	\N	19.0	10000
7794	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 900 PN25	GRP 900 PN25	GRP 900 PN25	900	900	882.000	924.000	\N	25	\N	21.0	10000
7795	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 960 PN25	GRP 960 PN25	GRP 960 PN25	960	960	918.000	960.000	\N	25	\N	21.0	10000
7796	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1000 PN25	GRP 1000 PN25	GRP 1000 PN25	1000	1000	980.000	1026.000	\N	25	\N	23.0	10000
7797	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 150 PN32	GRP 150 PN32	GRP 150 PN32	150	150	154.000	168.000	\N	32	\N	7.0	10000
7798	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 200 PN32	GRP 200 PN32	GRP 200 PN32	200	200	204.000	220.000	\N	32	\N	8.0	10000
7799	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 250 PN32	GRP 250 PN32	GRP 250 PN32	250	250	252.000	272.000	\N	32	\N	10.0	10000
7800	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 300 PN32	GRP 300 PN32	GRP 300 PN32	300	300	302.000	324.000	\N	32	\N	11.0	10000
7801	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 350 PN32	GRP 350 PN32	GRP 350 PN32	350	350	352.000	376.000	\N	32	\N	12.0	10000
7802	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 400 PN32	GRP 400 PN32	GRP 400 PN32	400	400	401.000	427.000	\N	32	\N	13.0	10000
7803	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 450 PN32	GRP 450 PN32	GRP 450 PN32	450	450	448.000	478.000	\N	32	\N	15.0	10000
7804	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 500 PN32	GRP 500 PN32	GRP 500 PN32	500	500	498.000	530.000	\N	32	\N	16.0	10000
7805	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 550 PN32	GRP 550 PN32	GRP 550 PN32	550	550	518.000	550.000	\N	32	\N	16.0	10000
7806	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 600 PN32	GRP 600 PN32	GRP 600 PN32	600	600	580.000	616.000	\N	32	\N	18.0	10000
7807	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 650 PN32	GRP 650 PN32	GRP 650 PN32	650	650	614.000	650.000	\N	32	\N	18.0	10000
7808	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 700 PN32	GRP 700 PN32	GRP 700 PN32	700	700	678.000	718.000	\N	32	\N	20.0	10000
7809	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 750 PN32	GRP 750 PN32	GRP 750 PN32	750	750	710.000	752.000	\N	32	\N	21.0	10000
7810	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 800 PN32	GRP 800 PN32	GRP 800 PN32	800	800	774.000	820.000	\N	32	\N	23.0	10000
7811	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 860 PN32	GRP 860 PN32	GRP 860 PN32	860	860	812.000	860.000	\N	32	\N	24.0	10000
7812	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 900 PN32	GRP 900 PN32	GRP 900 PN32	900	900	874.000	924.000	\N	32	\N	25.0	10000
7813	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 960 PN32	GRP 960 PN32	GRP 960 PN32	960	960	908.000	960.000	\N	32	\N	26.0	10000
7814	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1000 PN32	GRP 1000 PN32	GRP 1000 PN32	1000	1000	972.000	1026.000	\N	32	\N	27.0	10000
7815	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 150 PN6	GRP 150 PN6	GRP 150 PN6	150	150	156.000	168.000	\N	6	\N	6.0	10000
7816	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 200 PN6	GRP 200 PN6	GRP 200 PN6	200	200	204.000	220.000	\N	6	\N	8.0	10000
7817	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 250 PN6	GRP 250 PN6	GRP 250 PN6	250	250	254.000	272.000	\N	6	\N	9.0	10000
7818	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 300 PN6	GRP 300 PN6	GRP 300 PN6	300	300	304.000	324.000	\N	6	\N	10.0	10000
7819	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 350 PN6	GRP 350 PN6	GRP 350 PN6	350	350	352.000	376.000	\N	6	\N	12.0	10000
7820	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 400 PN6	GRP 400 PN6	GRP 400 PN6	400	400	403.000	427.000	\N	6	\N	12.0	10000
7821	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 450 PN6	GRP 450 PN6	GRP 450 PN6	450	450	452.000	478.000	\N	6	\N	13.0	10000
7822	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 500 PN6	GRP 500 PN6	GRP 500 PN6	500	500	502.000	530.000	\N	6	\N	14.0	10000
7823	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 550 PN6	GRP 550 PN6	GRP 550 PN6	550	550	520.000	550.000	\N	6	\N	15.0	10000
7824	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 600 PN6	GRP 600 PN6	GRP 600 PN6	600	600	584.000	616.000	\N	6	\N	16.0	10000
7825	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 650 PN6	GRP 650 PN6	GRP 650 PN6	650	650	616.000	650.000	\N	6	\N	17.0	10000
7826	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 700 PN6	GRP 700 PN6	GRP 700 PN6	700	700	682.000	718.000	\N	6	\N	18.0	10000
7827	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 750 PN6	GRP 750 PN6	GRP 750 PN6	750	750	714.000	752.000	\N	6	\N	19.0	10000
7828	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 800 PN6	GRP 800 PN6	GRP 800 PN6	800	800	778.000	820.000	\N	6	\N	21.0	10000
7829	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 860 PN6	GRP 860 PN6	GRP 860 PN6	860	860	818.000	860.000	\N	6	\N	21.0	10000
7830	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 900 PN6	GRP 900 PN6	GRP 900 PN6	900	900	878.000	924.000	\N	6	\N	23.0	10000
7831	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 960 PN6	GRP 960 PN6	GRP 960 PN6	960	960	912.000	960.000	\N	6	\N	24.0	10000
7832	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1000 PN6	GRP 1000 PN6	GRP 1000 PN6	1000	1000	976.000	1026.000	\N	6	\N	25.0	10000
7833	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1100 PN6	GRP 1100 PN6	GRP 1100 PN6	1100	1100	1045.000	1099.000	\N	6	\N	27.0	10000
7834	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1200 PN6	GRP 1200 PN6	GRP 1200 PN6	1200	1200	1169.000	1229.000	\N	6	\N	30.0	10000
7835	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1280 PN6	GRP 1280 PN6	GRP 1280 PN6	1280	1280	1218.000	1280.000	\N	6	\N	31.0	10000
7836	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1348 PN6	GRP 1348 PN6	GRP 1348 PN6	1348	1348	1284.000	1348.000	\N	6	\N	32.0	10000
7837	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1400 PN6	GRP 1400 PN6	GRP 1400 PN6	1400	1400	1366.000	1434.000	\N	6	\N	34.0	10000
7838	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1500 PN6	GRP 1500 PN6	GRP 1500 PN6	1500	1500	1429.000	1499.000	\N	6	\N	35.0	10000
7839	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1535 PN6	GRP 1535 PN6	GRP 1535 PN6	1535	1535	1463.000	1535.000	\N	6	\N	36.0	10000
7840	t	PRV	GRP	GRP	Polyester renforcé de fibres de verre	Glass-fibre-reinforced polyester	Rășini armate cu fibră de sticlă (GRP)	\N	\N	\N	PRV 1600 PN6	GRP 1600 PN6	GRP 1600 PN6	1600	1600	1560.000	1638.000	\N	6	\N	39.0	10000
\.


--
-- Data for Name: pipe_protection; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pipe_protection (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
4302	t	\N	\N	\N	SOMO PVC	\N	SOMO PVC	\N	\N	\N
4304	t	\N	\N	\N	SOMO autre	\N	SOMO de alt tip	\N	\N	\N
4310	t	\N	\N	\N	SOMO PE	\N	SOMO PE	\N	\N	\N
4301	t	\N	\N	\N	ancienne conduite AGG	\N	conductă veche de OLG	\N	\N	\N
4303	t	\N	\N	\N	ancienne conduite F	\N	conductă veche Fontă	\N	\N	\N
4305	t	\N	\N	\N	ancienne conduite TAC	\N	conductă veche Azbociment	\N	\N	\N
4306	t	\N	\N	\N	ancienne conduite AC	\N	conductă veche OL	\N	\N	\N
4307	t	\N	\N	\N	ancienne conduite PE	\N	conductă veche PE	\N	\N	\N
4308	t	\N	\N	\N	ancienne conduite autre	\N	conductă veche de alt tip	\N	\N	\N
4309	t	\N	\N	\N	dans tuyau ciment	\N	în conductă ciment	\N	\N	\N
4311	t	\N	\N	\N	flexible	\N	flexibilă	\N	\N	\N
\.


--
-- Data for Name: precision; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY "precision" (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	Autre	Other	Alta	\N	\N	\N	\N
102	t	\N	\N	\N	Inconnu	Unknown	Necunoscută	\N	\N	\N	1
103	t	\N	\N	\N	À déterminer	To be determined	De determinat	\N	\N	\N	\N
1101	t	\N	\N	\N	Imprécis	Unprecise	Imprecisă	\N	\N	\N	1
1102	t	\N	\N	\N	Précis	Precise	Precisă	\N	\N	\N	0
1103	t	\N	\N	\N	Localisé	Localized	Localizată	\N	\N	\N	1
1104	t	\N	\N	\N	Digitalisé	Digitalized	Digitizată	\N	\N	\N	1
\.


--
-- Data for Name: precisionalti; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY precisionalti (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	Autre	Other	Alta	\N	\N	\N	\N
102	t	\N	\N	\N	Inconnu	Unknown	Necunoscută	\N	\N	\N	1
103	t	\N	\N	\N	À déterminer	To be determined	De determinat	\N	\N	\N	\N
1121	t	\N	\N	\N	Imprécis	Unprecised	Imprecisă	\N	\N	\N	1
1122	t	\N	\N	\N	Inférieure à 100 cm	Better than 100 cm	Mai bună de 100 cm	\N	\N	\N	0
1123	t	\N	\N	\N	Inférieure à 50 cm	Better than 50 cm	Mai bună de 50 cm	\N	\N	\N	0
1124	t	\N	\N	\N	Inférieure à 10 cm	Better than 10 cm	Mai bună de 10 cm	\N	\N	\N	0
1125	t	\N	\N	\N	Inférieure à 5 cm	Better than 5 cm	Mai bună de 5 cm	\N	\N	\N	0
\.


--
-- Data for Name: pressurecontrol_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pressurecontrol_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
2801	t	\N	\N	\N	réducteur	reducer	reductor	\N	\N	\N
2802	t	\N	\N	\N	coupe-pression	pressure cut	tăiere presiune	\N	\N	\N
2803	t	\N	\N	\N	rassemblement	gathering	colectare/captare	\N	\N	\N
\.


--
-- Data for Name: protectionzone_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY protectionzone_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	Autre	Other	Alta	Autre	Other	Alta	\N	\N	\N
102	t	Inconnu	Unknown	Nec.	Inconnu	Unknown	Necunoscută	\N	\N	\N
103	t	À dét.	To determ.	De det.	à déterminer	To be determined	De determinat	\N	\N	\N
9501	t	S1	S1	S1	Zone de protection S1	S1 protection zone	Zonă de protecţie S1	\N	\N	\N
9502	t	S2	S2	S2	Zone de protection S2	S2 protection zone	Zonă de protecţie S2	\N	\N	\N
9503	t	S3	S3	S3	Zone de protection S3	S3 protection zone	Zonă de protecţie S3	\N	\N	\N
9504	t	PP	PP	PP	Périmètre de protection	Protection perimeter	Perimetru de protecţie	\N	\N	\N
9505	t	Zo	Zo	Zo	Zone de protection des eaux de surface	Surface Water protection zone	Zonă de protecţie a apelor de suprafaţă	\N	\N	\N
\.


--
-- Data for Name: pump_operating; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pump_operating (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	0
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
2402	t	\N	\N	\N	alterné	alternative	alternativ	\N	\N	\N	1
2403	t	\N	\N	\N	parallèle	parallel	paralel	\N	\N	\N	2
\.


--
-- Data for Name: pump_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY pump_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
2501	t	\N	\N	\N	surpresseur		hidrofor	\N	\N	\N	0
2502	t	\N	\N	\N	normal		normal	\N	\N	\N	1
2503	t	\N	\N	\N	accélération		periferică	\N	\N	\N	2
\.


--
-- Data for Name: remote_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY remote_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
1201	t	\N	\N	\N	Aucune		Niciuna	\N	\N	\N
1202	t	\N	\N	\N	Cable en site propre		Cablu propriu	\N	\N	\N
1203	t	\N	\N	\N	Ligne louée		Linie închiriată	\N	\N	\N
1204	t	\N	\N	\N	Ligne commutée		Linie comutată	\N	\N	\N
1205	t	\N	\N	\N	ADSL		ADSL	\N	\N	\N
1206	t	\N	\N	\N	Radio		Radio	\N	\N	\N
1207	t	\N	\N	\N	GPRS		GPRS	\N	\N	\N
\.


--
-- Data for Name: source_quality; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY source_quality (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	0
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
2602	t	\N	\N	\N	bonne	\N	bună	\N	\N	\N	1
2603	t	\N	\N	\N	conditionnellement bonne	\N	bună condiţionat	\N	\N	\N	2
2604	t	\N	\N	\N	désinfection obligatoire	\N	dezinfecţie obligatorie	\N	\N	\N	3
\.


--
-- Data for Name: source_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY source_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
2701	t	\N	\N	\N	captage eau lac	\N	captare lac	\N	\N	\N	0
2702	t	\N	\N	\N	captage eau nappe	\N	captare strat freatic	\N	\N	\N	1
2703	t	\N	\N	\N	captage eau source	\N	captare sursă subterană	\N	\N	\N	2
2704	t	\N	\N	\N	captage eau rivière	\N	captare râu	\N	\N	\N	3
\.


--
-- Data for Name: status; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY status (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, active, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	t	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	t	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	t	\N
1307	t	\N	\N	\N	fictif	fictional	Fictiv	L'objet n'existe pas mais est nécessaire à l'intégrité topologique.		Obiectul este fictiv dar este necesar pentru integritatea topologică.	t	1
1303	t	\N	\N	\N	désaffecté	shut down	Dezafectat	La mise hors service est quasi-définitive et une remise en service nécessiterai des opérations spéciales. Par exemple, une source non-captée est considérée comme désaffectée. Ou encore, une conduite n'étant plus raccordée maism étant toutefois dans état propre à son utilisation.		Punerea în stare dezafectată este semi definitivă iar repunerea în stare funcţională ar necesita operaţiuni speciale. Spre exemplu, o sursă necaptată este considerată ca dezafectată. Sau mai mult, o conductă care nu este racordată dar a cărei stare e utilizabilă.	f	\N
1305	t	\N	\N	\N	détruit	destroyed	Distrus	L'objet a été partiellement ou complètement détruit.		Obiectul este distrus complet sau parţial	f	\N
1302	t	\N	\N	\N	hors service	out of service	Nefuncţional	Ne contribue actuellement pas au réseau, mais peut être remis en service sans opération spéciale. La mise hors service est considérée comme temporaire. Par exemple, une source mise hors service pour des problèmes de qualité.		Nu contribuie efectiv la reţea, dar poate fi repusă în stare funcţională fară operaţiuni speciale. Starea nefuncţională este considerată ca una temporară. De exemplu, putem avea o sursă care a fost pusă în stare nefuncţională datorită unor probleme de calitate.	f	\N
1301	t	\N	\N	\N	en service	in use	Funcţional	Contribue actuellement au réseau.		Contribuie efectiv la reţea.	t	1
1304	t	\N	\N	\N	abandonné	disused	Abandonat	L'objet est inutilisable et sa mise hors service est strictement définitive. Par exemple, une conduite non raccordée et impropre au transport d'eau, mais pouvant éventuellement servir à passer des câbles. Ou encore une station de pompage sans pompe en état de fonctionner.		Obiectul este abandonat iar scoaterea din funcţiune este strict definitivă. Spre exemplu, putem avea o conductă neracordată și improprie transportului de apă dar care poate fi eventual folosită ca mediu protector pentru alte conducte sau pt. cabluri. Alt exemplu este o statie de pompare fară nici o pompă  în stare funcţională.	f	\N
1306	t	\N	\N	\N	projet	project	Proiect	L'objet est un projet validé en attente ou en cours de réalisation.		Obiectul face parte dintr-un proiect care se va face sau în curs de realizare. 	f	\N
\.


--
-- Data for Name: subscriber_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY subscriber_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
9401	t	abo	\N	\N	Abonnement	Subscriber	abonat	\N	\N	\N
9402	t	arr	\N	\N	Arrosage	\N	irigare/udare	\N	\N	\N
9403	t	font	\N	\N	Fontaine	Fountain	fântână cişmea	\N	\N	\N
9404	t	wc	\N	\N	WC	WC	WC	\N	\N	\N
9405	t	spkr	\N	\N	Sprinkler	\N	stropitoare/sprinkler	\N	\N	\N
\.


--
-- Data for Name: survey_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY survey_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
9901	t	\N	\N	\N	GPS	GPS	GPS	\N	\N	\N	\N
9902	t	\N	\N	\N	chevillère	meter?	?	\N	\N	\N	\N
\.


--
-- Data for Name: tank_firestorage; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY tank_firestorage (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
2301	t	\N	\N	\N	aucune	\N	niciunul	\N	\N	\N
2302	t	\N	\N	\N	cuve 1 entière	\N	cisterna 1 toată	\N	\N	\N
2303	t	\N	\N	\N	cuve 1 partielle	\N	cisterna 1 parţial	\N	\N	\N
2304	t	\N	\N	\N	cuve 2 entière	\N	cisterna 2 toată	\N	\N	\N
2305	t	\N	\N	\N	cuve 2 partielle	\N	cisterna 2 parţial	\N	\N	\N
2306	t	\N	\N	\N	2 cuves partielles	\N	2 cisterne parţial	\N	\N	\N
\.


--
-- Data for Name: value_list_base; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY value_list_base (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
\.


--
-- Data for Name: valve_actuation; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY valve_actuation (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, schema_visible) FROM stdin;
101	t	\N	\N	\N	autre	other	altul	\N	\N	\N	t
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N	t
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	t
6401	t	\N	\N	\N	manuel	hand control	manuală	\N	\N	\N	t
6402	t	\N	\N	\N	manuel à gauche	left hand control	manuală la stânga	\N	\N	\N	t
6403	t	\N	\N	\N	électrique	electric drive	electrică	\N	\N	\N	t
6404	t	\N	\N	\N	télécommandée	remote controlled	telecomandată	\N	\N	\N	t
\.


--
-- Data for Name: valve_function; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY valve_function (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, schema_visible) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	t
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	t
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	t
6101	t	\N	\N	\N	vanne de régulation	control valve	vană reglaj	\N	\N	\N	t
6102	t	Ve	\N	\N	ventouse	vacuum release	aerisire	\N	\N	\N	t
6103	t	\N	\N	\N	vanne bypass	bypass valve	vană bypass	\N	\N	\N	t
6105	t	\N	\N	\N	vanne branchement	connecting pipe	robinet concesie	\N	\N	\N	f
6107	t	\N	\N	\N	vanne incendie	fire valve	vană incendiu	\N	\N	\N	t
6108	t	\N	\N	\N	vanne d'hydrant	hydrant valve	vană hidrant	\N	\N	\N	t
6110	t	Vi	\N	\N	vidange	discharge	vană golire	\N	\N	\N	t
6111	t	\N	\N	\N	vanne réseau		vană cu sertar	\N	\N	\N	t
6112	t	ViVe	\N	\N	vidange-ventouse	discharge-vacuum	golire-aerisire	\N	\N	\N	t
6113	t	\N	\N	\N	antiretour	backflow prevention	antiretur	\N	\N	\N	t
6114	t	\N	\N	\N	vanne sprinkler	sprinkler	sprinkler?	\N	\N	\N	t
6115	t	\N	\N	\N	jauge	vent valve	aerisire	\N	\N	\N	t
\.


--
-- Data for Name: valve_maintenance; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY valve_maintenance (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, priority) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
6201	t	\N	\N	\N	Cape fendue	\N	Înveliş crăpat	\N	\N	\N	3
6202	t	\N	\N	\N	Joint manquant	\N	Lipsă tijă	\N	\N	\N	2
6203	t	\N	\N	\N	Bloquée	\N	Blocată	\N	\N	\N	1
\.


--
-- Data for Name: valve_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY valve_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscut	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
6301	t	\N	\N	\N	vanne à opercule	gate valve	vană cu sertar	\N	\N	\N
6302	t	\N	\N	\N	vanne clayton	clayton valve	vană clayton	\N	\N	\N
6303	t	\N	\N	\N	vanne annulaire	annular valve	vană inelară	\N	\N	\N
6306	t	\N	\N	\N	limiteur de débit	flow control valve	reductor	\N	\N	\N
6307	t	\N	\N	\N	clapet anti-retour	check valve	vană cu clapetă	\N	\N	\N
6309	t	\N	\N	\N	sprinkler		sprinkler	\N	\N	\N
6310	t	\N	\N	\N	vanne	valve	vană	\N	\N	\N
6311	t	P	\N	\N	vanne papillon	butterfly valve	vană fluture	\N	\N	\N
6312	t	\N	\N	\N	Elgef		Elgef	\N	\N	\N
6313	t	\N	\N	\N	1/4 de tour	1/4 of turn	sfert de tur	\N	\N	\N
6314	t	\N	\N	\N	soupape manuelle		supapă ?	\N	\N	\N
6315	t	\N	\N	\N	soupape automatique		supapă automată	\N	\N	\N
\.


--
-- Data for Name: visible; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY visible (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, vl_code, vl_code_int) FROM stdin;
1401	t	\N	\N	\N	Auto	Auto	Auto	\N	\N	\N	\N	1
1402	t	\N	\N	\N	Visible	Visible	Vizibilă	\N	\N	\N	t	2
1403	t	\N	\N	\N	Invisible	Invisible	Invizibilă	\N	\N	\N	f	0
\.


--
-- Data for Name: watertype; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY watertype (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro, code_sire) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N	\N
1501	t	\N	\N	\N	brute	raw	brută	\N	\N	\N	0
1502	t	\N	\N	\N	potable	drinkable	potabilă	\N	\N	\N	1
1503	t	\N	\N	\N	industrielle	industrial	industrială	\N	\N	\N	2
\.


--
-- Data for Name: worker_type; Type: TABLE DATA; Schema: qwat_vl; Owner: postgres
--

COPY worker_type (id, vl_active, short_fr, short_en, short_ro, value_fr, value_en, value_ro, description_fr, description_en, description_ro) FROM stdin;
101	t	\N	\N	\N	autre	other	alta	\N	\N	\N
102	t	\N	\N	\N	inconnu	unknown	necunoscută	\N	\N	\N
103	t	\N	\N	\N	à déterminer	to be determined	de determinat	\N	\N	\N
8001	t	\N	\N	\N		leaks repairing	rezolvare avarii	\N	\N	\N
8002	t	\N	\N	\N		valves checking	verificare vane	\N	\N	\N
8003	t	\N	\N	\N		hydrants checking	verificare hidranti	\N	\N	\N
\.


SET search_path = qwat_dr, pg_catalog;

--
-- Name: annotationline annotationline_pkey; Type: CONSTRAINT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY annotationline
    ADD CONSTRAINT annotationline_pkey PRIMARY KEY (id);


--
-- Name: annotationpoint annotationpoint_pkey; Type: CONSTRAINT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY annotationpoint
    ADD CONSTRAINT annotationpoint_pkey PRIMARY KEY (id);


--
-- Name: constructionpoint constructionpoint_pkey; Type: CONSTRAINT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY constructionpoint
    ADD CONSTRAINT constructionpoint_pkey PRIMARY KEY (id);


--
-- Name: dimension_distance dimension_distance_pkey; Type: CONSTRAINT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY dimension_distance
    ADD CONSTRAINT dimension_distance_pkey PRIMARY KEY (id);


--
-- Name: dimension_orientation dimension_orientation_pkey; Type: CONSTRAINT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY dimension_orientation
    ADD CONSTRAINT dimension_orientation_pkey PRIMARY KEY (id);


SET search_path = qwat_od, pg_catalog;

--
-- Name: chamber chamber_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY chamber
    ADD CONSTRAINT chamber_pkey PRIMARY KEY (id);


--
-- Name: consumptionzone consumptionzone_name; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY consumptionzone
    ADD CONSTRAINT consumptionzone_name UNIQUE (name);


--
-- Name: consumptionzone consumptionzone_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY consumptionzone
    ADD CONSTRAINT consumptionzone_pkey PRIMARY KEY (id);


--
-- Name: cover cover_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY cover
    ADD CONSTRAINT cover_pkey PRIMARY KEY (id);


--
-- Name: crossing crossing_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY crossing
    ADD CONSTRAINT crossing_pkey PRIMARY KEY (id);


--
-- Name: distributor distributor_name; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY distributor
    ADD CONSTRAINT distributor_name UNIQUE (name);


--
-- Name: distributor distributor_pk; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY distributor
    ADD CONSTRAINT distributor_pk PRIMARY KEY (id);


--
-- Name: district district_name; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY district
    ADD CONSTRAINT district_name UNIQUE (name);


--
-- Name: district district_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY district
    ADD CONSTRAINT district_pkey PRIMARY KEY (id);


--
-- Name: folder folder_identification; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY folder
    ADD CONSTRAINT folder_identification UNIQUE (identification);


--
-- Name: folder folder_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY folder
    ADD CONSTRAINT folder_pkey PRIMARY KEY (id);


--
-- Name: hydrant hydrant_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_pkey PRIMARY KEY (id);


--
-- Name: installation installation_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY installation
    ADD CONSTRAINT installation_pkey PRIMARY KEY (id);


--
-- Name: leak leak_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY leak
    ADD CONSTRAINT leak_pkey PRIMARY KEY (id);


--
-- Name: meter meter_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY meter
    ADD CONSTRAINT meter_pkey PRIMARY KEY (id);


--
-- Name: meter_reference meter_reference_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY meter_reference
    ADD CONSTRAINT meter_reference_pkey PRIMARY KEY (id);


--
-- Name: network_element network_element_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT network_element_pkey PRIMARY KEY (id);


--
-- Name: node node_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY node
    ADD CONSTRAINT node_pkey PRIMARY KEY (id);


--
-- Name: part part_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY part
    ADD CONSTRAINT part_pkey PRIMARY KEY (id);


--
-- Name: pipe pipe_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_pkey PRIMARY KEY (id);


--
-- Name: pressurecontrol pressurecontrol_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurecontrol
    ADD CONSTRAINT pressurecontrol_pkey PRIMARY KEY (id);


--
-- Name: pressurezone pressurezone_name; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone
    ADD CONSTRAINT pressurezone_name UNIQUE (name);


--
-- Name: pressurezone pressurezone_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone
    ADD CONSTRAINT pressurezone_pkey PRIMARY KEY (id);


--
-- Name: printmap printmap_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY printmap
    ADD CONSTRAINT printmap_pkey PRIMARY KEY (id);


--
-- Name: protectionzone protectionzone_name; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY protectionzone
    ADD CONSTRAINT protectionzone_name UNIQUE (name);


--
-- Name: protectionzone protectionzone_pk; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY protectionzone
    ADD CONSTRAINT protectionzone_pk PRIMARY KEY (id);


--
-- Name: pump pump_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pump
    ADD CONSTRAINT pump_pkey PRIMARY KEY (id);


--
-- Name: remote remote_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_pkey PRIMARY KEY (id);


--
-- Name: samplingpoint samplingpoint_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY samplingpoint
    ADD CONSTRAINT samplingpoint_pkey PRIMARY KEY (id);


--
-- Name: source source_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY source
    ADD CONSTRAINT source_pkey PRIMARY KEY (id);


--
-- Name: subscriber subscriber_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber
    ADD CONSTRAINT subscriber_pkey PRIMARY KEY (id);


--
-- Name: subscriber_reference subscriber_reference_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber_reference
    ADD CONSTRAINT subscriber_reference_pkey PRIMARY KEY (id);


--
-- Name: surveypoint surveypoint_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY surveypoint
    ADD CONSTRAINT surveypoint_pkey PRIMARY KEY (id);


--
-- Name: tank tank_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY tank
    ADD CONSTRAINT tank_pkey PRIMARY KEY (id);


--
-- Name: treatment treatment_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY treatment
    ADD CONSTRAINT treatment_pkey PRIMARY KEY (id);


--
-- Name: valve valve_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_pkey PRIMARY KEY (id);


--
-- Name: worker worker_pkey; Type: CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY worker
    ADD CONSTRAINT worker_pkey PRIMARY KEY (id);


SET search_path = qwat_sys, pg_catalog;

--
-- Name: logged_actions logged_actions_pkey; Type: CONSTRAINT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY logged_actions
    ADD CONSTRAINT logged_actions_pkey PRIMARY KEY (event_id);


--
-- Name: versions module_unique; Type: CONSTRAINT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY versions
    ADD CONSTRAINT module_unique UNIQUE (module);


--
-- Name: settings setting_unique; Type: CONSTRAINT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY settings
    ADD CONSTRAINT setting_unique UNIQUE (name);


--
-- Name: settings settings_pkey; Type: CONSTRAINT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY settings
    ADD CONSTRAINT settings_pkey PRIMARY KEY (id);


--
-- Name: versions versions_pkey; Type: CONSTRAINT; Schema: qwat_sys; Owner: postgres
--

ALTER TABLE ONLY versions
    ADD CONSTRAINT versions_pkey PRIMARY KEY (id);


SET search_path = qwat_vl, pg_catalog;

--
-- Name: value_list_base value_list_base_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY value_list_base
    ADD CONSTRAINT value_list_base_pk PRIMARY KEY (id);


--
-- Name: visible visible_code; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY visible
    ADD CONSTRAINT visible_code UNIQUE (vl_code);


--
-- Name: visible visible_code_int; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY visible
    ADD CONSTRAINT visible_code_int UNIQUE (vl_code_int);


--
-- Name: bedding vl_bedding_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY bedding
    ADD CONSTRAINT vl_bedding_pk PRIMARY KEY (id);


--
-- Name: cistern vl_cistern_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY cistern
    ADD CONSTRAINT vl_cistern_pk PRIMARY KEY (id);


--
-- Name: cover_type vl_cover_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY cover_type
    ADD CONSTRAINT vl_cover_type_pk PRIMARY KEY (id);


--
-- Name: hydrant_material vl_hydrant_material_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_material
    ADD CONSTRAINT vl_hydrant_material_pk PRIMARY KEY (id);


--
-- Name: hydrant_model_inf vl_hydrant_model_inf_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_model_inf
    ADD CONSTRAINT vl_hydrant_model_inf_pk PRIMARY KEY (id);


--
-- Name: hydrant_model_sup vl_hydrant_model_sup_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_model_sup
    ADD CONSTRAINT vl_hydrant_model_sup_pk PRIMARY KEY (id);


--
-- Name: hydrant_output vl_hydrant_output_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_output
    ADD CONSTRAINT vl_hydrant_output_pk PRIMARY KEY (id);


--
-- Name: hydrant_provider vl_hydrant_provider_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY hydrant_provider
    ADD CONSTRAINT vl_hydrant_provider_pk PRIMARY KEY (id);


--
-- Name: leak_cause vl_leak_cause_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY leak_cause
    ADD CONSTRAINT vl_leak_cause_pk PRIMARY KEY (id);


--
-- Name: locationtype vl_location_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY locationtype
    ADD CONSTRAINT vl_location_pk PRIMARY KEY (id);


--
-- Name: object_reference vl_object_reference_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY object_reference
    ADD CONSTRAINT vl_object_reference_pk PRIMARY KEY (id);


--
-- Name: overflow vl_overflow_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY overflow
    ADD CONSTRAINT vl_overflow_pk PRIMARY KEY (id);


--
-- Name: part_type vl_part_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY part_type
    ADD CONSTRAINT vl_part_type_pk PRIMARY KEY (id);


--
-- Name: pipe_function vl_pipe_function_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_function
    ADD CONSTRAINT vl_pipe_function_pk PRIMARY KEY (id);


--
-- Name: pipe_installmethod vl_pipe_installmethod_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_installmethod
    ADD CONSTRAINT vl_pipe_installmethod_pk PRIMARY KEY (id);


--
-- Name: pipe_material vl_pipe_material_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_material
    ADD CONSTRAINT vl_pipe_material_pk PRIMARY KEY (id);


--
-- Name: pipe_protection vl_pipe_protection_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pipe_protection
    ADD CONSTRAINT vl_pipe_protection_pk PRIMARY KEY (id);


--
-- Name: precision vl_precision_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY "precision"
    ADD CONSTRAINT vl_precision_pk PRIMARY KEY (id);


--
-- Name: precisionalti vl_precisionalti_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY precisionalti
    ADD CONSTRAINT vl_precisionalti_pk PRIMARY KEY (id);


--
-- Name: pressurecontrol_type vl_pressurecontrol_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pressurecontrol_type
    ADD CONSTRAINT vl_pressurecontrol_type_pk PRIMARY KEY (id);


--
-- Name: protectionzone_type vl_protectionzone_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY protectionzone_type
    ADD CONSTRAINT vl_protectionzone_type_pk PRIMARY KEY (id);


--
-- Name: pump_operating vl_pump_operating_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pump_operating
    ADD CONSTRAINT vl_pump_operating_pk PRIMARY KEY (id);


--
-- Name: pump_type vl_pump_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY pump_type
    ADD CONSTRAINT vl_pump_type_pk PRIMARY KEY (id);


--
-- Name: remote_type vl_remote_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY remote_type
    ADD CONSTRAINT vl_remote_type_pk PRIMARY KEY (id);


--
-- Name: source_quality vl_source_quality_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY source_quality
    ADD CONSTRAINT vl_source_quality_pk PRIMARY KEY (id);


--
-- Name: source_type vl_source_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY source_type
    ADD CONSTRAINT vl_source_type_pk PRIMARY KEY (id);


--
-- Name: status vl_status_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY status
    ADD CONSTRAINT vl_status_pk PRIMARY KEY (id);


--
-- Name: subscriber_type vl_subscriber_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY subscriber_type
    ADD CONSTRAINT vl_subscriber_type_pk PRIMARY KEY (id);


--
-- Name: survey_type vl_survey_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY survey_type
    ADD CONSTRAINT vl_survey_type_pk PRIMARY KEY (id);


--
-- Name: tank_firestorage vl_tank_firestorage_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY tank_firestorage
    ADD CONSTRAINT vl_tank_firestorage_pk PRIMARY KEY (id);


--
-- Name: valve_actuation vl_valve_actuation_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_actuation
    ADD CONSTRAINT vl_valve_actuation_pk PRIMARY KEY (id);


--
-- Name: valve_function vl_valve_function_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_function
    ADD CONSTRAINT vl_valve_function_pk PRIMARY KEY (id);


--
-- Name: valve_type vl_valve_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_type
    ADD CONSTRAINT vl_valve_type_pk PRIMARY KEY (id);


--
-- Name: visible vl_visible_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY visible
    ADD CONSTRAINT vl_visible_pk PRIMARY KEY (id);


--
-- Name: watertype vl_watertype_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY watertype
    ADD CONSTRAINT vl_watertype_pk PRIMARY KEY (id);


--
-- Name: worker_type vl_worker_type_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY worker_type
    ADD CONSTRAINT vl_worker_type_pk PRIMARY KEY (id);


--
-- Name: valve_maintenance vlvalve_maintenance_pk; Type: CONSTRAINT; Schema: qwat_vl; Owner: postgres
--

ALTER TABLE ONLY valve_maintenance
    ADD CONSTRAINT vlvalve_maintenance_pk PRIMARY KEY (id);


SET search_path = qwat_dr, pg_catalog;

--
-- Name: annotationline_geoidx; Type: INDEX; Schema: qwat_dr; Owner: postgres
--

CREATE INDEX annotationline_geoidx ON annotationline USING gist (geometry);


--
-- Name: annotationpoint_geoidx; Type: INDEX; Schema: qwat_dr; Owner: postgres
--

CREATE INDEX annotationpoint_geoidx ON annotationpoint USING gist (geometry);


--
-- Name: constructionpoint_geoidx; Type: INDEX; Schema: qwat_dr; Owner: postgres
--

CREATE INDEX constructionpoint_geoidx ON constructionpoint USING gist (geometry);


--
-- Name: dimension_distance_geoidx; Type: INDEX; Schema: qwat_dr; Owner: postgres
--

CREATE INDEX dimension_distance_geoidx ON dimension_distance USING gist (geometry);


--
-- Name: dimension_orientation_geoidx; Type: INDEX; Schema: qwat_dr; Owner: postgres
--

CREATE INDEX dimension_orientation_geoidx ON dimension_orientation USING gist (geometry);


--
-- Name: fki_constructionpoint_fk_object_reference; Type: INDEX; Schema: qwat_dr; Owner: postgres
--

CREATE INDEX fki_constructionpoint_fk_object_reference ON constructionpoint USING btree (fk_object_reference);


SET search_path = qwat_od, pg_catalog;

--
-- Name: district_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX district_geoidx ON district USING gist (geometry);


--
-- Name: fki_cover_fk_installation; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_cover_fk_installation ON cover USING btree (fk_installation);


--
-- Name: fki_cover_fk_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_cover_fk_type ON cover USING btree (fk_cover_type);


--
-- Name: fki_cover_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_cover_label_1_visible ON cover USING btree (label_1_visible);


--
-- Name: fki_cover_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_cover_label_2_visible ON cover USING btree (label_2_visible);


--
-- Name: fki_district_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_district_label_1_visible ON district USING btree (label_1_visible);


--
-- Name: fki_district_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_district_label_2_visible ON district USING btree (label_2_visible);


--
-- Name: fki_element_fk_distributor; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_element_fk_distributor ON network_element USING btree (fk_distributor);


--
-- Name: fki_element_fk_folder; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_element_fk_folder ON network_element USING btree (fk_folder);


--
-- Name: fki_element_fk_object_reference; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_element_fk_object_reference ON network_element USING btree (fk_object_reference);


--
-- Name: fki_element_fk_precision; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_element_fk_precision ON network_element USING btree (fk_precision);


--
-- Name: fki_element_fk_precisionalti; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_element_fk_precisionalti ON network_element USING btree (fk_precisionalti);


--
-- Name: fki_element_fk_status; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_element_fk_status ON network_element USING btree (fk_status);


--
-- Name: fki_hydrant_fk_material; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_hydrant_fk_material ON hydrant USING btree (fk_material);


--
-- Name: fki_hydrant_fk_model_inf; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_hydrant_fk_model_inf ON hydrant USING btree (fk_model_inf);


--
-- Name: fki_hydrant_fk_model_sup; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_hydrant_fk_model_sup ON hydrant USING btree (fk_model_sup);


--
-- Name: fki_hydrant_fk_output; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_hydrant_fk_output ON hydrant USING btree (fk_output);


--
-- Name: fki_hydrant_fk_provider; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_hydrant_fk_provider ON hydrant USING btree (fk_provider);


--
-- Name: fki_installation_fk_parent; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_installation_fk_parent ON installation USING btree (fk_parent);


--
-- Name: fki_installation_fk_remote; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_installation_fk_remote ON installation USING btree (fk_remote);


--
-- Name: fki_installation_watertype; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_installation_watertype ON installation USING btree (fk_watertype);


--
-- Name: fki_leak_fk_cause; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_leak_fk_cause ON leak USING btree (fk_cause);


--
-- Name: fki_leak_fk_pipe; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_leak_fk_pipe ON leak USING btree (fk_pipe);


--
-- Name: fki_leak_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_leak_label_1_visible ON leak USING btree (label_1_visible);


--
-- Name: fki_leak_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_leak_label_2_visible ON leak USING btree (label_2_visible);


--
-- Name: fki_meter_fk_pipe; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_meter_fk_pipe ON meter USING btree (fk_pipe);


--
-- Name: fki_meter_reference_fk_meter; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_meter_reference_fk_meter ON meter_reference USING btree (fk_meter);


--
-- Name: fki_network_element_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_network_element_label_1_visible ON network_element USING btree (label_1_visible);


--
-- Name: fki_network_element_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_network_element_label_2_visible ON network_element USING btree (label_2_visible);


--
-- Name: fki_network_element_schema_force_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_network_element_schema_force_visible ON network_element USING btree (schema_force_visible);


--
-- Name: fki_node_fk_district; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_node_fk_district ON node USING btree (fk_district);


--
-- Name: fki_node_fk_pressurezone; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_node_fk_pressurezone ON node USING btree (fk_pressurezone);


--
-- Name: fki_part_fk_pipe; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_part_fk_pipe ON part USING btree (fk_pipe);


--
-- Name: fki_part_fk_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_part_fk_type ON part USING btree (fk_part_type);


--
-- Name: fki_pipe_fk_bedding; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_bedding ON pipe USING btree (fk_bedding);


--
-- Name: fki_pipe_fk_distributor; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_distributor ON pipe USING btree (fk_distributor);


--
-- Name: fki_pipe_fk_district; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_district ON pipe USING btree (fk_district);


--
-- Name: fki_pipe_fk_folder; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_folder ON pipe USING btree (fk_folder);


--
-- Name: fki_pipe_fk_function; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_function ON pipe USING btree (fk_function);


--
-- Name: fki_pipe_fk_installmethod; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_installmethod ON pipe USING btree (fk_installmethod);


--
-- Name: fki_pipe_fk_material; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_material ON pipe USING btree (fk_material);


--
-- Name: fki_pipe_fk_node_a; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_node_a ON pipe USING btree (fk_node_a);


--
-- Name: fki_pipe_fk_node_b; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_node_b ON pipe USING btree (fk_node_b);


--
-- Name: fki_pipe_fk_parent; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_parent ON pipe USING btree (fk_parent);


--
-- Name: fki_pipe_fk_precision; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_precision ON pipe USING btree (fk_precision);


--
-- Name: fki_pipe_fk_pressurezone; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_pressurezone ON pipe USING btree (fk_pressurezone);


--
-- Name: fki_pipe_fk_protection; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_protection ON pipe USING btree (fk_protection);


--
-- Name: fki_pipe_fk_status; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_status ON pipe USING btree (fk_status);


--
-- Name: fki_pipe_fk_watertype; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_fk_watertype ON pipe USING btree (fk_watertype);


--
-- Name: fki_pipe_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_label_1_visible ON pipe USING btree (label_1_visible);


--
-- Name: fki_pipe_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_label_2_visible ON pipe USING btree (label_2_visible);


--
-- Name: fki_pipe_schema_force_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pipe_schema_force_visible ON pipe USING btree (schema_force_visible);


--
-- Name: fki_pressurecontrol_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pressurecontrol_type ON pressurecontrol USING btree (fk_pressurecontrol_type);


--
-- Name: fki_pressurezone_fk_consumptionzone; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pressurezone_fk_consumptionzone ON pressurezone USING btree (fk_consumptionzone);


--
-- Name: fki_pressurezone_fk_distributor; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pressurezone_fk_distributor ON pressurezone USING btree (fk_distributor);


--
-- Name: fki_pressurezone_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pressurezone_label_1_visible ON pressurezone USING btree (label_1_visible);


--
-- Name: fki_pressurezone_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pressurezone_label_2_visible ON pressurezone USING btree (label_2_visible);


--
-- Name: fki_printmap_fk_district; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_printmap_fk_district ON printmap USING btree (id);


--
-- Name: fki_printmap_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_printmap_label_1_visible ON printmap USING btree (label_1_visible);


--
-- Name: fki_printmap_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_printmap_label_2_visible ON printmap USING btree (label_2_visible);


--
-- Name: fki_protectionzone_fk_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_protectionzone_fk_type ON protectionzone USING btree (fk_type);


--
-- Name: fki_pump_operating; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pump_operating ON pump USING btree (fk_pump_operating);


--
-- Name: fki_pump_pipe_in; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pump_pipe_in ON pump USING btree (fk_pipe_in);


--
-- Name: fki_pump_pipe_out; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pump_pipe_out ON pump USING btree (fk_pipe_out);


--
-- Name: fki_pump_vl_pump_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_pump_vl_pump_type ON pump USING btree (fk_pump_type);


--
-- Name: fki_remote_fk_distributor; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_remote_fk_distributor ON remote USING btree (fk_distributor);


--
-- Name: fki_remote_fk_material; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_remote_fk_material ON remote USING btree (fk_material);


--
-- Name: fki_remote_fk_precision; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_remote_fk_precision ON remote USING btree (fk_precision);


--
-- Name: fki_remote_fk_status; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_remote_fk_status ON remote USING btree (fk_status);


--
-- Name: fki_remote_label_1_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_remote_label_1_visible ON remote USING btree (label_1_visible);


--
-- Name: fki_remote_label_2_visible; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_remote_label_2_visible ON remote USING btree (label_2_visible);


--
-- Name: fki_source_source_quality; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_source_source_quality ON source USING btree (fk_source_quality);


--
-- Name: fki_source_source_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_source_source_type ON source USING btree (fk_source_type);


--
-- Name: fki_subscriber_fk_pipe; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_subscriber_fk_pipe ON subscriber USING btree (fk_pipe);


--
-- Name: fki_subscriber_fk_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_subscriber_fk_type ON subscriber USING btree (fk_subscriber_type);


--
-- Name: fki_subscriber_reference_fk_subscriber; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_subscriber_reference_fk_subscriber ON subscriber_reference USING btree (fk_subscriber);


--
-- Name: fki_surveypoint_fk_folder; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_surveypoint_fk_folder ON surveypoint USING btree (fk_folder);


--
-- Name: fki_surveypoint_fk_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_surveypoint_fk_type ON surveypoint USING btree (fk_survey_type);


--
-- Name: fki_surveypoint_fk_worker; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_surveypoint_fk_worker ON surveypoint USING btree (fk_worker);


--
-- Name: fki_tank_cistern1type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_tank_cistern1type ON tank USING btree (cistern1_fk_type);


--
-- Name: fki_tank_cistern2type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_tank_cistern2type ON tank USING btree (cistern2_fk_type);


--
-- Name: fki_tank_fk_overflow; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_tank_fk_overflow ON tank USING btree (fk_overflow);


--
-- Name: fki_tank_fk_tank_firestorage; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_tank_fk_tank_firestorage ON tank USING btree (fk_tank_firestorage);


--
-- Name: fki_valve_fk_function; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_valve_fk_function ON valve USING btree (fk_valve_function);


--
-- Name: fki_valve_fk_handle_precision; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_valve_fk_handle_precision ON valve USING btree (fk_handle_precision);


--
-- Name: fki_valve_fk_handle_precisionalti; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_valve_fk_handle_precisionalti ON valve USING btree (fk_handle_precisionalti);


--
-- Name: fki_valve_fk_pipe; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_valve_fk_pipe ON valve USING btree (fk_pipe);


--
-- Name: fki_valve_fk_type; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_valve_fk_type ON valve USING btree (fk_valve_type);


--
-- Name: fki_valve_fk_valve_actuation; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX fki_valve_fk_valve_actuation ON valve USING btree (fk_valve_actuation);


--
-- Name: folder_geoidx_line; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX folder_geoidx_line ON folder USING gist (geometry_line);


--
-- Name: folder_geoidx_polygon; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX folder_geoidx_polygon ON folder USING gist (geometry_polygon);


--
-- Name: installation_poly_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX installation_poly_geoidx ON installation USING gist (geometry_polygon);


--
-- Name: meter_reference_geoidx_sch; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX meter_reference_geoidx_sch ON meter_reference USING gist (geometry);


--
-- Name: node_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX node_geoidx ON node USING gist (geometry);


--
-- Name: node_geoidx_alt1; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX node_geoidx_alt1 ON node USING gist (geometry_alt1);


--
-- Name: node_geoidx_alt2; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX node_geoidx_alt2 ON node USING gist (geometry_alt2);


--
-- Name: pipe_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX pipe_geoidx ON pipe USING gist (geometry);


--
-- Name: pipe_geoidx_alt1; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX pipe_geoidx_alt1 ON pipe USING gist (geometry_alt1);


--
-- Name: pipe_geoidx_alt2; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX pipe_geoidx_alt2 ON pipe USING gist (geometry_alt2);


--
-- Name: pressurezone_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX pressurezone_geoidx ON pressurezone USING gist (geometry);


--
-- Name: pressurezone_geoidx_alt1; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX pressurezone_geoidx_alt1 ON pressurezone USING gist (geometry_alt1);


--
-- Name: pressurezone_geoidx_alt2; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX pressurezone_geoidx_alt2 ON pressurezone USING gist (geometry_alt2);


--
-- Name: printmap_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX printmap_geoidx ON printmap USING gist (geometry);


--
-- Name: protectionzone_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX protectionzone_geoidx ON protectionzone USING gist (geometry);


--
-- Name: remote_geoidx; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX remote_geoidx ON remote USING gist (geometry);


--
-- Name: remote_geoidx_alt1; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX remote_geoidx_alt1 ON remote USING gist (geometry_alt1);


--
-- Name: remote_geoidx_alt2; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX remote_geoidx_alt2 ON remote USING gist (geometry_alt2);


--
-- Name: subscriber_reference_geoidx_sch; Type: INDEX; Schema: qwat_od; Owner: postgres
--

CREATE INDEX subscriber_reference_geoidx_sch ON subscriber_reference USING gist (geometry);


SET search_path = qwat_sys, pg_catalog;

--
-- Name: logged_actions_action_idx; Type: INDEX; Schema: qwat_sys; Owner: postgres
--

CREATE INDEX logged_actions_action_idx ON logged_actions USING btree (action);


--
-- Name: logged_actions_action_tstamp_tx_stm_idx; Type: INDEX; Schema: qwat_sys; Owner: postgres
--

CREATE INDEX logged_actions_action_tstamp_tx_stm_idx ON logged_actions USING btree (action_tstamp_stm);


--
-- Name: logged_actions_relid_idx; Type: INDEX; Schema: qwat_sys; Owner: postgres
--

CREATE INDEX logged_actions_relid_idx ON logged_actions USING btree (relid);


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_consumptionzone rl_consumptionzone_delete; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_consumptionzone_delete AS
    ON DELETE TO vw_consumptionzone DO INSTEAD  DELETE FROM consumptionzone
  WHERE (consumptionzone.id = old.id);


--
-- Name: vw_consumptionzone rl_consumptionzone_insert; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_consumptionzone_insert AS
    ON INSERT TO vw_consumptionzone DO INSTEAD  INSERT INTO consumptionzone (name, population, colorcode)
  VALUES (new.name, new.population, new.colorcode);


--
-- Name: vw_consumptionzone rl_consumptionzone_update; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_consumptionzone_update AS
    ON UPDATE TO vw_consumptionzone DO INSTEAD  UPDATE consumptionzone SET name = new.name, population = new.population, colorcode = new.colorcode
  WHERE (consumptionzone.id = new.id);


--
-- Name: pipe rl_crossing_delete; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_crossing_delete AS
    ON DELETE TO pipe DO  DELETE FROM crossing
  WHERE ((crossing._pipe1_id = old.id) OR (crossing._pipe2_id = old.id));


--
-- Name: vw_pipe_schema_visibleitems rl_pipe_delete_alternative; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_pipe_delete_alternative AS
    ON DELETE TO vw_pipe_schema_visibleitems DO INSTEAD  UPDATE pipe SET schema_force_visible = false
  WHERE (pipe.id = old.id);


--
-- Name: vw_pipe_schema rl_pipe_schema_label; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_pipe_schema_label AS
    ON UPDATE TO vw_pipe_schema DO INSTEAD  UPDATE pipe SET label_2_visible = new.label_2_visible, label_2_text = new.label_2_text
  WHERE (pipe.id = old.id);


--
-- Name: vw_pipe_schema_visibleitems rl_pipe_update_alternative; Type: RULE; Schema: qwat_od; Owner: postgres
--

CREATE RULE rl_pipe_update_alternative AS
    ON UPDATE TO vw_pipe_schema_visibleitems DO INSTEAD  UPDATE pipe SET fk_parent = new.fk_parent, schema_force_visible = new.schema_force_visible, geometry_alt2 = new.geometry
  WHERE (pipe.id = new.id);


SET search_path = qwat_dr, pg_catalog;

--
-- Name: annotationline audit_trigger_row; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON annotationline FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: annotationpoint audit_trigger_row; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON annotationpoint FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: constructionpoint audit_trigger_row; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON constructionpoint FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: dimension_distance audit_trigger_row; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON dimension_distance FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: dimension_orientation audit_trigger_row; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON dimension_orientation FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: annotationline audit_trigger_stm; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON annotationline FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: annotationpoint audit_trigger_stm; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON annotationpoint FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: constructionpoint audit_trigger_stm; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON constructionpoint FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: dimension_distance audit_trigger_stm; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON dimension_distance FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: dimension_orientation audit_trigger_stm; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON dimension_orientation FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: dimension_distance tr_dimension_distance; Type: TRIGGER; Schema: qwat_dr; Owner: postgres
--

CREATE TRIGGER tr_dimension_distance BEFORE INSERT OR UPDATE OF geometry ON dimension_distance FOR EACH ROW EXECUTE PROCEDURE ft_dimension_distance_distance();


--
-- Name: TRIGGER tr_dimension_distance ON dimension_distance; Type: COMMENT; Schema: qwat_dr; Owner: postgres
--

COMMENT ON TRIGGER tr_dimension_distance ON dimension_distance IS 'Trigger: updates the length and other fields of the pipe after insert/update.';


SET search_path = qwat_od, pg_catalog;

--
-- Name: distributor audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON distributor FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: district audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON district FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: hydrant audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON hydrant FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: installation audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON installation FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pressurecontrol audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pressurecontrol FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pump audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pump FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: source audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON source FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: treatment audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON treatment FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: tank audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON tank FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: chamber audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON chamber FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: leak audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON leak FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: meter audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON meter FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pipe FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pressurezone audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pressurezone FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: printmap audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON printmap FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: protectionzone audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON protectionzone FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: samplingpoint audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON samplingpoint FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: subscriber audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON subscriber FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: subscriber_reference audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON subscriber_reference FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: surveypoint audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON surveypoint FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve audit_trigger_row; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON valve FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: distributor audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON distributor FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: district audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON district FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: hydrant audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON hydrant FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: installation audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON installation FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pressurecontrol audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pressurecontrol FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pump audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pump FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: source audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON source FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: treatment audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON treatment FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: tank audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON tank FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: chamber audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON chamber FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: leak audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON leak FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: meter audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON meter FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pipe FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pressurezone audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pressurezone FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: printmap audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON printmap FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: protectionzone audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON protectionzone FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: samplingpoint audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON samplingpoint FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: subscriber audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON subscriber FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: subscriber_reference audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON subscriber_reference FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: surveypoint audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON surveypoint FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve audit_trigger_stm; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON valve FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: cover cover_altitude_insert_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER cover_altitude_insert_trigger BEFORE INSERT ON cover FOR EACH ROW EXECUTE PROCEDURE ft_geom3d_altitude();


--
-- Name: TRIGGER cover_altitude_insert_trigger ON cover; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER cover_altitude_insert_trigger ON cover IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: cover cover_altitude_update_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER cover_altitude_update_trigger BEFORE UPDATE OF altitude, geometry ON cover FOR EACH ROW WHEN (((new.altitude <> old.altitude) OR (public.st_z(new.geometry) <> public.st_z(old.geometry)))) EXECUTE PROCEDURE ft_geom3d_altitude();


--
-- Name: TRIGGER cover_altitude_update_trigger ON cover; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER cover_altitude_update_trigger ON cover IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: surveypoint surveypoint_altitude_insert_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER surveypoint_altitude_insert_trigger BEFORE INSERT ON surveypoint FOR EACH ROW EXECUTE PROCEDURE ft_geom3d_altitude();


--
-- Name: TRIGGER surveypoint_altitude_insert_trigger ON surveypoint; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER surveypoint_altitude_insert_trigger ON surveypoint IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: surveypoint surveypoint_altitude_update_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER surveypoint_altitude_update_trigger BEFORE UPDATE OF altitude, geometry ON surveypoint FOR EACH ROW WHEN (((new.altitude <> old.altitude) OR (public.st_z(new.geometry) <> public.st_z(old.geometry)))) EXECUTE PROCEDURE ft_geom3d_altitude();


--
-- Name: TRIGGER surveypoint_altitude_update_trigger ON surveypoint; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER surveypoint_altitude_update_trigger ON surveypoint IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: crossing tr_controled_crossing; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_controled_crossing BEFORE UPDATE ON crossing FOR EACH ROW WHEN ((new.hide_pipe <> old.hide_pipe)) EXECUTE PROCEDURE ft_controled_crossing();


--
-- Name: vw_element_hydrant tr_element_hydrant_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_hydrant_delete INSTEAD OF DELETE ON vw_element_hydrant FOR EACH ROW EXECUTE PROCEDURE ft_element_hydrant_delete();


--
-- Name: vw_element_hydrant tr_element_hydrant_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_hydrant_insert INSTEAD OF INSERT ON vw_element_hydrant FOR EACH ROW EXECUTE PROCEDURE ft_element_hydrant_insert();


--
-- Name: vw_element_hydrant tr_element_hydrant_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_hydrant_update INSTEAD OF UPDATE ON vw_element_hydrant FOR EACH ROW EXECUTE PROCEDURE ft_element_hydrant_update();


--
-- Name: vw_element_installation tr_element_installation_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_installation_delete INSTEAD OF DELETE ON vw_element_installation FOR EACH ROW EXECUTE PROCEDURE ft_element_installation_delete();


--
-- Name: vw_element_installation tr_element_installation_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_installation_insert INSTEAD OF INSERT ON vw_element_installation FOR EACH ROW EXECUTE PROCEDURE ft_element_installation_insert();


--
-- Name: vw_element_installation tr_element_installation_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_installation_update INSTEAD OF UPDATE ON vw_element_installation FOR EACH ROW EXECUTE PROCEDURE ft_element_installation_update();


--
-- Name: vw_element_meter tr_element_meter_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_meter_delete INSTEAD OF DELETE ON vw_element_meter FOR EACH ROW EXECUTE PROCEDURE ft_element_meter_delete();


--
-- Name: vw_element_meter tr_element_meter_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_meter_insert INSTEAD OF INSERT ON vw_element_meter FOR EACH ROW EXECUTE PROCEDURE ft_element_meter_insert();


--
-- Name: vw_element_meter tr_element_meter_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_meter_update INSTEAD OF UPDATE ON vw_element_meter FOR EACH ROW EXECUTE PROCEDURE ft_element_meter_update();


--
-- Name: vw_element_part tr_element_part_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_part_delete INSTEAD OF DELETE ON vw_element_part FOR EACH ROW EXECUTE PROCEDURE ft_element_part_delete();


--
-- Name: vw_element_part tr_element_part_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_part_insert INSTEAD OF INSERT ON vw_element_part FOR EACH ROW EXECUTE PROCEDURE ft_element_part_insert();


--
-- Name: vw_element_part tr_element_part_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_part_update INSTEAD OF UPDATE ON vw_element_part FOR EACH ROW EXECUTE PROCEDURE ft_element_part_update();


--
-- Name: vw_element_samplingpoint tr_element_samplingpoint_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_samplingpoint_delete INSTEAD OF DELETE ON vw_element_samplingpoint FOR EACH ROW EXECUTE PROCEDURE ft_element_samplingpoint_delete();


--
-- Name: vw_element_samplingpoint tr_element_samplingpoint_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_samplingpoint_insert INSTEAD OF INSERT ON vw_element_samplingpoint FOR EACH ROW EXECUTE PROCEDURE ft_element_samplingpoint_insert();


--
-- Name: vw_element_samplingpoint tr_element_samplingpoint_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_samplingpoint_update INSTEAD OF UPDATE ON vw_element_samplingpoint FOR EACH ROW EXECUTE PROCEDURE ft_element_samplingpoint_update();


--
-- Name: vw_element_subscriber tr_element_subscriber_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_subscriber_delete INSTEAD OF DELETE ON vw_element_subscriber FOR EACH ROW EXECUTE PROCEDURE ft_element_subscriber_delete();


--
-- Name: vw_element_subscriber tr_element_subscriber_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_subscriber_insert INSTEAD OF INSERT ON vw_element_subscriber FOR EACH ROW EXECUTE PROCEDURE ft_element_subscriber_insert();


--
-- Name: vw_element_subscriber tr_element_subscriber_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_subscriber_update INSTEAD OF UPDATE ON vw_element_subscriber FOR EACH ROW EXECUTE PROCEDURE ft_element_subscriber_update();


--
-- Name: vw_element_valve tr_element_valve_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_valve_delete INSTEAD OF DELETE ON vw_element_valve FOR EACH ROW EXECUTE PROCEDURE ft_element_valve_delete();


--
-- Name: vw_element_valve tr_element_valve_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_valve_insert INSTEAD OF INSERT ON vw_element_valve FOR EACH ROW EXECUTE PROCEDURE ft_element_valve_insert();


--
-- Name: vw_element_valve tr_element_valve_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_element_valve_update INSTEAD OF UPDATE ON vw_element_valve FOR EACH ROW EXECUTE PROCEDURE ft_element_valve_update();


--
-- Name: vw_installation_chamber tr_installation_chamber_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_chamber_delete INSTEAD OF DELETE ON vw_installation_chamber FOR EACH ROW EXECUTE PROCEDURE ft_installation_chamber_delete();


--
-- Name: vw_installation_chamber tr_installation_chamber_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_chamber_insert INSTEAD OF INSERT ON vw_installation_chamber FOR EACH ROW EXECUTE PROCEDURE ft_installation_chamber_insert();


--
-- Name: vw_installation_chamber tr_installation_chamber_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_chamber_update INSTEAD OF UPDATE ON vw_installation_chamber FOR EACH ROW EXECUTE PROCEDURE ft_installation_chamber_update();


--
-- Name: vw_installation_pressurecontrol tr_installation_pressurecontrol_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_pressurecontrol_delete INSTEAD OF DELETE ON vw_installation_pressurecontrol FOR EACH ROW EXECUTE PROCEDURE ft_installation_pressurecontrol_delete();


--
-- Name: vw_installation_pressurecontrol tr_installation_pressurecontrol_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_pressurecontrol_insert INSTEAD OF INSERT ON vw_installation_pressurecontrol FOR EACH ROW EXECUTE PROCEDURE ft_installation_pressurecontrol_insert();


--
-- Name: vw_installation_pressurecontrol tr_installation_pressurecontrol_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_pressurecontrol_update INSTEAD OF UPDATE ON vw_installation_pressurecontrol FOR EACH ROW EXECUTE PROCEDURE ft_installation_pressurecontrol_update();


--
-- Name: vw_installation_pump tr_installation_pump_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_pump_delete INSTEAD OF DELETE ON vw_installation_pump FOR EACH ROW EXECUTE PROCEDURE ft_installation_pump_delete();


--
-- Name: vw_installation_pump tr_installation_pump_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_pump_insert INSTEAD OF INSERT ON vw_installation_pump FOR EACH ROW EXECUTE PROCEDURE ft_installation_pump_insert();


--
-- Name: vw_installation_pump tr_installation_pump_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_pump_update INSTEAD OF UPDATE ON vw_installation_pump FOR EACH ROW EXECUTE PROCEDURE ft_installation_pump_update();


--
-- Name: vw_installation_source tr_installation_source_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_source_delete INSTEAD OF DELETE ON vw_installation_source FOR EACH ROW EXECUTE PROCEDURE ft_installation_source_delete();


--
-- Name: vw_installation_source tr_installation_source_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_source_insert INSTEAD OF INSERT ON vw_installation_source FOR EACH ROW EXECUTE PROCEDURE ft_installation_source_insert();


--
-- Name: vw_installation_source tr_installation_source_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_source_update INSTEAD OF UPDATE ON vw_installation_source FOR EACH ROW EXECUTE PROCEDURE ft_installation_source_update();


--
-- Name: vw_installation_tank tr_installation_tank_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_tank_delete INSTEAD OF DELETE ON vw_installation_tank FOR EACH ROW EXECUTE PROCEDURE ft_installation_tank_delete();


--
-- Name: vw_installation_tank tr_installation_tank_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_tank_insert INSTEAD OF INSERT ON vw_installation_tank FOR EACH ROW EXECUTE PROCEDURE ft_installation_tank_insert();


--
-- Name: vw_installation_tank tr_installation_tank_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_tank_update INSTEAD OF UPDATE ON vw_installation_tank FOR EACH ROW EXECUTE PROCEDURE ft_installation_tank_update();


--
-- Name: vw_installation_treatment tr_installation_treatment_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_treatment_delete INSTEAD OF DELETE ON vw_installation_treatment FOR EACH ROW EXECUTE PROCEDURE ft_installation_treatment_delete();


--
-- Name: vw_installation_treatment tr_installation_treatment_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_treatment_insert INSTEAD OF INSERT ON vw_installation_treatment FOR EACH ROW EXECUTE PROCEDURE ft_installation_treatment_insert();


--
-- Name: vw_installation_treatment tr_installation_treatment_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_installation_treatment_update INSTEAD OF UPDATE ON vw_installation_treatment FOR EACH ROW EXECUTE PROCEDURE ft_installation_treatment_update();


--
-- Name: leak tr_leak_pipe; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_leak_pipe BEFORE INSERT ON leak FOR EACH ROW EXECUTE PROCEDURE ft_leak_pipe();


--
-- Name: TRIGGER tr_leak_pipe ON leak; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_leak_pipe ON leak IS 'Trigger: get the pipe associated to the leak.';


--
-- Name: leak tr_leak_repaired; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_leak_repaired BEFORE INSERT OR UPDATE OF repair_date ON leak FOR EACH ROW EXECUTE PROCEDURE ft_leak_repaired();


--
-- Name: TRIGGER tr_leak_repaired ON leak; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_leak_repaired ON leak IS 'Trigger: updates the repaired status of the leak.';


--
-- Name: node tr_node_add_pipe_vertex_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_add_pipe_vertex_insert AFTER INSERT ON node FOR EACH ROW EXECUTE PROCEDURE ft_node_add_pipe_vertex();


--
-- Name: TRIGGER tr_node_add_pipe_vertex_insert ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_add_pipe_vertex_insert ON node IS 'Trigger: updates auto fields after insert.';


--
-- Name: node tr_node_add_pipe_vertex_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_add_pipe_vertex_update AFTER UPDATE OF geometry ON node FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_node_add_pipe_vertex();


--
-- Name: TRIGGER tr_node_add_pipe_vertex_update ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_add_pipe_vertex_update ON node IS 'Trigger: updates auto fields after geom update.';


--
-- Name: node tr_node_altgeom_alt; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_altgeom_alt BEFORE UPDATE OF geometry_alt1, geometry_alt2 ON node FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_aux();


--
-- Name: TRIGGER tr_node_altgeom_alt ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_altgeom_alt ON node IS 'Trigger: when updating, check if alternative geometries are different to fill the boolean fields.';


--
-- Name: node tr_node_altgeom_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_altgeom_insert BEFORE INSERT ON node FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_node_altgeom_insert ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_altgeom_insert ON node IS 'Trigger: handle alternative geometries on insert';


--
-- Name: node tr_node_altgeom_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_altgeom_update BEFORE UPDATE OF geometry ON node FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_node_altgeom_update ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_altgeom_update ON node IS 'Trigger: handle alternative geometries on update';


--
-- Name: vw_node_element tr_node_element_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_element_delete INSTEAD OF DELETE ON vw_node_element FOR EACH ROW EXECUTE PROCEDURE ft_node_element_delete();


--
-- Name: vw_node_element tr_node_element_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_element_insert INSTEAD OF INSERT ON vw_node_element FOR EACH ROW EXECUTE PROCEDURE ft_node_element_insert();


--
-- Name: vw_node_element tr_node_element_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_element_update INSTEAD OF UPDATE ON vw_node_element FOR EACH ROW EXECUTE PROCEDURE ft_node_element_update();


--
-- Name: node tr_node_geom_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_geom_insert BEFORE INSERT ON node FOR EACH ROW EXECUTE PROCEDURE ft_node_geom();


--
-- Name: TRIGGER tr_node_geom_insert ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_geom_insert ON node IS 'Trigger: updates auto fields after insert.';


--
-- Name: node tr_node_geom_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_node_geom_update BEFORE UPDATE OF geometry ON node FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_node_geom();


--
-- Name: TRIGGER tr_node_geom_update ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_node_geom_update ON node IS 'Trigger: updates auto fields after geom update.';


--
-- Name: pipe tr_pipe_altgeom_alt; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_altgeom_alt BEFORE UPDATE OF geometry_alt1, geometry_alt2 ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_aux();


--
-- Name: TRIGGER tr_pipe_altgeom_alt ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_altgeom_alt ON pipe IS 'Trigger: when updating, check if alternative geometries are different to fill the boolean fields.';


--
-- Name: pipe tr_pipe_altgeom_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_altgeom_insert BEFORE INSERT ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_pipe_altgeom_insert ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_altgeom_insert ON pipe IS 'Trigger: handle alternative geometries on insert';


--
-- Name: pipe tr_pipe_altgeom_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_altgeom_update BEFORE UPDATE OF geometry ON pipe FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_pipe_altgeom_update ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_altgeom_update ON pipe IS 'Trigger: handle alternative geometries on update';


--
-- Name: pipe tr_pipe_geom_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_geom_insert BEFORE INSERT ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_pipe_geom();


--
-- Name: TRIGGER tr_pipe_geom_insert ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_geom_insert ON pipe IS 'Trigger: updates auto fields of the pipe after insert.';


--
-- Name: pipe tr_pipe_geom_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_geom_update BEFORE UPDATE OF geometry ON pipe FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_pipe_geom();


--
-- Name: TRIGGER tr_pipe_geom_update ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_geom_update ON pipe IS 'Trigger: updates auto fields of the pipe after geom update.';


--
-- Name: node tr_pipe_node_moved; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_node_moved AFTER UPDATE OF geometry ON node FOR EACH ROW EXECUTE PROCEDURE ft_pipe_node_moved();


--
-- Name: TRIGGER tr_pipe_node_moved ON node; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_node_moved ON node IS 'Trigger: if a network element (i.e. a node) has moved, then reaasign the nodes for the pipe. Do it after update.';


--
-- Name: pipe tr_pipe_node_type_insdel; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_node_type_insdel AFTER INSERT OR DELETE ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_pipe_node_type();


--
-- Name: TRIGGER tr_pipe_node_type_insdel ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_node_type_insdel ON pipe IS 'Trigger: after insert or delete of a pipe, set the type of nodes / clean the nodes.';


--
-- Name: pipe tr_pipe_node_type_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_node_type_update AFTER UPDATE OF geometry ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_pipe_node_type();


--
-- Name: TRIGGER tr_pipe_node_type_update ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_node_type_update ON pipe IS 'Trigger: after updating of a pipe geometry, set the type of nodes / clean the nodes.';


--
-- Name: pipe tr_pipe_tunnelbridge; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pipe_tunnelbridge BEFORE INSERT OR UPDATE OF tunnel_or_bridge ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_pipe_tunnelbridge();


--
-- Name: TRIGGER tr_pipe_tunnelbridge ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pipe_tunnelbridge ON pipe IS 'For tunnel and bridges, 3d length is the 2d length (i.e. pipes are considered as horinzontal).';


--
-- Name: pressurezone tr_pressurezone_altgeom_alt; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pressurezone_altgeom_alt BEFORE UPDATE OF geometry_alt1, geometry_alt2 ON pressurezone FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_aux();


--
-- Name: TRIGGER tr_pressurezone_altgeom_alt ON pressurezone; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pressurezone_altgeom_alt ON pressurezone IS 'Trigger: when updating, check if alternative geometries are different to fill the boolean fields.';


--
-- Name: pressurezone tr_pressurezone_altgeom_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pressurezone_altgeom_insert BEFORE INSERT ON pressurezone FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_pressurezone_altgeom_insert ON pressurezone; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pressurezone_altgeom_insert ON pressurezone IS 'Trigger: handle alternative geometries on insert';


--
-- Name: pressurezone tr_pressurezone_altgeom_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_pressurezone_altgeom_update BEFORE UPDATE OF geometry ON pressurezone FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_pressurezone_altgeom_update ON pressurezone; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_pressurezone_altgeom_update ON pressurezone IS 'Trigger: handle alternative geometries on update';


--
-- Name: remote tr_remote_altgeom_alt; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_remote_altgeom_alt BEFORE UPDATE OF geometry_alt1, geometry_alt2 ON remote FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_aux();


--
-- Name: TRIGGER tr_remote_altgeom_alt ON remote; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_remote_altgeom_alt ON remote IS 'Trigger: when updating, check if alternative geometries are different to fill the boolean fields.';


--
-- Name: remote tr_remote_altgeom_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_remote_altgeom_insert BEFORE INSERT ON remote FOR EACH ROW EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_remote_altgeom_insert ON remote; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_remote_altgeom_insert ON remote IS 'Trigger: handle alternative geometries on insert';


--
-- Name: remote tr_remote_altgeom_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_remote_altgeom_update BEFORE UPDATE OF geometry ON remote FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_geometry_alternative_main();


--
-- Name: TRIGGER tr_remote_altgeom_update ON remote; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_remote_altgeom_update ON remote IS 'Trigger: handle alternative geometries on update';


--
-- Name: tank tr_tank; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_tank BEFORE INSERT OR UPDATE OF cistern1_fk_type, cistern1_dimension_1, cistern1_dimension_2, cistern2_fk_type, cistern2_dimension_1, cistern2_dimension_2 ON tank FOR EACH ROW EXECUTE PROCEDURE ft_tank();


--
-- Name: pipe tr_valve_pipe_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_valve_pipe_delete AFTER DELETE ON pipe FOR EACH ROW EXECUTE PROCEDURE ft_valve_pipe_update();


--
-- Name: TRIGGER tr_valve_pipe_delete ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_valve_pipe_delete ON pipe IS 'Trigger: when deleting a pipe, reassign the pipe to all valves connected to the old pipe. Do an AFTER trigger since it will update valve after updating the node.';


--
-- Name: pipe tr_valve_pipe_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_valve_pipe_update AFTER UPDATE OF geometry ON pipe FOR EACH ROW WHEN ((public.st_equals(public.st_force2d(new.geometry), public.st_force2d(old.geometry)) IS FALSE)) EXECUTE PROCEDURE ft_valve_pipe_update();


--
-- Name: TRIGGER tr_valve_pipe_update ON pipe; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_valve_pipe_update ON pipe IS 'Trigger: when moving a pipe, reassign the pipe to all valves connected to the old pipe. Do an AFTER trigger since it will update valve after updating the node.';


--
-- Name: valve tr_valve_update_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_valve_update_trigger AFTER UPDATE ON valve FOR EACH ROW EXECUTE PROCEDURE ft_valve_update();


--
-- Name: TRIGGER tr_valve_update_trigger ON valve; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER tr_valve_update_trigger ON valve IS 'Trigger: when updating a valve, reevaluate old and new pipes.';


--
-- Name: vw_qwat_installation tr_vw_qwat_installation_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_installation_delete INSTEAD OF DELETE ON vw_qwat_installation FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_installation_delete();


--
-- Name: vw_qwat_installation tr_vw_qwat_installation_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_installation_insert INSTEAD OF INSERT ON vw_qwat_installation FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_installation_insert();


--
-- Name: vw_qwat_installation tr_vw_qwat_installation_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_installation_update INSTEAD OF UPDATE ON vw_qwat_installation FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_installation_update();


--
-- Name: vw_qwat_network_element tr_vw_qwat_network_element_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_network_element_delete INSTEAD OF DELETE ON vw_qwat_network_element FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_network_element_delete();


--
-- Name: vw_qwat_network_element tr_vw_qwat_network_element_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_network_element_insert INSTEAD OF INSERT ON vw_qwat_network_element FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_network_element_insert();


--
-- Name: vw_qwat_network_element tr_vw_qwat_network_element_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_network_element_update INSTEAD OF UPDATE ON vw_qwat_network_element FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_network_element_update();


--
-- Name: vw_qwat_node tr_vw_qwat_node_delete; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_node_delete INSTEAD OF DELETE ON vw_qwat_node FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_node_delete();


--
-- Name: vw_qwat_node tr_vw_qwat_node_insert; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_node_insert INSTEAD OF INSERT ON vw_qwat_node FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_node_insert();


--
-- Name: vw_qwat_node tr_vw_qwat_node_update; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER tr_vw_qwat_node_update INSTEAD OF UPDATE ON vw_qwat_node FOR EACH ROW EXECUTE PROCEDURE ft_vw_qwat_node_update();


--
-- Name: valve valve_handle_altitude_insert_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER valve_handle_altitude_insert_trigger BEFORE INSERT ON valve FOR EACH ROW EXECUTE PROCEDURE ft_valve_handle_altitude();


--
-- Name: TRIGGER valve_handle_altitude_insert_trigger ON valve; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER valve_handle_altitude_insert_trigger ON valve IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: valve valve_handle_altitude_update_trigger; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER valve_handle_altitude_update_trigger BEFORE UPDATE OF handle_altitude, handle_geometry ON valve FOR EACH ROW WHEN (((new.handle_altitude <> old.handle_altitude) OR (public.st_z(new.handle_geometry) <> public.st_z(old.handle_geometry)))) EXECUTE PROCEDURE ft_valve_handle_altitude();


--
-- Name: TRIGGER valve_handle_altitude_update_trigger ON valve; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER valve_handle_altitude_update_trigger ON valve IS 'Trigger: when updating, check if altitude or Z value of geometry changed and synchronize them.';


--
-- Name: valve valve_node_set_type; Type: TRIGGER; Schema: qwat_od; Owner: postgres
--

CREATE TRIGGER valve_node_set_type AFTER INSERT ON valve FOR EACH ROW EXECUTE PROCEDURE ft_valve_node_set_type();


--
-- Name: TRIGGER valve_node_set_type ON valve; Type: COMMENT; Schema: qwat_od; Owner: postgres
--

COMMENT ON TRIGGER valve_node_set_type ON valve IS 'Trigger: set-type of node after inserting a valve (to get orientation).';


SET search_path = qwat_sys, pg_catalog;

--
-- Name: settings tr_setting_create_fn_get_insert; Type: TRIGGER; Schema: qwat_sys; Owner: postgres
--

CREATE TRIGGER tr_setting_create_fn_get_insert BEFORE INSERT OR DELETE ON settings FOR EACH ROW EXECUTE PROCEDURE ft_setting_create_fn_get();


--
-- Name: TRIGGER tr_setting_create_fn_get_insert ON settings; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON TRIGGER tr_setting_create_fn_get_insert ON settings IS 'Trigger: automatically create get function for inserted settings';


--
-- Name: settings tr_setting_create_fn_get_update; Type: TRIGGER; Schema: qwat_sys; Owner: postgres
--

CREATE TRIGGER tr_setting_create_fn_get_update BEFORE UPDATE OF type, name ON settings FOR EACH ROW WHEN ((((new.type)::oid <> (old.type)::oid) OR ((old.name)::text <> (new.name)::text))) EXECUTE PROCEDURE ft_setting_create_fn_get();


--
-- Name: TRIGGER tr_setting_create_fn_get_update ON settings; Type: COMMENT; Schema: qwat_sys; Owner: postgres
--

COMMENT ON TRIGGER tr_setting_create_fn_get_update ON settings IS 'Trigger: automatically create get function for inserted settings';


SET search_path = qwat_vl, pg_catalog;

--
-- Name: cistern audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON cistern FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: hydrant_provider audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON hydrant_provider FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: hydrant_material audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON hydrant_material FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: leak_cause audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON leak_cause FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: overflow audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON overflow FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_function audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pipe_function FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_installmethod audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pipe_installmethod FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_material audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pipe_material FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_protection audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pipe_protection FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: precision audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON "precision" FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pressurecontrol_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pressurecontrol_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: protectionzone_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON protectionzone_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pump_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON pump_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: remote_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON remote_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: source_quality audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON source_quality FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: source_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON source_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: status audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON status FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: subscriber_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON subscriber_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: survey_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON survey_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: tank_firestorage audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON tank_firestorage FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_function audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON valve_function FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_maintenance audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON valve_maintenance FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_actuation audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON valve_actuation FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_type audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON valve_type FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: visible audit_trigger_row; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_row AFTER INSERT OR DELETE OR UPDATE ON visible FOR EACH ROW EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: cistern audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON cistern FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: hydrant_provider audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON hydrant_provider FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: hydrant_material audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON hydrant_material FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: leak_cause audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON leak_cause FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: overflow audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON overflow FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_function audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pipe_function FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_installmethod audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pipe_installmethod FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_material audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pipe_material FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_protection audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pipe_protection FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: precision audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON "precision" FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pressurecontrol_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pressurecontrol_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: protectionzone_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON protectionzone_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pump_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON pump_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: remote_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON remote_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: source_quality audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON source_quality FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: source_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON source_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: status audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON status FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: subscriber_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON subscriber_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: survey_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON survey_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: tank_firestorage audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON tank_firestorage FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_function audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON valve_function FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_maintenance audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON valve_maintenance FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_actuation audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON valve_actuation FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: valve_type audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON valve_type FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: visible audit_trigger_stm; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON visible FOR EACH STATEMENT EXECUTE PROCEDURE qwat_sys.if_modified_func('true');


--
-- Name: pipe_material tr_fancy_value; Type: TRIGGER; Schema: qwat_vl; Owner: postgres
--

CREATE TRIGGER tr_fancy_value BEFORE INSERT OR UPDATE OF short_fr, short_ro, short_en, diameter ON pipe_material FOR EACH ROW EXECUTE PROCEDURE pipe_material_displayname();


--
-- Name: TRIGGER tr_fancy_value ON pipe_material; Type: COMMENT; Schema: qwat_vl; Owner: postgres
--

COMMENT ON TRIGGER tr_fancy_value ON pipe_material IS 'Trigger: updates the fancy value_fr, value_ro and value_en in the material table.';


SET search_path = qwat_dr, pg_catalog;

--
-- Name: constructionpoint constructionpoint_fk_object_reference; Type: FK CONSTRAINT; Schema: qwat_dr; Owner: postgres
--

ALTER TABLE ONLY constructionpoint
    ADD CONSTRAINT constructionpoint_fk_object_reference FOREIGN KEY (fk_object_reference) REFERENCES qwat_vl.object_reference(id) MATCH FULL;


SET search_path = qwat_od, pg_catalog;

--
-- Name: chamber chamber_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY chamber
    ADD CONSTRAINT chamber_id_fkey FOREIGN KEY (id) REFERENCES installation(id);


--
-- Name: cover cover_fk_installation; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY cover
    ADD CONSTRAINT cover_fk_installation FOREIGN KEY (fk_installation) REFERENCES installation(id) MATCH FULL;


--
-- Name: cover cover_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY cover
    ADD CONSTRAINT cover_fk_type FOREIGN KEY (fk_cover_type) REFERENCES qwat_vl.cover_type(id) MATCH FULL;


--
-- Name: cover cover_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY cover
    ADD CONSTRAINT cover_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: cover cover_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY cover
    ADD CONSTRAINT cover_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: crossing crossing_pipe1; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY crossing
    ADD CONSTRAINT crossing_pipe1 FOREIGN KEY (_pipe1_id) REFERENCES pipe(id) MATCH FULL;


--
-- Name: crossing crossing_pipe2; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY crossing
    ADD CONSTRAINT crossing_pipe2 FOREIGN KEY (_pipe2_id) REFERENCES pipe(id) MATCH FULL;


--
-- Name: district district_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY district
    ADD CONSTRAINT district_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: district district_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY district
    ADD CONSTRAINT district_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: network_element element_fk_distributor; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT element_fk_distributor FOREIGN KEY (fk_distributor) REFERENCES distributor(id) MATCH FULL;


--
-- Name: network_element element_fk_folder; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT element_fk_folder FOREIGN KEY (fk_folder) REFERENCES folder(id) MATCH FULL;


--
-- Name: network_element element_fk_object_reference; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT element_fk_object_reference FOREIGN KEY (fk_object_reference) REFERENCES qwat_vl.object_reference(id) MATCH FULL;


--
-- Name: network_element element_fk_precision; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT element_fk_precision FOREIGN KEY (fk_precision) REFERENCES qwat_vl."precision"(id) MATCH FULL;


--
-- Name: network_element element_fk_precisionalti; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT element_fk_precisionalti FOREIGN KEY (fk_precisionalti) REFERENCES qwat_vl.precisionalti(id) MATCH FULL;


--
-- Name: network_element element_fk_status; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT element_fk_status FOREIGN KEY (fk_status) REFERENCES qwat_vl.status(id) MATCH FULL;


--
-- Name: hydrant hydrant_fk_material; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_fk_material FOREIGN KEY (fk_material) REFERENCES qwat_vl.hydrant_material(id) MATCH FULL;


--
-- Name: hydrant hydrant_fk_model_inf; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_fk_model_inf FOREIGN KEY (fk_model_inf) REFERENCES qwat_vl.hydrant_model_inf(id) MATCH FULL;


--
-- Name: hydrant hydrant_fk_model_sup; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_fk_model_sup FOREIGN KEY (fk_model_sup) REFERENCES qwat_vl.hydrant_model_sup(id) MATCH FULL;


--
-- Name: hydrant hydrant_fk_output; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_fk_output FOREIGN KEY (fk_output) REFERENCES qwat_vl.hydrant_output(id) MATCH FULL;


--
-- Name: hydrant hydrant_fk_provider; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_fk_provider FOREIGN KEY (fk_provider) REFERENCES qwat_vl.hydrant_provider(id) MATCH FULL;


--
-- Name: hydrant hydrant_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY hydrant
    ADD CONSTRAINT hydrant_id_fkey FOREIGN KEY (id) REFERENCES network_element(id);


--
-- Name: installation installation_fk_parent; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY installation
    ADD CONSTRAINT installation_fk_parent FOREIGN KEY (fk_parent) REFERENCES installation(id) MATCH FULL;


--
-- Name: installation installation_fk_remote; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY installation
    ADD CONSTRAINT installation_fk_remote FOREIGN KEY (fk_remote) REFERENCES qwat_vl.remote_type(id) MATCH FULL;


--
-- Name: installation installation_fk_watertype; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY installation
    ADD CONSTRAINT installation_fk_watertype FOREIGN KEY (fk_watertype) REFERENCES qwat_vl.watertype(id) MATCH FULL;


--
-- Name: installation installation_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY installation
    ADD CONSTRAINT installation_id_fkey FOREIGN KEY (id) REFERENCES network_element(id);


--
-- Name: leak leak_fk_cause; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY leak
    ADD CONSTRAINT leak_fk_cause FOREIGN KEY (fk_cause) REFERENCES qwat_vl.leak_cause(id) MATCH FULL;


--
-- Name: leak leak_fk_pipe; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY leak
    ADD CONSTRAINT leak_fk_pipe FOREIGN KEY (fk_pipe) REFERENCES pipe(id) MATCH FULL;


--
-- Name: leak leak_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY leak
    ADD CONSTRAINT leak_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: leak leak_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY leak
    ADD CONSTRAINT leak_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: meter meter_fk_pipe; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY meter
    ADD CONSTRAINT meter_fk_pipe FOREIGN KEY (fk_pipe) REFERENCES pipe(id) MATCH FULL;


--
-- Name: meter meter_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY meter
    ADD CONSTRAINT meter_id_fkey FOREIGN KEY (id) REFERENCES network_element(id);


--
-- Name: meter_reference meter_reference_fk_meter; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY meter_reference
    ADD CONSTRAINT meter_reference_fk_meter FOREIGN KEY (fk_meter) REFERENCES meter(id) MATCH FULL;


--
-- Name: network_element network_element_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT network_element_id_fkey FOREIGN KEY (id) REFERENCES node(id);


--
-- Name: network_element network_element_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT network_element_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: network_element network_element_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT network_element_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: network_element network_element_schema_force_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY network_element
    ADD CONSTRAINT network_element_schema_force_visible FOREIGN KEY (schema_force_visible) REFERENCES qwat_vl.visible(vl_code) MATCH FULL;


--
-- Name: node node_fk_district; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY node
    ADD CONSTRAINT node_fk_district FOREIGN KEY (fk_district) REFERENCES district(id) MATCH FULL;


--
-- Name: node node_fk_pressurezone; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY node
    ADD CONSTRAINT node_fk_pressurezone FOREIGN KEY (fk_pressurezone) REFERENCES pressurezone(id) MATCH FULL;


--
-- Name: part part_fk_pipe; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY part
    ADD CONSTRAINT part_fk_pipe FOREIGN KEY (fk_pipe) REFERENCES pipe(id) MATCH FULL;


--
-- Name: part part_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY part
    ADD CONSTRAINT part_fk_type FOREIGN KEY (fk_part_type) REFERENCES qwat_vl.part_type(id) MATCH FULL;


--
-- Name: part part_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY part
    ADD CONSTRAINT part_id_fkey FOREIGN KEY (id) REFERENCES part(id);


--
-- Name: pipe pipe_fk_bedding; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_bedding FOREIGN KEY (fk_bedding) REFERENCES qwat_vl.bedding(id) MATCH FULL;


--
-- Name: pipe pipe_fk_distributor; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_distributor FOREIGN KEY (fk_distributor) REFERENCES distributor(id) MATCH FULL;


--
-- Name: pipe pipe_fk_district; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_district FOREIGN KEY (fk_district) REFERENCES district(id) MATCH FULL;


--
-- Name: pipe pipe_fk_folder; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_folder FOREIGN KEY (fk_folder) REFERENCES folder(id) MATCH FULL;


--
-- Name: pipe pipe_fk_function; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_function FOREIGN KEY (fk_function) REFERENCES qwat_vl.pipe_function(id) MATCH FULL;


--
-- Name: pipe pipe_fk_installmethod; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_installmethod FOREIGN KEY (fk_installmethod) REFERENCES qwat_vl.pipe_installmethod(id) MATCH FULL;


--
-- Name: pipe pipe_fk_material; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_material FOREIGN KEY (fk_material) REFERENCES qwat_vl.pipe_material(id) MATCH FULL;


--
-- Name: pipe pipe_fk_node_a; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_node_a FOREIGN KEY (fk_node_a) REFERENCES node(id) MATCH FULL;


--
-- Name: pipe pipe_fk_node_b; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_node_b FOREIGN KEY (fk_node_b) REFERENCES node(id) MATCH FULL;


--
-- Name: pipe pipe_fk_parent; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_parent FOREIGN KEY (fk_parent) REFERENCES pipe(id) MATCH FULL;


--
-- Name: pipe pipe_fk_precision; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_precision FOREIGN KEY (fk_precision) REFERENCES qwat_vl."precision"(id) MATCH FULL;


--
-- Name: pipe pipe_fk_pressurezone; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_pressurezone FOREIGN KEY (fk_pressurezone) REFERENCES pressurezone(id) MATCH FULL;


--
-- Name: pipe pipe_fk_protection; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_protection FOREIGN KEY (fk_protection) REFERENCES qwat_vl.pipe_protection(id) MATCH FULL;


--
-- Name: pipe pipe_fk_status; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_status FOREIGN KEY (fk_status) REFERENCES qwat_vl.status(id) MATCH FULL;


--
-- Name: pipe pipe_fk_watertype; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_fk_watertype FOREIGN KEY (fk_watertype) REFERENCES qwat_vl.watertype(id) MATCH FULL;


--
-- Name: pipe pipe_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: pipe pipe_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: pipe pipe_schema_force_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pipe
    ADD CONSTRAINT pipe_schema_force_visible FOREIGN KEY (schema_force_visible) REFERENCES qwat_vl.visible(vl_code) MATCH FULL;


--
-- Name: pressurecontrol pressurecontrol_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurecontrol
    ADD CONSTRAINT pressurecontrol_fk_type FOREIGN KEY (fk_pressurecontrol_type) REFERENCES qwat_vl.pressurecontrol_type(id) MATCH FULL;


--
-- Name: pressurecontrol pressurecontrol_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurecontrol
    ADD CONSTRAINT pressurecontrol_id_fkey FOREIGN KEY (id) REFERENCES installation(id);


--
-- Name: pressurezone pressurezone_fk_consumptionzone; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone
    ADD CONSTRAINT pressurezone_fk_consumptionzone FOREIGN KEY (fk_consumptionzone) REFERENCES consumptionzone(id) MATCH FULL;


--
-- Name: pressurezone pressurezone_fk_distributor; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone
    ADD CONSTRAINT pressurezone_fk_distributor FOREIGN KEY (fk_distributor) REFERENCES distributor(id) MATCH FULL;


--
-- Name: pressurezone pressurezone_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone
    ADD CONSTRAINT pressurezone_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: pressurezone pressurezone_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pressurezone
    ADD CONSTRAINT pressurezone_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: printmap printmap_fk_district; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY printmap
    ADD CONSTRAINT printmap_fk_district FOREIGN KEY (fk_district) REFERENCES district(id) MATCH FULL;


--
-- Name: printmap printmap_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY printmap
    ADD CONSTRAINT printmap_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: printmap printmap_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY printmap
    ADD CONSTRAINT printmap_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: protectionzone protectionzone_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY protectionzone
    ADD CONSTRAINT protectionzone_fk_type FOREIGN KEY (fk_type) REFERENCES qwat_vl.protectionzone_type(id) MATCH FULL;


--
-- Name: pump pump_fk_pipe_in; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pump
    ADD CONSTRAINT pump_fk_pipe_in FOREIGN KEY (fk_pipe_in) REFERENCES pipe(id) MATCH FULL;


--
-- Name: pump pump_fk_pipe_out; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pump
    ADD CONSTRAINT pump_fk_pipe_out FOREIGN KEY (fk_pipe_out) REFERENCES pipe(id) MATCH FULL;


--
-- Name: pump pump_fk_pump_operating; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pump
    ADD CONSTRAINT pump_fk_pump_operating FOREIGN KEY (fk_pump_operating) REFERENCES qwat_vl.pump_operating(id) MATCH FULL;


--
-- Name: pump pump_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pump
    ADD CONSTRAINT pump_fk_type FOREIGN KEY (fk_pump_type) REFERENCES qwat_vl.pump_type(id) MATCH FULL;


--
-- Name: pump pump_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY pump
    ADD CONSTRAINT pump_id_fkey FOREIGN KEY (id) REFERENCES installation(id);


--
-- Name: remote remote_fk_distributor; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_fk_distributor FOREIGN KEY (fk_distributor) REFERENCES distributor(id) MATCH FULL;


--
-- Name: remote remote_fk_material; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_fk_material FOREIGN KEY (fk_material) REFERENCES qwat_vl.pipe_material(id) MATCH FULL;


--
-- Name: remote remote_fk_precision; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_fk_precision FOREIGN KEY (fk_precision) REFERENCES qwat_vl."precision"(id) MATCH FULL;


--
-- Name: remote remote_fk_status; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_fk_status FOREIGN KEY (fk_status) REFERENCES qwat_vl.status(id) MATCH FULL;


--
-- Name: remote remote_label_1_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_label_1_visible FOREIGN KEY (label_1_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: remote remote_label_2_visible; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY remote
    ADD CONSTRAINT remote_label_2_visible FOREIGN KEY (label_2_visible) REFERENCES qwat_vl.visible(vl_code_int);


--
-- Name: samplingpoint samplingpoint_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY samplingpoint
    ADD CONSTRAINT samplingpoint_id_fkey FOREIGN KEY (id) REFERENCES network_element(id);


--
-- Name: source source_fk_source_quality; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY source
    ADD CONSTRAINT source_fk_source_quality FOREIGN KEY (fk_source_quality) REFERENCES qwat_vl.source_quality(id) MATCH FULL;


--
-- Name: source source_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY source
    ADD CONSTRAINT source_fk_type FOREIGN KEY (fk_source_type) REFERENCES qwat_vl.source_type(id) MATCH FULL;


--
-- Name: source source_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY source
    ADD CONSTRAINT source_id_fkey FOREIGN KEY (id) REFERENCES installation(id);


--
-- Name: subscriber subscriber_fk_pipe; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber
    ADD CONSTRAINT subscriber_fk_pipe FOREIGN KEY (fk_pipe) REFERENCES pipe(id) MATCH FULL;


--
-- Name: subscriber subscriber_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber
    ADD CONSTRAINT subscriber_fk_type FOREIGN KEY (fk_subscriber_type) REFERENCES qwat_vl.subscriber_type(id) MATCH FULL;


--
-- Name: subscriber subscriber_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber
    ADD CONSTRAINT subscriber_id_fkey FOREIGN KEY (id) REFERENCES network_element(id);


--
-- Name: subscriber_reference subscriber_reference_fk_subscriber; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY subscriber_reference
    ADD CONSTRAINT subscriber_reference_fk_subscriber FOREIGN KEY (fk_subscriber) REFERENCES subscriber(id) MATCH FULL;


--
-- Name: surveypoint surveypoint_fk_folder; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY surveypoint
    ADD CONSTRAINT surveypoint_fk_folder FOREIGN KEY (fk_folder) REFERENCES folder(id) MATCH FULL;


--
-- Name: surveypoint surveypoint_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY surveypoint
    ADD CONSTRAINT surveypoint_fk_type FOREIGN KEY (fk_survey_type) REFERENCES qwat_vl.survey_type(id) MATCH FULL;


--
-- Name: surveypoint surveypoint_fk_worker; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY surveypoint
    ADD CONSTRAINT surveypoint_fk_worker FOREIGN KEY (fk_worker) REFERENCES worker(id) MATCH FULL;


--
-- Name: surveypoint surveypoint_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY surveypoint
    ADD CONSTRAINT surveypoint_id_fkey FOREIGN KEY (id) REFERENCES surveypoint(id);


--
-- Name: tank tank_cistern1type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY tank
    ADD CONSTRAINT tank_cistern1type FOREIGN KEY (cistern1_fk_type) REFERENCES qwat_vl.cistern(id) MATCH FULL;


--
-- Name: tank tank_cistern2type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY tank
    ADD CONSTRAINT tank_cistern2type FOREIGN KEY (cistern2_fk_type) REFERENCES qwat_vl.cistern(id) MATCH FULL;


--
-- Name: tank tank_fk_overflow; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY tank
    ADD CONSTRAINT tank_fk_overflow FOREIGN KEY (fk_overflow) REFERENCES qwat_vl.overflow(id) MATCH FULL;


--
-- Name: tank tank_fk_tank_firestorage; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY tank
    ADD CONSTRAINT tank_fk_tank_firestorage FOREIGN KEY (fk_tank_firestorage) REFERENCES qwat_vl.tank_firestorage(id) MATCH FULL;


--
-- Name: tank tank_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY tank
    ADD CONSTRAINT tank_id_fkey FOREIGN KEY (id) REFERENCES installation(id);


--
-- Name: treatment treatment_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY treatment
    ADD CONSTRAINT treatment_id_fkey FOREIGN KEY (id) REFERENCES installation(id);


--
-- Name: valve valve_fk_function; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_fk_function FOREIGN KEY (fk_valve_function) REFERENCES qwat_vl.valve_function(id) MATCH FULL;


--
-- Name: valve valve_fk_handle_precision; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_fk_handle_precision FOREIGN KEY (fk_handle_precision) REFERENCES qwat_vl."precision"(id) MATCH FULL;


--
-- Name: valve valve_fk_handle_precisionalti; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_fk_handle_precisionalti FOREIGN KEY (fk_handle_precisionalti) REFERENCES qwat_vl.precisionalti(id) MATCH FULL;


--
-- Name: valve valve_fk_pipe; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_fk_pipe FOREIGN KEY (fk_pipe) REFERENCES pipe(id) MATCH FULL;


--
-- Name: valve valve_fk_type; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_fk_type FOREIGN KEY (fk_valve_type) REFERENCES qwat_vl.valve_type(id) MATCH FULL;


--
-- Name: valve valve_fk_valve_actuation; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_fk_valve_actuation FOREIGN KEY (fk_valve_actuation) REFERENCES qwat_vl.valve_actuation(id) MATCH FULL;


--
-- Name: valve valve_id_fkey; Type: FK CONSTRAINT; Schema: qwat_od; Owner: postgres
--

ALTER TABLE ONLY valve
    ADD CONSTRAINT valve_id_fkey FOREIGN KEY (id) REFERENCES network_element(id);


--
-- Name: qwat_dr; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA qwat_dr TO qwat_user;
GRANT USAGE ON SCHEMA qwat_dr TO qwat_viewer;


--
-- Name: qwat_od; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA qwat_od TO qwat_user;
GRANT USAGE ON SCHEMA qwat_od TO qwat_viewer;


--
-- Name: qwat_sys; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA qwat_sys TO qwat_sysadmin;
GRANT USAGE ON SCHEMA qwat_sys TO qwat_viewer;


--
-- Name: qwat_vl; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA qwat_vl TO qwat_manager;
GRANT USAGE ON SCHEMA qwat_vl TO qwat_viewer;


SET search_path = qwat_dr, pg_catalog;

--
-- Name: annotationline; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE annotationline TO qwat_viewer;
GRANT ALL ON TABLE annotationline TO qwat_user;


--
-- Name: annotationline_id_seq; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE annotationline_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE annotationline_id_seq TO qwat_user;


--
-- Name: annotationpoint; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE annotationpoint TO qwat_viewer;
GRANT ALL ON TABLE annotationpoint TO qwat_user;


--
-- Name: annotationpoint_id_seq; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE annotationpoint_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE annotationpoint_id_seq TO qwat_user;


--
-- Name: constructionpoint; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE constructionpoint TO qwat_viewer;
GRANT ALL ON TABLE constructionpoint TO qwat_user;


--
-- Name: constructionpoint_id_seq; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE constructionpoint_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE constructionpoint_id_seq TO qwat_user;


--
-- Name: dimension_distance; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE dimension_distance TO qwat_viewer;
GRANT ALL ON TABLE dimension_distance TO qwat_user;


--
-- Name: dimension_distance_id_seq; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE dimension_distance_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE dimension_distance_id_seq TO qwat_user;


--
-- Name: dimension_orientation; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE dimension_orientation TO qwat_viewer;
GRANT ALL ON TABLE dimension_orientation TO qwat_user;


--
-- Name: dimension_orientation_id_seq; Type: ACL; Schema: qwat_dr; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE dimension_orientation_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE dimension_orientation_id_seq TO qwat_user;


SET search_path = qwat_od, pg_catalog;

--
-- Name: chamber; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE chamber TO qwat_viewer;
GRANT ALL ON TABLE chamber TO qwat_user;
GRANT ALL ON TABLE chamber TO qwat_manager;


--
-- Name: consumptionzone; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE consumptionzone TO qwat_viewer;
GRANT ALL ON TABLE consumptionzone TO qwat_user;
GRANT ALL ON TABLE consumptionzone TO qwat_manager;


--
-- Name: consumptionzone_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE consumptionzone_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE consumptionzone_id_seq TO qwat_user;


--
-- Name: cover; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE cover TO qwat_viewer;
GRANT ALL ON TABLE cover TO qwat_user;
GRANT ALL ON TABLE cover TO qwat_manager;


--
-- Name: cover_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE cover_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE cover_id_seq TO qwat_user;


--
-- Name: crossing; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE crossing TO qwat_viewer;
GRANT ALL ON TABLE crossing TO qwat_user;
GRANT ALL ON TABLE crossing TO qwat_manager;


--
-- Name: crossing_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE crossing_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE crossing_id_seq TO qwat_user;


--
-- Name: distributor; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE distributor TO qwat_viewer;
GRANT ALL ON TABLE distributor TO qwat_user;
GRANT ALL ON TABLE distributor TO qwat_manager;


--
-- Name: distributor_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE distributor_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE distributor_id_seq TO qwat_user;


--
-- Name: district; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE district TO qwat_viewer;
GRANT ALL ON TABLE district TO qwat_user;
GRANT ALL ON TABLE district TO qwat_manager;


--
-- Name: district_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE district_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE district_id_seq TO qwat_user;


--
-- Name: folder; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE folder TO qwat_viewer;
GRANT ALL ON TABLE folder TO qwat_user;
GRANT ALL ON TABLE folder TO qwat_manager;


--
-- Name: folder_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE folder_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE folder_id_seq TO qwat_user;


--
-- Name: hydrant; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE hydrant TO qwat_viewer;
GRANT ALL ON TABLE hydrant TO qwat_user;
GRANT ALL ON TABLE hydrant TO qwat_manager;


--
-- Name: installation; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE installation TO qwat_viewer;
GRANT ALL ON TABLE installation TO qwat_user;
GRANT ALL ON TABLE installation TO qwat_manager;


--
-- Name: leak; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE leak TO qwat_viewer;
GRANT ALL ON TABLE leak TO qwat_user;
GRANT ALL ON TABLE leak TO qwat_manager;


--
-- Name: leak_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE leak_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE leak_id_seq TO qwat_user;


--
-- Name: meter; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE meter TO qwat_viewer;
GRANT ALL ON TABLE meter TO qwat_user;
GRANT ALL ON TABLE meter TO qwat_manager;


--
-- Name: meter_reference; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE meter_reference TO qwat_viewer;
GRANT ALL ON TABLE meter_reference TO qwat_user;
GRANT ALL ON TABLE meter_reference TO qwat_manager;


--
-- Name: meter_reference_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE meter_reference_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE meter_reference_id_seq TO qwat_user;


--
-- Name: network_element; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE network_element TO qwat_viewer;
GRANT ALL ON TABLE network_element TO qwat_user;
GRANT ALL ON TABLE network_element TO qwat_manager;


--
-- Name: node; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE node TO qwat_viewer;
GRANT ALL ON TABLE node TO qwat_user;
GRANT ALL ON TABLE node TO qwat_manager;


--
-- Name: node_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE node_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE node_id_seq TO qwat_user;


--
-- Name: part; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE part TO qwat_viewer;
GRANT ALL ON TABLE part TO qwat_user;
GRANT ALL ON TABLE part TO qwat_manager;


--
-- Name: pipe; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pipe TO qwat_viewer;
GRANT ALL ON TABLE pipe TO qwat_user;
GRANT ALL ON TABLE pipe TO qwat_manager;


--
-- Name: pipe_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE pipe_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE pipe_id_seq TO qwat_user;


--
-- Name: pressurecontrol; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pressurecontrol TO qwat_viewer;
GRANT ALL ON TABLE pressurecontrol TO qwat_user;
GRANT ALL ON TABLE pressurecontrol TO qwat_manager;


--
-- Name: pressurezone; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pressurezone TO qwat_viewer;
GRANT ALL ON TABLE pressurezone TO qwat_user;
GRANT ALL ON TABLE pressurezone TO qwat_manager;


--
-- Name: pressurezone_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE pressurezone_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE pressurezone_id_seq TO qwat_user;


--
-- Name: printmap; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE printmap TO qwat_viewer;
GRANT ALL ON TABLE printmap TO qwat_user;
GRANT ALL ON TABLE printmap TO qwat_manager;


--
-- Name: printmap_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE printmap_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE printmap_id_seq TO qwat_user;


--
-- Name: protectionzone; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE protectionzone TO qwat_viewer;
GRANT ALL ON TABLE protectionzone TO qwat_user;
GRANT ALL ON TABLE protectionzone TO qwat_manager;


--
-- Name: protectionzone_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE protectionzone_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE protectionzone_id_seq TO qwat_user;


--
-- Name: pump; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pump TO qwat_viewer;
GRANT ALL ON TABLE pump TO qwat_user;
GRANT ALL ON TABLE pump TO qwat_manager;


--
-- Name: remote; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE remote TO qwat_viewer;
GRANT ALL ON TABLE remote TO qwat_user;
GRANT ALL ON TABLE remote TO qwat_manager;


--
-- Name: remote_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE remote_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE remote_id_seq TO qwat_user;


--
-- Name: samplingpoint; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE samplingpoint TO qwat_viewer;
GRANT ALL ON TABLE samplingpoint TO qwat_user;
GRANT ALL ON TABLE samplingpoint TO qwat_manager;


--
-- Name: source; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE source TO qwat_viewer;
GRANT ALL ON TABLE source TO qwat_user;
GRANT ALL ON TABLE source TO qwat_manager;


--
-- Name: subscriber; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE subscriber TO qwat_viewer;
GRANT ALL ON TABLE subscriber TO qwat_user;
GRANT ALL ON TABLE subscriber TO qwat_manager;


--
-- Name: subscriber_reference; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE subscriber_reference TO qwat_viewer;
GRANT ALL ON TABLE subscriber_reference TO qwat_user;
GRANT ALL ON TABLE subscriber_reference TO qwat_manager;


--
-- Name: subscriber_reference_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE subscriber_reference_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE subscriber_reference_id_seq TO qwat_user;


--
-- Name: surveypoint; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE surveypoint TO qwat_viewer;
GRANT ALL ON TABLE surveypoint TO qwat_user;
GRANT ALL ON TABLE surveypoint TO qwat_manager;


--
-- Name: tank; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tank TO qwat_viewer;
GRANT ALL ON TABLE tank TO qwat_user;
GRANT ALL ON TABLE tank TO qwat_manager;


--
-- Name: treatment; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE treatment TO qwat_viewer;
GRANT ALL ON TABLE treatment TO qwat_user;
GRANT ALL ON TABLE treatment TO qwat_manager;


--
-- Name: valve; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE valve TO qwat_viewer;
GRANT ALL ON TABLE valve TO qwat_user;
GRANT ALL ON TABLE valve TO qwat_manager;


--
-- Name: vw_consumptionzone; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_consumptionzone TO qwat_viewer;
GRANT ALL ON TABLE vw_consumptionzone TO qwat_user;
GRANT ALL ON TABLE vw_consumptionzone TO qwat_manager;


--
-- Name: vw_node_element; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_node_element TO qwat_viewer;
GRANT ALL ON TABLE vw_node_element TO qwat_user;
GRANT ALL ON TABLE vw_node_element TO qwat_manager;


--
-- Name: vw_element_hydrant; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_hydrant TO qwat_viewer;
GRANT ALL ON TABLE vw_element_hydrant TO qwat_user;
GRANT ALL ON TABLE vw_element_hydrant TO qwat_manager;


--
-- Name: vw_qwat_installation; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_qwat_installation TO qwat_viewer;
GRANT ALL ON TABLE vw_qwat_installation TO qwat_user;
GRANT ALL ON TABLE vw_qwat_installation TO qwat_manager;


--
-- Name: vw_element_installation; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_installation TO qwat_viewer;
GRANT ALL ON TABLE vw_element_installation TO qwat_user;
GRANT ALL ON TABLE vw_element_installation TO qwat_manager;


--
-- Name: vw_element_meter; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_meter TO qwat_viewer;
GRANT ALL ON TABLE vw_element_meter TO qwat_user;
GRANT ALL ON TABLE vw_element_meter TO qwat_manager;


--
-- Name: vw_element_part; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_part TO qwat_viewer;
GRANT ALL ON TABLE vw_element_part TO qwat_user;
GRANT ALL ON TABLE vw_element_part TO qwat_manager;


--
-- Name: vw_element_samplingpoint; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_samplingpoint TO qwat_viewer;
GRANT ALL ON TABLE vw_element_samplingpoint TO qwat_user;
GRANT ALL ON TABLE vw_element_samplingpoint TO qwat_manager;


--
-- Name: vw_element_subscriber; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_subscriber TO qwat_viewer;
GRANT ALL ON TABLE vw_element_subscriber TO qwat_user;
GRANT ALL ON TABLE vw_element_subscriber TO qwat_manager;


--
-- Name: vw_element_valve; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_element_valve TO qwat_viewer;
GRANT ALL ON TABLE vw_element_valve TO qwat_user;
GRANT ALL ON TABLE vw_element_valve TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: value_list_base; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE value_list_base TO qwat_viewer;


--
-- Name: hydrant_material; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE hydrant_material TO qwat_viewer;


--
-- Name: hydrant_model_inf; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE hydrant_model_inf TO qwat_viewer;


--
-- Name: hydrant_model_sup; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE hydrant_model_sup TO qwat_viewer;


--
-- Name: hydrant_output; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE hydrant_output TO qwat_viewer;


--
-- Name: hydrant_provider; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE hydrant_provider TO qwat_viewer;


--
-- Name: object_reference; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE object_reference TO qwat_viewer;


--
-- Name: precision; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE "precision" TO qwat_viewer;


--
-- Name: precisionalti; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE precisionalti TO qwat_viewer;


--
-- Name: status; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE status TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_hydrant; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_hydrant TO qwat_viewer;
GRANT ALL ON TABLE vw_export_hydrant TO qwat_user;
GRANT ALL ON TABLE vw_export_hydrant TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: cistern; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE cistern TO qwat_viewer;


--
-- Name: overflow; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE overflow TO qwat_viewer;


--
-- Name: pressurecontrol_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pressurecontrol_type TO qwat_viewer;


--
-- Name: pump_operating; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pump_operating TO qwat_viewer;


--
-- Name: pump_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pump_type TO qwat_viewer;


--
-- Name: remote_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE remote_type TO qwat_viewer;


--
-- Name: source_quality; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE source_quality TO qwat_viewer;


--
-- Name: source_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE source_type TO qwat_viewer;


--
-- Name: tank_firestorage; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tank_firestorage TO qwat_viewer;


--
-- Name: watertype; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE watertype TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_installation; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_installation TO qwat_viewer;
GRANT ALL ON TABLE vw_export_installation TO qwat_user;
GRANT ALL ON TABLE vw_export_installation TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: pipe_function; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pipe_function TO qwat_viewer;


--
-- Name: pipe_installmethod; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pipe_installmethod TO qwat_viewer;


--
-- Name: pipe_material; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pipe_material TO qwat_viewer;


--
-- Name: pipe_protection; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE pipe_protection TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_pipe; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_pipe TO qwat_viewer;
GRANT ALL ON TABLE vw_export_pipe TO qwat_user;
GRANT ALL ON TABLE vw_export_pipe TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: leak_cause; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE leak_cause TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_leak; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_leak TO qwat_viewer;
GRANT ALL ON TABLE vw_export_leak TO qwat_user;
GRANT ALL ON TABLE vw_export_leak TO qwat_manager;


--
-- Name: vw_export_meter; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_meter TO qwat_viewer;
GRANT ALL ON TABLE vw_export_meter TO qwat_user;
GRANT ALL ON TABLE vw_export_meter TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: part_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE part_type TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_part; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_part TO qwat_viewer;
GRANT ALL ON TABLE vw_export_part TO qwat_user;
GRANT ALL ON TABLE vw_export_part TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: subscriber_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE subscriber_type TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_subscriber; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_subscriber TO qwat_viewer;
GRANT ALL ON TABLE vw_export_subscriber TO qwat_user;
GRANT ALL ON TABLE vw_export_subscriber TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: valve_actuation; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE valve_actuation TO qwat_viewer;


--
-- Name: valve_function; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE valve_function TO qwat_viewer;


--
-- Name: valve_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE valve_type TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_export_valve; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_export_valve TO qwat_viewer;
GRANT ALL ON TABLE vw_export_valve TO qwat_user;
GRANT ALL ON TABLE vw_export_valve TO qwat_manager;


--
-- Name: vw_installation_chamber; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_installation_chamber TO qwat_viewer;
GRANT ALL ON TABLE vw_installation_chamber TO qwat_user;
GRANT ALL ON TABLE vw_installation_chamber TO qwat_manager;


--
-- Name: vw_installation_pressurecontrol; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_installation_pressurecontrol TO qwat_viewer;
GRANT ALL ON TABLE vw_installation_pressurecontrol TO qwat_user;
GRANT ALL ON TABLE vw_installation_pressurecontrol TO qwat_manager;


--
-- Name: vw_installation_pump; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_installation_pump TO qwat_viewer;
GRANT ALL ON TABLE vw_installation_pump TO qwat_user;
GRANT ALL ON TABLE vw_installation_pump TO qwat_manager;


--
-- Name: vw_installation_source; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_installation_source TO qwat_viewer;
GRANT ALL ON TABLE vw_installation_source TO qwat_user;
GRANT ALL ON TABLE vw_installation_source TO qwat_manager;


--
-- Name: vw_installation_tank; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_installation_tank TO qwat_viewer;
GRANT ALL ON TABLE vw_installation_tank TO qwat_user;
GRANT ALL ON TABLE vw_installation_tank TO qwat_manager;


--
-- Name: vw_installation_treatment; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_installation_treatment TO qwat_viewer;
GRANT ALL ON TABLE vw_installation_treatment TO qwat_user;
GRANT ALL ON TABLE vw_installation_treatment TO qwat_manager;


--
-- Name: vw_pipe_child_parent; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_pipe_child_parent TO qwat_viewer;
GRANT ALL ON TABLE vw_pipe_child_parent TO qwat_user;
GRANT ALL ON TABLE vw_pipe_child_parent TO qwat_manager;


--
-- Name: vw_pipe_schema_visibleitems; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_pipe_schema_visibleitems TO qwat_viewer;
GRANT ALL ON TABLE vw_pipe_schema_visibleitems TO qwat_user;
GRANT ALL ON TABLE vw_pipe_schema_visibleitems TO qwat_manager;


--
-- Name: vw_pipe_schema_merged; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_pipe_schema_merged TO qwat_viewer;
GRANT ALL ON TABLE vw_pipe_schema_merged TO qwat_user;
GRANT ALL ON TABLE vw_pipe_schema_merged TO qwat_manager;


--
-- Name: vw_pipe_schema; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_pipe_schema TO qwat_viewer;
GRANT ALL ON TABLE vw_pipe_schema TO qwat_user;
GRANT ALL ON TABLE vw_pipe_schema TO qwat_manager;


--
-- Name: vw_pipe_schema_error; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_pipe_schema_error TO qwat_viewer;
GRANT ALL ON TABLE vw_pipe_schema_error TO qwat_user;
GRANT ALL ON TABLE vw_pipe_schema_error TO qwat_manager;


--
-- Name: vw_printmap; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_printmap TO qwat_viewer;
GRANT ALL ON TABLE vw_printmap TO qwat_user;
GRANT ALL ON TABLE vw_printmap TO qwat_manager;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: protectionzone_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE protectionzone_type TO qwat_viewer;


SET search_path = qwat_od, pg_catalog;

--
-- Name: vw_protectionzone; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_protectionzone TO qwat_viewer;
GRANT ALL ON TABLE vw_protectionzone TO qwat_user;
GRANT ALL ON TABLE vw_protectionzone TO qwat_manager;


--
-- Name: vw_qwat_network_element; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_qwat_network_element TO qwat_viewer;
GRANT ALL ON TABLE vw_qwat_network_element TO qwat_user;
GRANT ALL ON TABLE vw_qwat_network_element TO qwat_manager;


--
-- Name: vw_qwat_node; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_qwat_node TO qwat_viewer;
GRANT ALL ON TABLE vw_qwat_node TO qwat_user;
GRANT ALL ON TABLE vw_qwat_node TO qwat_manager;


--
-- Name: vw_remote; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_remote TO qwat_viewer;
GRANT ALL ON TABLE vw_remote TO qwat_user;
GRANT ALL ON TABLE vw_remote TO qwat_manager;


--
-- Name: vw_search_view; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_search_view TO qwat_viewer;
GRANT ALL ON TABLE vw_search_view TO qwat_user;
GRANT ALL ON TABLE vw_search_view TO qwat_manager;


--
-- Name: vw_subscriber_pipe_relation; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_subscriber_pipe_relation TO qwat_viewer;
GRANT ALL ON TABLE vw_subscriber_pipe_relation TO qwat_user;
GRANT ALL ON TABLE vw_subscriber_pipe_relation TO qwat_manager;


--
-- Name: vw_valve_lines; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE vw_valve_lines TO qwat_viewer;
GRANT ALL ON TABLE vw_valve_lines TO qwat_user;
GRANT ALL ON TABLE vw_valve_lines TO qwat_manager;


--
-- Name: worker; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE worker TO qwat_viewer;
GRANT ALL ON TABLE worker TO qwat_user;
GRANT ALL ON TABLE worker TO qwat_manager;


--
-- Name: worker_id_seq; Type: ACL; Schema: qwat_od; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE worker_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE worker_id_seq TO qwat_user;


SET search_path = qwat_sys, pg_catalog;

--
-- Name: logged_actions; Type: ACL; Schema: qwat_sys; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE logged_actions TO qwat_viewer;
GRANT ALL ON TABLE logged_actions TO qwat_sysadmin;


--
-- Name: logged_actions_event_id_seq; Type: ACL; Schema: qwat_sys; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE logged_actions_event_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE logged_actions_event_id_seq TO qwat_sysadmin;


--
-- Name: settings; Type: ACL; Schema: qwat_sys; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE settings TO qwat_viewer;
GRANT ALL ON TABLE settings TO qwat_sysadmin;


--
-- Name: settings_id_seq; Type: ACL; Schema: qwat_sys; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE settings_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE settings_id_seq TO qwat_sysadmin;


--
-- Name: versions; Type: ACL; Schema: qwat_sys; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE versions TO qwat_viewer;
GRANT ALL ON TABLE versions TO qwat_sysadmin;


--
-- Name: versions_id_seq; Type: ACL; Schema: qwat_sys; Owner: postgres
--

GRANT SELECT,USAGE ON SEQUENCE versions_id_seq TO qwat_viewer;
GRANT ALL ON SEQUENCE versions_id_seq TO qwat_sysadmin;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: bedding; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE bedding TO qwat_viewer;


--
-- Name: cover_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE cover_type TO qwat_viewer;


--
-- Name: locationtype; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE locationtype TO qwat_viewer;


--
-- Name: survey_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE survey_type TO qwat_viewer;


--
-- Name: valve_maintenance; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE valve_maintenance TO qwat_viewer;


--
-- Name: visible; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE visible TO qwat_viewer;


--
-- Name: worker_type; Type: ACL; Schema: qwat_vl; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE worker_type TO qwat_viewer;


SET search_path = qwat_dr, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: qwat_dr; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_dr REVOKE ALL ON SEQUENCES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_dr GRANT ALL ON SEQUENCES  TO qwat_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: qwat_dr; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_dr REVOKE ALL ON TABLES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_dr GRANT SELECT,REFERENCES,TRIGGER ON TABLES  TO qwat_viewer;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_dr GRANT ALL ON TABLES  TO qwat_user;


SET search_path = qwat_od, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: qwat_od; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_od REVOKE ALL ON SEQUENCES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_od GRANT ALL ON SEQUENCES  TO qwat_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: qwat_od; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_od REVOKE ALL ON TABLES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_od GRANT SELECT,REFERENCES,TRIGGER ON TABLES  TO qwat_viewer;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_od GRANT ALL ON TABLES  TO qwat_user;


SET search_path = qwat_sys, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: qwat_sys; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_sys REVOKE ALL ON SEQUENCES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_sys GRANT ALL ON SEQUENCES  TO qwat_sysadmin;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: qwat_sys; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_sys REVOKE ALL ON TABLES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_sys GRANT SELECT,REFERENCES,TRIGGER ON TABLES  TO qwat_viewer;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_sys GRANT ALL ON TABLES  TO qwat_sysadmin;


SET search_path = qwat_vl, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: qwat_vl; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_vl REVOKE ALL ON SEQUENCES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_vl GRANT ALL ON SEQUENCES  TO qwat_manager;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: qwat_vl; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_vl REVOKE ALL ON TABLES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_vl GRANT SELECT,REFERENCES,TRIGGER ON TABLES  TO qwat_viewer;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA qwat_vl GRANT ALL ON TABLES  TO qwat_manager;


--
-- PostgreSQL database dump complete
--

